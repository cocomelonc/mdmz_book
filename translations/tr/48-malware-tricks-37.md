\newpage
\subsection{48. kötü amaçlı yazılım geliştirme tekniği.  
VirtualQueryEx ile İşlem modüllerini listeleme. Basit C++ örneği.}

﷽

![hack](./images/110/2023-11-08_17-31.png){width="80%"}      

Bugün, bu gönderi, hedef işlemin modüllerinin listesini almak için kullanılan başka bir popüler kötü amaçlı yazılım geliştirme tekniği hakkındaki kendi araştırmamın sonucudur.     

Bu, önceki gönderimdeki modül listesini alma tekniğine benzer, ancak bu durumda [VirtualQueryEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex) kullanıyorum.

### pratik örnek

Öncelikle, hedef işlemin PID'sini bulmak için bir yöntem kullanıyoruz. Örneğin, ben [şu](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html) yöntemi kullandım:     

```cpp
typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ph,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE Newph
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = (fNtGetNextProcess) 
  GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}
```

Ardından, belirtilen işlemi açan, `VirtualQueryEx` kullanarak bellek bölgelerinde döngü oluşturan ve yüklenen modüller hakkında (isimleri ve temel adresleri dahil) bilgi alan bir fonksiyon oluşturun:    

```cpp
// function to list modules loaded by a specified process
int listModulesOfProcess(int pid) {
  HANDLE ph;
  MEMORY_BASIC_INFORMATION mbi;
  char * base = NULL;

  ph = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
  if (ph == NULL)
    return -1;

  printf("modules found:\n");
  printf("name\t\t\t base address\n");
  printf("======================================================================\n");

  while (VirtualQueryEx(ph, base, &mbi, sizeof(mbi)) == 
  sizeof(MEMORY_BASIC_INFORMATION)) {
    char szModName[MAX_PATH];

    // only focus on the base address regions
    if ((mbi.AllocationBase == mbi.BaseAddress) && (mbi.AllocationBase != NULL)) {
      if (GetModuleFileNameEx(ph, (HMODULE) mbi.AllocationBase, 
      (LPSTR) szModName, sizeof(szModName) / sizeof(TCHAR)))
        printf("%#25s\t\t%#10llx\n", szModName, 
        (unsigned long long)mbi.AllocationBase);
      }
      // check the next region
      base += mbi.RegionSize;
    }
  
  CloseHandle(ph);
  return 0;
}
```

Gördüğünüz gibi, kod `VirtualQueryEx` fonksiyonu başarılı bir şekilde bellek bilgisi aldığı sürece devam eden bir whiledöngüsüne girer. Bu döngü, hedef işlemin bellek bölgeleri boyunca iterasyon yapar.     

Daha sonra, mevcut bellek bölgesinin `AllocationBase` değerinin `BaseAddress` ile eşleşip eşleşmediğini kontrol eder. Bu koşul, yalnızca temel adres bölgelerine odaklanılmasını sağlar.Eğer koşullar sağlanırsa, modül adını almak için devam eder.     

`if (GetModuleFileNameEx(ph, (HMODULE) mbi.AllocationBase, (LPSTR) szModName, sizeof(szModName) / sizeof(TCHAR)))` - `GetModuleFileNameEx` fonksiyonu çağrılarak, mevcut bellek bölgesinin temel adresiyle ilişkili modül dosya adı alınır. Eğer başarılı olursa, dosya adı `szModName` değişkenine kaydedilir.      

Eğer modül adı alma işlemi başarılı olursa, kod modül adını ve temel adresini biçimlendirilmiş bir şekilde ekrana yazdırır.     

Mevcut bölge işlendikten sonra, temel adres göstergesi bölgenin boyutu kadar artırılır ve döngünün bir sonraki iterasyonunda sonraki bölge kontrol edilir.

Hepsi bu kadar.     

Tam kaynak kodu şu şekildedir (`hack.c`):

```cpp
/*
 * hack.c - get the list of 
 * modules of the process via VirtualQueryEx. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2023/11/07/malware-tricks-37.html
*/
#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <shlwapi.h>
#include <psapi.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "shlwapi.lib")

typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ph,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE Newph
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = (fNtGetNextProcess) 
  GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}

// function to list modules loaded by a specified process
int listModulesOfProcess(int pid) {
  HANDLE ph;
  MEMORY_BASIC_INFORMATION mbi;
  char * base = NULL;

  ph = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
  if (ph == NULL)
    return -1;

  printf("modules found:\n");
  printf("name\t\t\t base address\n");
  printf("=====================================================================\n");

  while (VirtualQueryEx(ph, base, &mbi, sizeof(mbi)) == 
  sizeof(MEMORY_BASIC_INFORMATION)) {
    char szModName[MAX_PATH];

    // only focus on the base address regions
    if ((mbi.AllocationBase == mbi.BaseAddress) && (mbi.AllocationBase != NULL)) {
      if (GetModuleFileNameEx(ph, (HMODULE) mbi.AllocationBase, 
      (LPSTR) szModName, sizeof(szModName) / sizeof(TCHAR)))
        printf("%#25s\t\t%#10llx\n", szModName, (unsigned long long)mbi.AllocationBase);
      }
      // check the next region
      base += mbi.RegionSize;
    }
  
  CloseHandle(ph);
  return 0;
}

int main(int argc, char* argv[]) {
  int pid = 0; // process ID
  pid = findMyProc(argv[1]);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);
  if (pid != 0)
    listModulesOfProcess(pid);
  return 0;
}
```

### demo

Haydi, bu mantığı çalışırken görelim.    

Derleyin:      
```bash
x86_64-w64-mingw32-g++ -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive -lpsapi -lshlwapi
```

![hack](./images/110/2023-11-08_17-15.png){width="80%"}      

Daha sonra, hedef süreci kurbanın makinesinde açın:      

![hack](./images/110/2023-11-08_16-41.png){width="80%"}      

Ve sadece `hack.exe`'yi çalıştırın:     

```powershell
.\hack.exe mspaint.exe
```

![hack](./images/110/2023-11-08_17-13.png){width="80%"}      

![hack](./images/110/2023-11-08_17-14.png){width="80%"}      

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=     

Bu kodun belirli Windows API'lerine bağımlılığı ve bazı sınırlamaları olabileceğini unutmayın. Ayrıca, işlem kimliğini belirlemek için işlem adını kullanır, ki bu her zaman benzersiz olmayabilir.     

Bu kod, adli bilişim veya mavi takım pratik vakalarında süreç belleğiyle çalışmak için kendi betiğinizi geliştirmenize de yardımcı olabilir.      

Umarım bu gönderi, mavi takım üyelerinin bu ilginç zararlı yazılım geliştirme tekniği hakkında farkındalığını artırır ve kırmızı takım üyeleri için bir silah ekler.     

[VirtualQueryEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex)    
[GetModuleFileNameEx](https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa)    
[Find process ID by name and inject to it](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html)     
[Find PID via NtGetNextProcess](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html)     
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-11-07-malware-trick-37)           
