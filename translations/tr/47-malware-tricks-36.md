\newpage
\subsection{47. zararlı yazılım geliştirme taktiği. süreç modüllerini numaralandırma. Basit C++ örneği.}

﷽

![hack](./images/108/2023-09-25_13-38.png){width="80%"}      

Bugünkü yazı, hedef süreçteki modüllerin listesini almak için kullanılan bir başka popüler zararlı yazılım geliştirme tekniği üzerine kendi araştırmalarımın bir sonucudur.     

Diyelim ki, bir sürece başarılı bir şekilde DLL enjeksiyonu yaptık. Peki, DLL'imizin süreçteki modüller listesinde olup olmadığını nasıl kontrol edebiliriz?     

![hack](./images/108/2023-09-25_13-10.png){width="80%"}      

### pratik örnek

Öncelikle, hedef sürecin PID'sini bulmak için yöntemlerden birini kullanmamız gerekiyor. Örneğin, ben [şu](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html) yöntemi kullandım:         

```cpp
typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ph,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE Newph
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}
```

Sonrasında, sadece Windows API'den `Module32First` ve `Module32Next` fonksiyonlarını kullanın.    

```cpp
// function to list modules loaded by a specified process
int listModulesOfProcess(int pid) {

  HANDLE mod;
  MODULEENTRY32 me32;

  mod = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
  if (mod == INVALID_HANDLE_VALUE) { 
    printf("CreateToolhelp32Snapshot error :(\n"); 
    return -1; 
  }

  me32.dwSize = sizeof(MODULEENTRY32); 
  if (!Module32First(mod, &me32)) {
    CloseHandle(mod);
    return -1;
  }
  
  printf("modules found:\n");
  printf("name\t\t\t base address\t\t\tsize\n");
  printf("======================================================================\n");
  do {
    printf("%#25s\t\t%#10llx\t\t%#10d\n", me32.szModule, me32.modBaseAddr, 
    me32.modBaseSize);
  } while (Module32Next(mod, &me32));
  CloseHandle(mod);
  return 0;
}
```

Bu kod, `CreateToolHelp32Snapshot`, `Process32First` ve `Process32Next` ile PID arama mantığına biraz benzemektedir.       

Tam kaynak kodu şu şekildedir (`hack.c`):     

```cpp
/*
 * hack.c - get the list of modules of the process. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2023/09/25/malware-tricks-36.html
*/
#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <shlwapi.h>
#include <psapi.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "shlwapi.lib")

typedef NTSTATUS (NTAPI * fNtGetNextProcess)(
  _In_ HANDLE ph,
  _In_ ACCESS_MASK DesiredAccess,
  _In_ ULONG HandleAttributes,
  _In_ ULONG Flags,
  _Out_ PHANDLE Newph
);

int findMyProc(const char * procname) {
  int pid = 0;
  HANDLE current = NULL;
  char procName[MAX_PATH];

  // resolve function address
  fNtGetNextProcess myNtGetNextProcess = 
  (fNtGetNextProcess) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");

  // loop through all processes
  while (!myNtGetNextProcess(current, MAXIMUM_ALLOWED, 0, 0, &current)) {
    GetProcessImageFileNameA(current, procName, MAX_PATH);
    if (lstrcmpiA(procname, PathFindFileName((LPCSTR) procName)) == 0) {
      pid = GetProcessId(current);
      break;
    }
  }

  return pid;
}

// function to list modules loaded by a specified process
int listModulesOfProcess(int pid) {

  HANDLE mod;
  MODULEENTRY32 me32;

  mod = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
  if (mod == INVALID_HANDLE_VALUE) { 
    printf("CreateToolhelp32Snapshot error :(\n"); 
    return -1; 
  }

  me32.dwSize = sizeof(MODULEENTRY32); 
  if (!Module32First(mod, &me32)) {
    CloseHandle(mod);
    return -1;
  }
  
  printf("modules found:\n");
  printf("name\t\t\t base address\t\t\tsize\n");
  printf("======================================================================\n");
  do {
    printf("%#25s\t\t%#10llx\t\t%#10d\n", me32.szModule, me32.modBaseAddr, 
    me32.modBaseSize);
  } while (Module32Next(mod, &me32));
  CloseHandle(mod);
  return 0;
}

int main(int argc, char* argv[]) {
  int pid = 0; // process ID
  pid = findMyProc(argv[1]);
  printf("%s%d\n", pid > 0 ? "process found at pid = " : 
  "process not found. pid = ", pid);
  if (pid != 0)
    listModulesOfProcess(pid);
  return 0;
}
```

Bu kodu, hedef sürecin modül listesindeki belirli bir DLL'in varlığını kontrol etmek için kullanabilirsiniz.     

### demo

Hadi bu mantığı çalışırken görelim.     

Derleyelim:     

```bash
x86_64-w64-mingw32-g++ -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \ -fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive -lshlwapi
```

![hack](./images/108/2023-09-25_12-47_1.png){width="80%"}      

Ardından, hedef süreci kurbanın makinesinde açın:      

![hack](./images/108/2023-09-25_12-40.png){width="80%"}      

![hack](./images/108/2023-09-25_12-41.png){width="80%"}      

Ve sadece `hack.exe` dosyamızı çalıştırın:     

```powershell
.\hack.exe mspaint.exe
```

![hack](./images/108/2023-09-25_12-41_1.png){width="80%"}      

![hack](./images/108/2023-09-25_12-47.png){width="80%"}      

![hack](./images/108/2023-09-25_12-44.png){width="80%"}      

Ayrıca, [DLL enjeksiyon](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html) mantığını kontrol edin:    

![hack](./images/108/2023-09-25_13-36.png){width="80%"}      

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=     

Bu kodun belirli Windows API'lerine bağımlılıkları ve sınırlamaları olabileceğini unutmayın. Ayrıca, işlem kimliği için işlem adını kullanır, bu da benzersiz olmayabilir.      

Bu teknik, vahşi doğada [4H RAT](https://attack.mitre.org/software/S0065/) ve [Aria-body](https://attack.mitre.org/software/S0456/) tarafından kullanılmaktadır.

Umarım bu gönderi, mavi takım üyelerinin bu ilginç kötü amaçlı yazılım geliştirme tekniğinin farkına varmasını sağlar ve kırmızı takım üyelerinin cephaneliğine bir silah ekler.      

[Find process ID by name and inject to it](https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html)     
[Find PID via NtGetNextProcess](https://cocomelonc.github.io/malware/2023/05/26/malware-tricks-30.html)     
[4H RAT](https://attack.mitre.org/software/S0065/)      
[Aria-body](https://attack.mitre.org/software/S0456/)      
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-09-25-malware-trick-36)           
