\newpage
\subsection{40. kötü amaçlı yazılım geliştirme hilesi. WinAPI LoadLibrary uygulaması. Basit C++ örneği.}

﷽

![av-evasion](./images/94/2023-04-28_15-06.png){width="80%"}      

Bugün, araştırmamı başka bir kötü amaçlı yazılım geliştirme hilesine odaklamak istiyorum: bu, bazı durumlar ve senaryolarda antivirüs (AV) kaçışına da yardımcı olabilir. Daha önceki [GetModuleHandle](https://cocomelonc.github.io/malware/2023/04/08/malware-av-evasion-15.html) ve [GetProcAddress](https://cocomelonc.github.io/malware/2023/04/16/malware-av-evasion-16.html) uygulamalarıyla ilgili yazılarda olduğu gibi, kendi `LoadLibrary` uygulamamı yapalım mı? Hadi bunu deneyelim.     

### LoadLibrary

`LoadLibrary`, bir Windows API işlevidir ve bir dinamik bağlantı kitaplığı (`DLL`) modülünü çağıran sürecin adres alanına yüklemenizi sağlar. Bu işlev, DLL'nin adını argüman olarak alır ve yüklenen modülün bir işaretçisini döndürür. İşlev başarısız olursa, `NULL` döndürür:    

```cpp
HMODULE LoadLibraryA(
  LPCSTR lpLibFileName
);
```

`lpFileName` - Null sonlandırılmış bir dizedir ve modülün adını belirtir (ya `.dll` ya da `.exe` dosyası).     

### pratik örnek  

İlk olarak, kendi `DLL`'imizi oluşturalım. Örneğin, şu şekilde bir şey (`pet.c`):     

```cpp
/*
pet.dll - DLL example for LoadLibrary
*/

#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {
  switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
      break;
    case DLL_PROCESS_DETACH:
      break;
    case DLL_THREAD_ATTACH:
      break;
    case DLL_THREAD_DETACH:
      break;
  }
  return TRUE;
}

__declspec(dllexport) int _cdecl Cat() {
  MessageBox(NULL, "meow-meow", "=^..^=", MB_OK);
  return 1;
}

__declspec(dllexport) int _cdecl Mouse() {
  MessageBox(NULL, "squeak-squeak", "<:3()~", MB_OK);
  return 1;
}
```

Ardından, bu `DLL`'i yükleyecek uygulamamızı oluşturalım. `LoadLibrary` mantığının basit bir uygulaması şu şekilde görünecek:    

```cpp
/*
 * hack.c - LoadLibrary implementation. C++ implementation
 * @cocomelonc
 * https://cocomelonc.github.io/tutorial/2023/04/27/malware-tricks-27.html
*/
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winternl.h>

typedef int (__cdecl *CatProc)();
typedef int (__cdecl *MouseProc)();

typedef NTSTATUS(NTAPI *pLdrLoadDll) (
    PWCHAR PathToFile,
    ULONG Flags,
    PUNICODE_STRING ModuleFileName,
    PHANDLE ModuleHandle
);

typedef VOID (NTAPI *pRtlInitUnicodeString)(PUNICODE_STRING DestinationString,
 PCWSTR SourceString);

HMODULE MyLoadLibrary(LPCWSTR lpFileName) {
    UNICODE_STRING ustrModule;
    HANDLE hModule = NULL;

    HMODULE hNtdll = GetModuleHandle("ntdll.dll");
    pRtlInitUnicodeString RtlInitUnicodeString = 
    (pRtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");

    RtlInitUnicodeString(&ustrModule, lpFileName);

    pLdrLoadDll myLdrLoadDll = (pLdrLoadDll)
    GetProcAddress(GetModuleHandle("ntdll.dll"), "LdrLoadDll");
    if (!myLdrLoadDll) {
        return NULL;
    }

    NTSTATUS status = myLdrLoadDll(NULL, 0, &ustrModule, &hModule);
    return (HMODULE)hModule;
}

int main() {
    HMODULE petDll = MyLoadLibrary(L"pet.dll");
    if (petDll) {
        CatProc catFunc = (CatProc) GetProcAddress(petDll, "Cat");
        MouseProc mouseFunc = (MouseProc) GetProcAddress(petDll, "Mouse");
        if ((catFunc != NULL) && (mouseFunc != NULL)) {
            (catFunc) ();
            (mouseFunc) ();
        }
        FreeLibrary(petDll);
    } else {
        printf("failed to load library :(\n");
    }
    return 0;
}
```

Bu uygulama, belgelenmemiş `LdrLoadDll` işlevini kullanır:     

```cpp
NTSYSAPI 
NTSTATUS
NTAPI
LdrLoadDll(
  IN PWCHAR               PathToFile OPTIONAL,
  IN ULONG                Flags OPTIONAL,
  IN PUNICODE_STRING      ModuleFileName,
  OUT PHANDLE             ModuleHandle );
```

bu işlev, `ntdll.dll` kütüphanesinin bir parçasıdır. `LdrLoadDll` işlevini kullanarak, gerekli parametreleri sağlayarak bir kütüphaneyi manuel olarak yükleyebiliriz.    

Peki, `MyLoadLibrary` ile `DLL`'imizi diğer uygulamalarda kullanabilir miyiz? Evet, kullanabiliriz. Ayrıca, gördüğünüz gibi, `GetProcAddress` ile işlev adreslerini alabiliriz.     

Ayrıca, doğrudan işlev çağrısı yerine, `RtlInitUnicodeString` işlev göstericisini kullanıyoruz.       

### demo

Hadi her şeyi pratikte görelim. İlk olarak, `pet.c` dosyamızı derleyelim:      

```bash
x86_64-w64-mingw32-gcc -shared -o pet.dll pet.c
```

![av-evasion](./images/94/2023-04-28_15-03.png){width="80%"}      

Ardından, "kötü amaçlı yazılım" uygulamamız olan `hack.cpp` dosyasını derleyelim:     

```bash
x86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe \
-I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ \
-static-libgcc -fpermissive
```

![av-evasion](./images/94/2023-04-28_15-05.png){width="80%"}      

Son olarak, bunu hedef makinede (`Windows 10 x64`) çalıştırın:    

```powershell
.\hack.exe
```

![av-evasion](./images/94/2023-04-28_15-07.png){width="80%"}      

![av-evasion](./images/94/2023-04-28_15-08.png){width="80%"}      

![av-evasion](./images/94/2023-04-28_16-35.png){width="80%"}        

Gördüğünüz gibi, her şey mükemmel çalıştı! =^..^=

Umarım bu yazı, mavi takım üyelerine bu ilginç kötü amaçlı yazılım geliştirme tekniği hakkında farkındalık kazandırır ve kırmızı takım üyelerinin cephanelerine bir silah ekler.     

[LoadLibrary](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)     
[GetProcAddress](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)    
[GetModuleHandle](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)     
[RtlInitUnicodeString](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlinitunicodestring)    
[github'taki kaynak kod](https://github.com/cocomelonc/meow/tree/master/2023-04-27-malware-tricks-27)     
